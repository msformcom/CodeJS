import { isFunction } from '../util/isFunction.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { identity } from '../util/identity.mjs';
/**
 * Used to perform side-effects for notifications from the source observable
 *
 * <span class="informal">Used when you want to affect outside state with a notification without altering the notification</span>
 *
 * ![](tap.png)
 *
 * Tap is designed to allow the developer a designated place to perform side effects. While you _could_ perform side-effects
 * inside of a `map` or a `mergeMap`, that would make their mapping functions impure, which isn't always a big deal, but will
 * make it so you can't do things like memoize those functions. The `tap` operator is designed solely for such side-effects to
 * help you remove side-effects from other operations.
 *
 * For any notification, next, error, or complete, `tap` will call the appropriate callback you have provided to it, via a function
 * reference, or a partial observer, then pass that notification down the stream.
 *
 * The observable returned by `tap` is an exact mirror of the source, with one exception: Any error that occurs -- synchronously -- in a handler
 * provided to `tap` will be emitted as an error from the returned observable.
 *
 * > Be careful! You can mutate objects as they pass through the `tap` operator's handlers.
 *
 * The most common use of `tap` is actually for debugging. You can place a `tap(console.log)` anywhere
 * in your observable `pipe`, log out the notifications as they are emitted by the source returned by the previous
 * operation.
 *
 * ## Examples
 *
 * Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1,
 * and emit `'big'` or `'small'` depending on the size of that number. But we wanted to log what the original number
 * was, so we have added a `tap(console.log)`.
 *
 * ```ts
 * import { of, tap, map } from 'rxjs';
 *
 * of(Math.random()).pipe(
 *   tap(console.log),
 *   map(n => n > 0.5 ? 'big' : 'small')
 * ).subscribe(console.log);
 * ```
 *
 * Using `tap` to analyze a value and force an error. Below is an observable where in our system we only
 * want to emit numbers 3 or less we get from another source. We can force our observable to error
 * using `tap`.
 *
 * ```ts
 * import { of, tap } from 'rxjs';
 *
 * const source = of(1, 2, 3, 4, 5);
 *
 * source.pipe(
 *   tap(n => {
 *     if (n > 3) {
 *       throw new TypeError(`Value ${ n } is greater than 3`);
 *     }
 *   })
 * )
 * .subscribe({ next: console.log, error: err => console.log(err.message) });
 * ```
 *
 * We want to know when an observable completes before moving on to the next observable. The system
 * below will emit a random series of `'X'` characters from 3 different observables in sequence. The
 * only way we know when one observable completes and moves to the next one, in this case, is because
 * we have added a `tap` with the side effect of logging to console.
 *
 * ```ts
 * import { of, concatMap, interval, take, map, tap } from 'rxjs';
 *
 * of(1, 2, 3).pipe(
 *   concatMap(n => interval(1000).pipe(
 *     take(Math.round(Math.random() * 10)),
 *     map(() => 'X'),
 *     tap({ complete: () => console.log(`Done with ${ n }`) })
 *   ))
 * )
 * .subscribe(console.log);
 * ```
 *
 * @see {@link finalize}
 * @see {@link TapObserver}
 *
 * @param observerOrNext A next handler or partial observer
 * @param error An error handler
 * @param complete A completion handler
 * @return A function that returns an Observable identical to the source, but
 * runs the specified Observer or callback(s) for each item.
 */
export function tap(observerOrNext, error, complete) {
    // We have to check to see not only if next is a function,
    // but if error or complete were passed. This is because someone
    // could technically call tap like `tap(null, fn)` or `tap(null, null, fn)`.
    const tapObserver = isFunction(observerOrNext) || error || complete
        ? // tslint:disable-next-line: no-object-literal-type-assertion
            { next: observerOrNext, error, complete }
        : observerOrNext;
    return tapObserver
        ? operate((source, subscriber) => {
            var _a;
            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
            let isUnsub = true;
            source.subscribe(createOperatorSubscriber(subscriber, (value) => {
                var _a;
                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
                subscriber.next(value);
            }, () => {
                var _a;
                isUnsub = false;
                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                subscriber.complete();
            }, (err) => {
                var _a;
                isUnsub = false;
                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
                subscriber.error(err);
            }, () => {
                var _a, _b;
                if (isUnsub) {
                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                }
                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
            }));
        })
        : // Tap was called with no valid tap observer or handler
            // (e.g. `tap(null, null, null)` or `tap(null)` or `tap()`)
            // so we're going to just mirror the source.
            identity;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNoRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQTZFNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9GRztBQUNILE1BQU0sVUFBVSxHQUFHLENBQ2pCLGNBQXNFLEVBQ3RFLEtBQWlDLEVBQ2pDLFFBQThCO0lBRTlCLDBEQUEwRDtJQUMxRCxnRUFBZ0U7SUFDaEUsNEVBQTRFO0lBQzVFLE1BQU0sV0FBVyxHQUNmLFVBQVUsQ0FBQyxjQUFjLENBQUMsSUFBSSxLQUFLLElBQUksUUFBUTtRQUM3QyxDQUFDLENBQUMsNkRBQTZEO1lBQzVELEVBQUUsSUFBSSxFQUFFLGNBQXlFLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBOEI7UUFDbkksQ0FBQyxDQUFDLGNBQWMsQ0FBQztJQUVyQixPQUFPLFdBQVc7UUFDaEIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTs7WUFDN0IsTUFBQSxXQUFXLENBQUMsU0FBUywyREFBSSxDQUFDO1lBQzFCLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQztZQUNuQixNQUFNLENBQUMsU0FBUyxDQUNkLHdCQUF3QixDQUN0QixVQUFVLEVBQ1YsQ0FBQyxLQUFLLEVBQUUsRUFBRTs7Z0JBQ1IsTUFBQSxXQUFXLENBQUMsSUFBSSw0REFBRyxLQUFLLENBQUMsQ0FBQztnQkFDMUIsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN6QixDQUFDLEVBQ0QsR0FBRyxFQUFFOztnQkFDSCxPQUFPLEdBQUcsS0FBSyxDQUFDO2dCQUNoQixNQUFBLFdBQVcsQ0FBQyxRQUFRLDJEQUFJLENBQUM7Z0JBQ3pCLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN4QixDQUFDLEVBQ0QsQ0FBQyxHQUFHLEVBQUUsRUFBRTs7Z0JBQ04sT0FBTyxHQUFHLEtBQUssQ0FBQztnQkFDaEIsTUFBQSxXQUFXLENBQUMsS0FBSyw0REFBRyxHQUFHLENBQUMsQ0FBQztnQkFDekIsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN4QixDQUFDLEVBQ0QsR0FBRyxFQUFFOztnQkFDSCxJQUFJLE9BQU8sRUFBRSxDQUFDO29CQUNaLE1BQUEsV0FBVyxDQUFDLFdBQVcsMkRBQUksQ0FBQztnQkFDOUIsQ0FBQztnQkFDRCxNQUFBLFdBQVcsQ0FBQyxRQUFRLDJEQUFJLENBQUM7WUFDM0IsQ0FBQyxDQUNGLENBQ0YsQ0FBQztRQUNKLENBQUMsQ0FBQztRQUNKLENBQUMsQ0FBQyx1REFBdUQ7WUFDdkQsMkRBQTJEO1lBQzNELDRDQUE0QztZQUM1QyxRQUFRLENBQUM7QUFDZixDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBpZGVudGl0eSB9IGZyb20gJy4uL3V0aWwvaWRlbnRpdHknO1xuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB0aGUge0BsaW5rIE9ic2VydmVyfSBpbnRlcmZhY2UgdXNlZCBvbmx5IGJ5IHRoZSB7QGxpbmsgdGFwfSBvcGVyYXRvci5cbiAqXG4gKiBJdCBwcm92aWRlcyBhIHVzZWZ1bCBzZXQgb2YgY2FsbGJhY2tzIGEgdXNlciBjYW4gcmVnaXN0ZXIgdG8gZG8gc2lkZS1lZmZlY3RzIGluXG4gKiBjYXNlcyBvdGhlciB0aGFuIHdoYXQgdGhlIHVzdWFsIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2tzIGFyZVxuICogKHtAbGluayBndWlkZS9nbG9zc2FyeS1hbmQtc2VtYW50aWNzI25leHQgbmV4dH0sXG4gKiB7QGxpbmsgZ3VpZGUvZ2xvc3NhcnktYW5kLXNlbWFudGljcyNlcnJvciBlcnJvcn0gYW5kL29yXG4gKiB7QGxpbmsgZ3VpZGUvZ2xvc3NhcnktYW5kLXNlbWFudGljcyNjb21wbGV0ZSBjb21wbGV0ZX0pLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50LCBzd2l0Y2hNYXAsIHRhcCwgaW50ZXJ2YWwsIHRha2UgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UkID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IHJlc3VsdCQgPSBzb3VyY2UkLnBpcGUoXG4gKiAgIHN3aXRjaE1hcCgoXywgaSkgPT4gaSAlIDIgPT09IDBcbiAqICAgICA/IGZyb21FdmVudChkb2N1bWVudCwgJ21vdXNlbW92ZScpLnBpcGUoXG4gKiAgICAgICAgIHRhcCh7XG4gKiAgICAgICAgICAgc3Vic2NyaWJlOiAoKSA9PiBjb25zb2xlLmxvZygnU3Vic2NyaWJlZCB0byB0aGUgbW91c2UgbW92ZSBldmVudHMgYWZ0ZXIgY2xpY2sgIycgKyBpKSxcbiAqICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4gY29uc29sZS5sb2coJ01vdXNlIG1vdmUgZXZlbnRzICMnICsgaSArICcgdW5zdWJzY3JpYmVkJyksXG4gKiAgICAgICAgICAgZmluYWxpemU6ICgpID0+IGNvbnNvbGUubG9nKCdNb3VzZSBtb3ZlIGV2ZW50cyAjJyArIGkgKyAnIGZpbmFsaXplZCcpXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICApXG4gKiAgICAgOiBpbnRlcnZhbCgxXzAwMCkucGlwZShcbiAqICAgICAgICAgdGFrZSg1KSxcbiAqICAgICAgICAgdGFwKHtcbiAqICAgICAgICAgICBzdWJzY3JpYmU6ICgpID0+IGNvbnNvbGUubG9nKCdTdWJzY3JpYmVkIHRvIHRoZSAxLXNlY29uZCBpbnRlcnZhbCBldmVudHMgYWZ0ZXIgY2xpY2sgIycgKyBpKSxcbiAqICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4gY29uc29sZS5sb2coJzEtc2Vjb25kIGludGVydmFsIGV2ZW50cyAjJyArIGkgKyAnIHVuc3Vic2NyaWJlZCcpLFxuICogICAgICAgICAgIGZpbmFsaXplOiAoKSA9PiBjb25zb2xlLmxvZygnMS1zZWNvbmQgaW50ZXJ2YWwgZXZlbnRzICMnICsgaSArICcgZmluYWxpemVkJylcbiAqICAgICAgICAgfSlcbiAqICAgICAgIClcbiAqICAgKVxuICogKTtcbiAqXG4gKiBjb25zdCBzdWJzY3JpcHRpb24gPSByZXN1bHQkLnN1YnNjcmliZSh7XG4gKiAgIG5leHQ6IGNvbnNvbGUubG9nXG4gKiB9KTtcbiAqXG4gKiBzZXRUaW1lb3V0KCgpID0+IHtcbiAqICAgY29uc29sZS5sb2coJ1Vuc3Vic2NyaWJlIGFmdGVyIDYwIHNlY29uZHMnKTtcbiAqICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gKiB9LCA2MF8wMDApO1xuICogYGBgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFwT2JzZXJ2ZXI8VD4gZXh0ZW5kcyBPYnNlcnZlcjxUPiB7XG4gIC8qKlxuICAgKiBUaGUgY2FsbGJhY2sgdGhhdCBgdGFwYCBvcGVyYXRvciBpbnZva2VzIGF0IHRoZSBtb21lbnQgd2hlbiB0aGUgc291cmNlIE9ic2VydmFibGVcbiAgICogZ2V0cyBzdWJzY3JpYmVkIHRvLlxuICAgKi9cbiAgc3Vic2NyaWJlOiAoKSA9PiB2b2lkO1xuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIHRoYXQgYHRhcGAgb3BlcmF0b3IgaW52b2tlcyB3aGVuIGFuIGV4cGxpY2l0XG4gICAqIHtAbGluayBndWlkZS9nbG9zc2FyeS1hbmQtc2VtYW50aWNzI3Vuc3Vic2NyaXB0aW9uIHVuc3Vic2NyaWJlfSBoYXBwZW5zLiBJdCB3b24ndCBnZXQgaW52b2tlZCBvblxuICAgKiBgZXJyb3JgIG9yIGBjb21wbGV0ZWAgZXZlbnRzLlxuICAgKi9cbiAgdW5zdWJzY3JpYmU6ICgpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBUaGUgY2FsbGJhY2sgdGhhdCBgdGFwYCBvcGVyYXRvciBpbnZva2VzIHdoZW4gYW55IGtpbmQgb2ZcbiAgICoge0BsaW5rIGd1aWRlL2dsb3NzYXJ5LWFuZC1zZW1hbnRpY3MjZmluYWxpemF0aW9uIGZpbmFsaXphdGlvbn0gaGFwcGVucyAtIGVpdGhlciB3aGVuXG4gICAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBgZXJyb3JgcyBvciBgY29tcGxldGVgcyBvciB3aGVuIGl0IGdldHMgZXhwbGljaXRseSB1bnN1YnNjcmliZWRcbiAgICogYnkgdGhlIHVzZXIuIFRoZXJlIGlzIG5vIGRpZmZlcmVuY2UgaW4gdXNpbmcgdGhpcyBjYWxsYmFjayBvciB0aGUge0BsaW5rIGZpbmFsaXplfVxuICAgKiBvcGVyYXRvciwgYnV0IGlmIHlvdSdyZSBhbHJlYWR5IHVzaW5nIGB0YXBgIG9wZXJhdG9yLCB5b3UgY2FuIHVzZSB0aGlzIGNhbGxiYWNrXG4gICAqIGluc3RlYWQuIFlvdSdkIGdldCB0aGUgc2FtZSByZXN1bHQgaW4gZWl0aGVyIGNhc2UuXG4gICAqL1xuICBmaW5hbGl6ZTogKCkgPT4gdm9pZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0YXA8VD4ob2JzZXJ2ZXJPck5leHQ/OiBQYXJ0aWFsPFRhcE9ic2VydmVyPFQ+PiB8ICgodmFsdWU6IFQpID0+IHZvaWQpKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+O1xuLyoqIEBkZXByZWNhdGVkIEluc3RlYWQgb2YgcGFzc2luZyBzZXBhcmF0ZSBjYWxsYmFjayBhcmd1bWVudHMsIHVzZSBhbiBvYnNlcnZlciBhcmd1bWVudC4gU2lnbmF0dXJlcyB0YWtpbmcgc2VwYXJhdGUgY2FsbGJhY2sgYXJndW1lbnRzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OC4gRGV0YWlsczogaHR0cHM6Ly9yeGpzLmRldi9kZXByZWNhdGlvbnMvc3Vic2NyaWJlLWFyZ3VtZW50cyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhcDxUPihcbiAgbmV4dD86ICgodmFsdWU6IFQpID0+IHZvaWQpIHwgbnVsbCxcbiAgZXJyb3I/OiAoKGVycm9yOiBhbnkpID0+IHZvaWQpIHwgbnVsbCxcbiAgY29tcGxldGU/OiAoKCkgPT4gdm9pZCkgfCBudWxsXG4pOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD47XG5cbi8qKlxuICogVXNlZCB0byBwZXJmb3JtIHNpZGUtZWZmZWN0cyBmb3Igbm90aWZpY2F0aW9ucyBmcm9tIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZVxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Vc2VkIHdoZW4geW91IHdhbnQgdG8gYWZmZWN0IG91dHNpZGUgc3RhdGUgd2l0aCBhIG5vdGlmaWNhdGlvbiB3aXRob3V0IGFsdGVyaW5nIHRoZSBub3RpZmljYXRpb248L3NwYW4+XG4gKlxuICogIVtdKHRhcC5wbmcpXG4gKlxuICogVGFwIGlzIGRlc2lnbmVkIHRvIGFsbG93IHRoZSBkZXZlbG9wZXIgYSBkZXNpZ25hdGVkIHBsYWNlIHRvIHBlcmZvcm0gc2lkZSBlZmZlY3RzLiBXaGlsZSB5b3UgX2NvdWxkXyBwZXJmb3JtIHNpZGUtZWZmZWN0c1xuICogaW5zaWRlIG9mIGEgYG1hcGAgb3IgYSBgbWVyZ2VNYXBgLCB0aGF0IHdvdWxkIG1ha2UgdGhlaXIgbWFwcGluZyBmdW5jdGlvbnMgaW1wdXJlLCB3aGljaCBpc24ndCBhbHdheXMgYSBiaWcgZGVhbCwgYnV0IHdpbGxcbiAqIG1ha2UgaXQgc28geW91IGNhbid0IGRvIHRoaW5ncyBsaWtlIG1lbW9pemUgdGhvc2UgZnVuY3Rpb25zLiBUaGUgYHRhcGAgb3BlcmF0b3IgaXMgZGVzaWduZWQgc29sZWx5IGZvciBzdWNoIHNpZGUtZWZmZWN0cyB0b1xuICogaGVscCB5b3UgcmVtb3ZlIHNpZGUtZWZmZWN0cyBmcm9tIG90aGVyIG9wZXJhdGlvbnMuXG4gKlxuICogRm9yIGFueSBub3RpZmljYXRpb24sIG5leHQsIGVycm9yLCBvciBjb21wbGV0ZSwgYHRhcGAgd2lsbCBjYWxsIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFjayB5b3UgaGF2ZSBwcm92aWRlZCB0byBpdCwgdmlhIGEgZnVuY3Rpb25cbiAqIHJlZmVyZW5jZSwgb3IgYSBwYXJ0aWFsIG9ic2VydmVyLCB0aGVuIHBhc3MgdGhhdCBub3RpZmljYXRpb24gZG93biB0aGUgc3RyZWFtLlxuICpcbiAqIFRoZSBvYnNlcnZhYmxlIHJldHVybmVkIGJ5IGB0YXBgIGlzIGFuIGV4YWN0IG1pcnJvciBvZiB0aGUgc291cmNlLCB3aXRoIG9uZSBleGNlcHRpb246IEFueSBlcnJvciB0aGF0IG9jY3VycyAtLSBzeW5jaHJvbm91c2x5IC0tIGluIGEgaGFuZGxlclxuICogcHJvdmlkZWQgdG8gYHRhcGAgd2lsbCBiZSBlbWl0dGVkIGFzIGFuIGVycm9yIGZyb20gdGhlIHJldHVybmVkIG9ic2VydmFibGUuXG4gKlxuICogPiBCZSBjYXJlZnVsISBZb3UgY2FuIG11dGF0ZSBvYmplY3RzIGFzIHRoZXkgcGFzcyB0aHJvdWdoIHRoZSBgdGFwYCBvcGVyYXRvcidzIGhhbmRsZXJzLlxuICpcbiAqIFRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgYHRhcGAgaXMgYWN0dWFsbHkgZm9yIGRlYnVnZ2luZy4gWW91IGNhbiBwbGFjZSBhIGB0YXAoY29uc29sZS5sb2cpYCBhbnl3aGVyZVxuICogaW4geW91ciBvYnNlcnZhYmxlIGBwaXBlYCwgbG9nIG91dCB0aGUgbm90aWZpY2F0aW9ucyBhcyB0aGV5IGFyZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgcmV0dXJuZWQgYnkgdGhlIHByZXZpb3VzXG4gKiBvcGVyYXRpb24uXG4gKlxuICogIyMgRXhhbXBsZXNcbiAqXG4gKiBDaGVjayBhIHJhbmRvbSBudW1iZXIgYmVmb3JlIGl0IGlzIGhhbmRsZWQuIEJlbG93IGlzIGFuIG9ic2VydmFibGUgdGhhdCB3aWxsIHVzZSBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLFxuICogYW5kIGVtaXQgYCdiaWcnYCBvciBgJ3NtYWxsJ2AgZGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIHRoYXQgbnVtYmVyLiBCdXQgd2Ugd2FudGVkIHRvIGxvZyB3aGF0IHRoZSBvcmlnaW5hbCBudW1iZXJcbiAqIHdhcywgc28gd2UgaGF2ZSBhZGRlZCBhIGB0YXAoY29uc29sZS5sb2cpYC5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgb2YsIHRhcCwgbWFwIH0gZnJvbSAncnhqcyc7XG4gKlxuICogb2YoTWF0aC5yYW5kb20oKSkucGlwZShcbiAqICAgdGFwKGNvbnNvbGUubG9nKSxcbiAqICAgbWFwKG4gPT4gbiA+IDAuNSA/ICdiaWcnIDogJ3NtYWxsJylcbiAqICkuc3Vic2NyaWJlKGNvbnNvbGUubG9nKTtcbiAqIGBgYFxuICpcbiAqIFVzaW5nIGB0YXBgIHRvIGFuYWx5emUgYSB2YWx1ZSBhbmQgZm9yY2UgYW4gZXJyb3IuIEJlbG93IGlzIGFuIG9ic2VydmFibGUgd2hlcmUgaW4gb3VyIHN5c3RlbSB3ZSBvbmx5XG4gKiB3YW50IHRvIGVtaXQgbnVtYmVycyAzIG9yIGxlc3Mgd2UgZ2V0IGZyb20gYW5vdGhlciBzb3VyY2UuIFdlIGNhbiBmb3JjZSBvdXIgb2JzZXJ2YWJsZSB0byBlcnJvclxuICogdXNpbmcgYHRhcGAuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mLCB0YXAgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UgPSBvZigxLCAyLCAzLCA0LCA1KTtcbiAqXG4gKiBzb3VyY2UucGlwZShcbiAqICAgdGFwKG4gPT4ge1xuICogICAgIGlmIChuID4gMykge1xuICogICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVmFsdWUgJHsgbiB9IGlzIGdyZWF0ZXIgdGhhbiAzYCk7XG4gKiAgICAgfVxuICogICB9KVxuICogKVxuICogLnN1YnNjcmliZSh7IG5leHQ6IGNvbnNvbGUubG9nLCBlcnJvcjogZXJyID0+IGNvbnNvbGUubG9nKGVyci5tZXNzYWdlKSB9KTtcbiAqIGBgYFxuICpcbiAqIFdlIHdhbnQgdG8ga25vdyB3aGVuIGFuIG9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBtb3Zpbmcgb24gdG8gdGhlIG5leHQgb2JzZXJ2YWJsZS4gVGhlIHN5c3RlbVxuICogYmVsb3cgd2lsbCBlbWl0IGEgcmFuZG9tIHNlcmllcyBvZiBgJ1gnYCBjaGFyYWN0ZXJzIGZyb20gMyBkaWZmZXJlbnQgb2JzZXJ2YWJsZXMgaW4gc2VxdWVuY2UuIFRoZVxuICogb25seSB3YXkgd2Uga25vdyB3aGVuIG9uZSBvYnNlcnZhYmxlIGNvbXBsZXRlcyBhbmQgbW92ZXMgdG8gdGhlIG5leHQgb25lLCBpbiB0aGlzIGNhc2UsIGlzIGJlY2F1c2VcbiAqIHdlIGhhdmUgYWRkZWQgYSBgdGFwYCB3aXRoIHRoZSBzaWRlIGVmZmVjdCBvZiBsb2dnaW5nIHRvIGNvbnNvbGUuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mLCBjb25jYXRNYXAsIGludGVydmFsLCB0YWtlLCBtYXAsIHRhcCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIG9mKDEsIDIsIDMpLnBpcGUoXG4gKiAgIGNvbmNhdE1hcChuID0+IGludGVydmFsKDEwMDApLnBpcGUoXG4gKiAgICAgdGFrZShNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMCkpLFxuICogICAgIG1hcCgoKSA9PiAnWCcpLFxuICogICAgIHRhcCh7IGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZyhgRG9uZSB3aXRoICR7IG4gfWApIH0pXG4gKiAgICkpXG4gKiApXG4gKiAuc3Vic2NyaWJlKGNvbnNvbGUubG9nKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZpbmFsaXplfVxuICogQHNlZSB7QGxpbmsgVGFwT2JzZXJ2ZXJ9XG4gKlxuICogQHBhcmFtIG9ic2VydmVyT3JOZXh0IEEgbmV4dCBoYW5kbGVyIG9yIHBhcnRpYWwgb2JzZXJ2ZXJcbiAqIEBwYXJhbSBlcnJvciBBbiBlcnJvciBoYW5kbGVyXG4gKiBAcGFyYW0gY29tcGxldGUgQSBjb21wbGV0aW9uIGhhbmRsZXJcbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSBpZGVudGljYWwgdG8gdGhlIHNvdXJjZSwgYnV0XG4gKiBydW5zIHRoZSBzcGVjaWZpZWQgT2JzZXJ2ZXIgb3IgY2FsbGJhY2socykgZm9yIGVhY2ggaXRlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhcDxUPihcbiAgb2JzZXJ2ZXJPck5leHQ/OiBQYXJ0aWFsPFRhcE9ic2VydmVyPFQ+PiB8ICgodmFsdWU6IFQpID0+IHZvaWQpIHwgbnVsbCxcbiAgZXJyb3I/OiAoKGU6IGFueSkgPT4gdm9pZCkgfCBudWxsLFxuICBjb21wbGV0ZT86ICgoKSA9PiB2b2lkKSB8IG51bGxcbik6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPiB7XG4gIC8vIFdlIGhhdmUgdG8gY2hlY2sgdG8gc2VlIG5vdCBvbmx5IGlmIG5leHQgaXMgYSBmdW5jdGlvbixcbiAgLy8gYnV0IGlmIGVycm9yIG9yIGNvbXBsZXRlIHdlcmUgcGFzc2VkLiBUaGlzIGlzIGJlY2F1c2Ugc29tZW9uZVxuICAvLyBjb3VsZCB0ZWNobmljYWxseSBjYWxsIHRhcCBsaWtlIGB0YXAobnVsbCwgZm4pYCBvciBgdGFwKG51bGwsIG51bGwsIGZuKWAuXG4gIGNvbnN0IHRhcE9ic2VydmVyID1cbiAgICBpc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSB8fCBlcnJvciB8fCBjb21wbGV0ZVxuICAgICAgPyAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLW9iamVjdC1saXRlcmFsLXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICh7IG5leHQ6IG9ic2VydmVyT3JOZXh0IGFzIEV4Y2x1ZGU8dHlwZW9mIG9ic2VydmVyT3JOZXh0LCBQYXJ0aWFsPFRhcE9ic2VydmVyPFQ+Pj4sIGVycm9yLCBjb21wbGV0ZSB9IGFzIFBhcnRpYWw8VGFwT2JzZXJ2ZXI8VD4+KVxuICAgICAgOiBvYnNlcnZlck9yTmV4dDtcblxuICByZXR1cm4gdGFwT2JzZXJ2ZXJcbiAgICA/IG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICB0YXBPYnNlcnZlci5zdWJzY3JpYmU/LigpO1xuICAgICAgICBsZXQgaXNVbnN1YiA9IHRydWU7XG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICB0YXBPYnNlcnZlci5uZXh0Py4odmFsdWUpO1xuICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgaXNVbnN1YiA9IGZhbHNlO1xuICAgICAgICAgICAgICB0YXBPYnNlcnZlci5jb21wbGV0ZT8uKCk7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGlzVW5zdWIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGFwT2JzZXJ2ZXIuZXJyb3I/LihlcnIpO1xuICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNVbnN1Yikge1xuICAgICAgICAgICAgICAgIHRhcE9ic2VydmVyLnVuc3Vic2NyaWJlPy4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXBPYnNlcnZlci5maW5hbGl6ZT8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSlcbiAgICA6IC8vIFRhcCB3YXMgY2FsbGVkIHdpdGggbm8gdmFsaWQgdGFwIG9ic2VydmVyIG9yIGhhbmRsZXJcbiAgICAgIC8vIChlLmcuIGB0YXAobnVsbCwgbnVsbCwgbnVsbClgIG9yIGB0YXAobnVsbClgIG9yIGB0YXAoKWApXG4gICAgICAvLyBzbyB3ZSdyZSBnb2luZyB0byBqdXN0IG1pcnJvciB0aGUgc291cmNlLlxuICAgICAgaWRlbnRpdHk7XG59XG4iXX0=
