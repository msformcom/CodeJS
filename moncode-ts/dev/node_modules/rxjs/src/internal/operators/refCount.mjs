import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way
 * you can connect to it.
 *
 * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if
 * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it
 * unsubscribes from the source. This way you can make sure that everything before the *published*
 * refCount has only a single subscription independently of the number of subscribers to the target
 * observable.
 *
 * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator
 * (making the observable hot) and the *refCount* operator in a sequence.
 *
 * ![](refCount.png)
 *
 * ## Example
 *
 * In the following example there are two intervals turned into connectable observables
 * by using the *publish* operator. The first one uses the *refCount* operator, the
 * second one does not use it. You will notice that a connectable observable does nothing
 * until you call its connect function.
 *
 * ```ts
 * import { interval, tap, publish, refCount } from 'rxjs';
 *
 * // Turn the interval observable into a ConnectableObservable (hot)
 * const refCountInterval = interval(400).pipe(
 *   tap(num => console.log(`refCount ${ num }`)),
 *   publish(),
 *   refCount()
 * );
 *
 * const publishedInterval = interval(400).pipe(
 *   tap(num => console.log(`publish ${ num }`)),
 *   publish()
 * );
 *
 * refCountInterval.subscribe();
 * refCountInterval.subscribe();
 * // 'refCount 0' -----> 'refCount 1' -----> etc
 * // All subscriptions will receive the same value and the tap (and
 * // every other operator) before the `publish` operator will be executed
 * // only once per event independently of the number of subscriptions.
 *
 * publishedInterval.subscribe();
 * // Nothing happens until you call .connect() on the observable.
 * ```
 *
 * @return A function that returns an Observable that automates the connection
 * to ConnectableObservable.
 * @see {@link ConnectableObservable}
 * @see {@link share}
 * @see {@link publish}
 * @deprecated Replaced with the {@link share} operator. How `share` is used
 * will depend on the connectable observable you created just prior to the
 * `refCount` operator.
 * Details: https://rxjs.dev/deprecations/multicasting
 */
export function refCount() {
    return operate((source, subscriber) => {
        let connection = null;
        source._refCount++;
        const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {
            if (!source || source._refCount <= 0 || 0 < --source._refCount) {
                connection = null;
                return;
            }
            ///
            // Compare the local RefCountSubscriber's connection Subscription to the
            // connection Subscription on the shared ConnectableObservable. In cases
            // where the ConnectableObservable source synchronously emits values, and
            // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
            // execution continues to here before the RefCountOperator has a chance to
            // supply the RefCountSubscriber with the shared connection Subscription.
            // For example:
            // ```
            // range(0, 10).pipe(
            //   publish(),
            //   refCount(),
            //   take(5),
            // )
            // .subscribe();
            // ```
            // In order to account for this case, RefCountSubscriber should only dispose
            // the ConnectableObservable's shared connection Subscription if the
            // connection Subscription exists, *and* either:
            //   a. RefCountSubscriber doesn't have a reference to the shared connection
            //      Subscription yet, or,
            //   b. RefCountSubscriber's connection Subscription reference is identical
            //      to the shared connection Subscription
            ///
            const sharedConnection = source._connection;
            const conn = connection;
            connection = null;
            if (sharedConnection && (!conn || sharedConnection === conn)) {
                sharedConnection.unsubscribe();
            }
            subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) {
            connection = source.connect();
        }
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVmQ291bnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUVoRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeURHO0FBQ0gsTUFBTSxVQUFVLFFBQVE7SUFDdEIsT0FBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDcEMsSUFBSSxVQUFVLEdBQXdCLElBQUksQ0FBQztRQUUxQyxNQUFjLENBQUMsU0FBUyxFQUFFLENBQUM7UUFFNUIsTUFBTSxVQUFVLEdBQUcsd0JBQXdCLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRTtZQUM1RixJQUFJLENBQUMsTUFBTSxJQUFLLE1BQWMsQ0FBQyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFHLE1BQWMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDakYsVUFBVSxHQUFHLElBQUksQ0FBQztnQkFDbEIsT0FBTztZQUNULENBQUM7WUFFRCxHQUFHO1lBQ0gsd0VBQXdFO1lBQ3hFLHdFQUF3RTtZQUN4RSx5RUFBeUU7WUFDekUsMkVBQTJFO1lBQzNFLDBFQUEwRTtZQUMxRSx5RUFBeUU7WUFDekUsZUFBZTtZQUNmLE1BQU07WUFDTixxQkFBcUI7WUFDckIsZUFBZTtZQUNmLGdCQUFnQjtZQUNoQixhQUFhO1lBQ2IsSUFBSTtZQUNKLGdCQUFnQjtZQUNoQixNQUFNO1lBQ04sNEVBQTRFO1lBQzVFLG9FQUFvRTtZQUNwRSxnREFBZ0Q7WUFDaEQsNEVBQTRFO1lBQzVFLDZCQUE2QjtZQUM3QiwyRUFBMkU7WUFDM0UsNkNBQTZDO1lBQzdDLEdBQUc7WUFFSCxNQUFNLGdCQUFnQixHQUFJLE1BQWMsQ0FBQyxXQUFXLENBQUM7WUFDckQsTUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDO1lBQ3hCLFVBQVUsR0FBRyxJQUFJLENBQUM7WUFFbEIsSUFBSSxnQkFBZ0IsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLGdCQUFnQixLQUFLLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQzdELGdCQUFnQixDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ2pDLENBQUM7WUFFRCxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDM0IsQ0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTdCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDdkIsVUFBVSxHQUFJLE1BQW1DLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDOUQsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlZkNvdW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGFibGVPYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuXG4vKipcbiAqIE1ha2UgYSB7QGxpbmsgQ29ubmVjdGFibGVPYnNlcnZhYmxlfSBiZWhhdmUgbGlrZSBhIG9yZGluYXJ5IG9ic2VydmFibGUgYW5kIGF1dG9tYXRlcyB0aGUgd2F5XG4gKiB5b3UgY2FuIGNvbm5lY3QgdG8gaXQuXG4gKlxuICogSW50ZXJuYWxseSBpdCBjb3VudHMgdGhlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIG9ic2VydmFibGUgYW5kIHN1YnNjcmliZXMgKG9ubHkgb25jZSkgdG8gdGhlIHNvdXJjZSBpZlxuICogdGhlIG51bWJlciBvZiBzdWJzY3JpcHRpb25zIGlzIGxhcmdlciB0aGFuIDAuIElmIHRoZSBudW1iZXIgb2Ygc3Vic2NyaXB0aW9ucyBpcyBzbWFsbGVyIHRoYW4gMSwgaXRcbiAqIHVuc3Vic2NyaWJlcyBmcm9tIHRoZSBzb3VyY2UuIFRoaXMgd2F5IHlvdSBjYW4gbWFrZSBzdXJlIHRoYXQgZXZlcnl0aGluZyBiZWZvcmUgdGhlICpwdWJsaXNoZWQqXG4gKiByZWZDb3VudCBoYXMgb25seSBhIHNpbmdsZSBzdWJzY3JpcHRpb24gaW5kZXBlbmRlbnRseSBvZiB0aGUgbnVtYmVyIG9mIHN1YnNjcmliZXJzIHRvIHRoZSB0YXJnZXRcbiAqIG9ic2VydmFibGUuXG4gKlxuICogTm90ZSB0aGF0IHVzaW5nIHRoZSB7QGxpbmsgc2hhcmV9IG9wZXJhdG9yIGlzIGV4YWN0bHkgdGhlIHNhbWUgYXMgdXNpbmcgdGhlIGBtdWx0aWNhc3QoKCkgPT4gbmV3IFN1YmplY3QoKSlgIG9wZXJhdG9yXG4gKiAobWFraW5nIHRoZSBvYnNlcnZhYmxlIGhvdCkgYW5kIHRoZSAqcmVmQ291bnQqIG9wZXJhdG9yIGluIGEgc2VxdWVuY2UuXG4gKlxuICogIVtdKHJlZkNvdW50LnBuZylcbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlIHRoZXJlIGFyZSB0d28gaW50ZXJ2YWxzIHR1cm5lZCBpbnRvIGNvbm5lY3RhYmxlIG9ic2VydmFibGVzXG4gKiBieSB1c2luZyB0aGUgKnB1Ymxpc2gqIG9wZXJhdG9yLiBUaGUgZmlyc3Qgb25lIHVzZXMgdGhlICpyZWZDb3VudCogb3BlcmF0b3IsIHRoZVxuICogc2Vjb25kIG9uZSBkb2VzIG5vdCB1c2UgaXQuIFlvdSB3aWxsIG5vdGljZSB0aGF0IGEgY29ubmVjdGFibGUgb2JzZXJ2YWJsZSBkb2VzIG5vdGhpbmdcbiAqIHVudGlsIHlvdSBjYWxsIGl0cyBjb25uZWN0IGZ1bmN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpbnRlcnZhbCwgdGFwLCBwdWJsaXNoLCByZWZDb3VudCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIC8vIFR1cm4gdGhlIGludGVydmFsIG9ic2VydmFibGUgaW50byBhIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSAoaG90KVxuICogY29uc3QgcmVmQ291bnRJbnRlcnZhbCA9IGludGVydmFsKDQwMCkucGlwZShcbiAqICAgdGFwKG51bSA9PiBjb25zb2xlLmxvZyhgcmVmQ291bnQgJHsgbnVtIH1gKSksXG4gKiAgIHB1Ymxpc2goKSxcbiAqICAgcmVmQ291bnQoKVxuICogKTtcbiAqXG4gKiBjb25zdCBwdWJsaXNoZWRJbnRlcnZhbCA9IGludGVydmFsKDQwMCkucGlwZShcbiAqICAgdGFwKG51bSA9PiBjb25zb2xlLmxvZyhgcHVibGlzaCAkeyBudW0gfWApKSxcbiAqICAgcHVibGlzaCgpXG4gKiApO1xuICpcbiAqIHJlZkNvdW50SW50ZXJ2YWwuc3Vic2NyaWJlKCk7XG4gKiByZWZDb3VudEludGVydmFsLnN1YnNjcmliZSgpO1xuICogLy8gJ3JlZkNvdW50IDAnIC0tLS0tPiAncmVmQ291bnQgMScgLS0tLS0+IGV0Y1xuICogLy8gQWxsIHN1YnNjcmlwdGlvbnMgd2lsbCByZWNlaXZlIHRoZSBzYW1lIHZhbHVlIGFuZCB0aGUgdGFwIChhbmRcbiAqIC8vIGV2ZXJ5IG90aGVyIG9wZXJhdG9yKSBiZWZvcmUgdGhlIGBwdWJsaXNoYCBvcGVyYXRvciB3aWxsIGJlIGV4ZWN1dGVkXG4gKiAvLyBvbmx5IG9uY2UgcGVyIGV2ZW50IGluZGVwZW5kZW50bHkgb2YgdGhlIG51bWJlciBvZiBzdWJzY3JpcHRpb25zLlxuICpcbiAqIHB1Ymxpc2hlZEludGVydmFsLnN1YnNjcmliZSgpO1xuICogLy8gTm90aGluZyBoYXBwZW5zIHVudGlsIHlvdSBjYWxsIC5jb25uZWN0KCkgb24gdGhlIG9ic2VydmFibGUuXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBhdXRvbWF0ZXMgdGhlIGNvbm5lY3Rpb25cbiAqIHRvIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5cbiAqIEBzZWUge0BsaW5rIENvbm5lY3RhYmxlT2JzZXJ2YWJsZX1cbiAqIEBzZWUge0BsaW5rIHNoYXJlfVxuICogQHNlZSB7QGxpbmsgcHVibGlzaH1cbiAqIEBkZXByZWNhdGVkIFJlcGxhY2VkIHdpdGggdGhlIHtAbGluayBzaGFyZX0gb3BlcmF0b3IuIEhvdyBgc2hhcmVgIGlzIHVzZWRcbiAqIHdpbGwgZGVwZW5kIG9uIHRoZSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlIHlvdSBjcmVhdGVkIGp1c3QgcHJpb3IgdG8gdGhlXG4gKiBgcmVmQ291bnRgIG9wZXJhdG9yLlxuICogRGV0YWlsczogaHR0cHM6Ly9yeGpzLmRldi9kZXByZWNhdGlvbnMvbXVsdGljYXN0aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWZDb3VudDxUPigpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4ge1xuICByZXR1cm4gb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgbGV0IGNvbm5lY3Rpb246IFN1YnNjcmlwdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gICAgKHNvdXJjZSBhcyBhbnkpLl9yZWZDb3VudCsrO1xuXG4gICAgY29uc3QgcmVmQ291bnRlciA9IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAoKSA9PiB7XG4gICAgICBpZiAoIXNvdXJjZSB8fCAoc291cmNlIGFzIGFueSkuX3JlZkNvdW50IDw9IDAgfHwgMCA8IC0tKHNvdXJjZSBhcyBhbnkpLl9yZWZDb3VudCkge1xuICAgICAgICBjb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLy9cbiAgICAgIC8vIENvbXBhcmUgdGhlIGxvY2FsIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHRvIHRoZVxuICAgICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gb24gdGhlIHNoYXJlZCBDb25uZWN0YWJsZU9ic2VydmFibGUuIEluIGNhc2VzXG4gICAgICAvLyB3aGVyZSB0aGUgQ29ubmVjdGFibGVPYnNlcnZhYmxlIHNvdXJjZSBzeW5jaHJvbm91c2x5IGVtaXRzIHZhbHVlcywgYW5kXG4gICAgICAvLyB0aGUgUmVmQ291bnRTdWJzY3JpYmVyJ3MgZG93bnN0cmVhbSBPYnNlcnZlcnMgc3luY2hyb25vdXNseSB1bnN1YnNjcmliZSxcbiAgICAgIC8vIGV4ZWN1dGlvbiBjb250aW51ZXMgdG8gaGVyZSBiZWZvcmUgdGhlIFJlZkNvdW50T3BlcmF0b3IgaGFzIGEgY2hhbmNlIHRvXG4gICAgICAvLyBzdXBwbHkgdGhlIFJlZkNvdW50U3Vic2NyaWJlciB3aXRoIHRoZSBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24uXG4gICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgIC8vIGBgYFxuICAgICAgLy8gcmFuZ2UoMCwgMTApLnBpcGUoXG4gICAgICAvLyAgIHB1Ymxpc2goKSxcbiAgICAgIC8vICAgcmVmQ291bnQoKSxcbiAgICAgIC8vICAgdGFrZSg1KSxcbiAgICAgIC8vIClcbiAgICAgIC8vIC5zdWJzY3JpYmUoKTtcbiAgICAgIC8vIGBgYFxuICAgICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhpcyBjYXNlLCBSZWZDb3VudFN1YnNjcmliZXIgc2hvdWxkIG9ubHkgZGlzcG9zZVxuICAgICAgLy8gdGhlIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSdzIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBpZiB0aGVcbiAgICAgIC8vIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGV4aXN0cywgKmFuZCogZWl0aGVyOlxuICAgICAgLy8gICBhLiBSZWZDb3VudFN1YnNjcmliZXIgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvblxuICAgICAgLy8gICAgICBTdWJzY3JpcHRpb24geWV0LCBvcixcbiAgICAgIC8vICAgYi4gUmVmQ291bnRTdWJzY3JpYmVyJ3MgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gcmVmZXJlbmNlIGlzIGlkZW50aWNhbFxuICAgICAgLy8gICAgICB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uXG4gICAgICAvLy9cblxuICAgICAgY29uc3Qgc2hhcmVkQ29ubmVjdGlvbiA9IChzb3VyY2UgYXMgYW55KS5fY29ubmVjdGlvbjtcbiAgICAgIGNvbnN0IGNvbm4gPSBjb25uZWN0aW9uO1xuICAgICAgY29ubmVjdGlvbiA9IG51bGw7XG5cbiAgICAgIGlmIChzaGFyZWRDb25uZWN0aW9uICYmICghY29ubiB8fCBzaGFyZWRDb25uZWN0aW9uID09PSBjb25uKSkge1xuICAgICAgICBzaGFyZWRDb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG5cbiAgICAgIHN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICB9KTtcblxuICAgIHNvdXJjZS5zdWJzY3JpYmUocmVmQ291bnRlcik7XG5cbiAgICBpZiAoIXJlZkNvdW50ZXIuY2xvc2VkKSB7XG4gICAgICBjb25uZWN0aW9uID0gKHNvdXJjZSBhcyBDb25uZWN0YWJsZU9ic2VydmFibGU8VD4pLmNvbm5lY3QoKTtcbiAgICB9XG4gIH0pO1xufVxuIl19
