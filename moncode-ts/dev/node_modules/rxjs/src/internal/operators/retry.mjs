import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { identity } from '../util/identity.mjs';
import { timer } from '../observable/timer.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`.
 *
 * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of
 * `count` resubscriptions rather than propagating the `error` call.
 *
 * ![](retry.png)
 *
 * The number of retries is determined by the `count` parameter. It can be set either by passing a number to
 * `retry` function or by setting `count` property when `retry` is configured using {@link RetryConfig}. If
 * `count` is omitted, `retry` will try to resubscribe on errors infinite number of times.
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those
 * emitted during failed subscriptions. For example, if an Observable fails at first but emits `[1, 2]` then
 * succeeds the second time and emits: `[1, 2, 3, 4, 5, complete]` then the complete stream of emissions and
 * notifications would be: `[1, 2, 1, 2, 3, 4, 5, complete]`.
 *
 * ## Example
 *
 * ```ts
 * import { interval, mergeMap, throwError, of, retry } from 'rxjs';
 *
 * const source = interval(1000);
 * const result = source.pipe(
 *   mergeMap(val => val > 5 ? throwError(() => 'Error!') : of(val)),
 *   retry(2) // retry 2 times on error
 * );
 *
 * result.subscribe({
 *   next: value => console.log(value),
 *   error: err => console.log(`${ err }: Retried 2 times then quit!`)
 * });
 *
 * // Output:
 * // 0..1..2..3..4..5..
 * // 0..1..2..3..4..5..
 * // 0..1..2..3..4..5..
 * // 'Error!: Retried 2 times then quit!'
 * ```
 *
 * @see {@link retryWhen}
 *
 * @param configOrCount - Either number of retry attempts before failing or a {@link RetryConfig} object.
 * @return A function that returns an Observable that will resubscribe to the
 * source stream when the source stream errors, at most `count` times.
 */
export function retry(configOrCount = Infinity) {
    let config;
    if (configOrCount && typeof configOrCount === 'object') {
        config = configOrCount;
    }
    else {
        config = {
            count: configOrCount,
        };
    }
    const { count = Infinity, delay, resetOnSuccess: resetOnSuccess = false } = config;
    return count <= 0
        ? identity
        : operate((source, subscriber) => {
            let soFar = 0;
            let innerSub;
            const subscribeForRetry = () => {
                let syncUnsub = false;
                innerSub = source.subscribe(createOperatorSubscriber(subscriber, (value) => {
                    // If we're resetting on success
                    if (resetOnSuccess) {
                        soFar = 0;
                    }
                    subscriber.next(value);
                }, 
                // Completions are passed through to consumer.
                undefined, (err) => {
                    if (soFar++ < count) {
                        // We are still under our retry count
                        const resub = () => {
                            if (innerSub) {
                                innerSub.unsubscribe();
                                innerSub = null;
                                subscribeForRetry();
                            }
                            else {
                                syncUnsub = true;
                            }
                        };
                        if (delay != null) {
                            // The user specified a retry delay.
                            // They gave us a number, use a timer, otherwise, it's a function,
                            // and we're going to call it to get a notifier.
                            const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(err, soFar));
                            const notifierSubscriber = createOperatorSubscriber(subscriber, () => {
                                // After we get the first notification, we
                                // unsubscribe from the notifier, because we don't want anymore
                                // and we resubscribe to the source.
                                notifierSubscriber.unsubscribe();
                                resub();
                            }, () => {
                                // The notifier completed without emitting.
                                // The author is telling us they want to complete.
                                subscriber.complete();
                            });
                            notifier.subscribe(notifierSubscriber);
                        }
                        else {
                            // There was no notifier given. Just resub immediately.
                            resub();
                        }
                    }
                    else {
                        // We're past our maximum number of retries.
                        // Just send along the error.
                        subscriber.error(err);
                    }
                }));
                if (syncUnsub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    subscribeForRetry();
                }
            };
            subscribeForRetry();
        });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvcmV0cnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUV2QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDNUMsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQThCcEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZDRztBQUNILE1BQU0sVUFBVSxLQUFLLENBQUksZ0JBQXNDLFFBQVE7SUFDckUsSUFBSSxNQUFtQixDQUFDO0lBQ3hCLElBQUksYUFBYSxJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQ3ZELE1BQU0sR0FBRyxhQUFhLENBQUM7SUFDekIsQ0FBQztTQUFNLENBQUM7UUFDTixNQUFNLEdBQUc7WUFDUCxLQUFLLEVBQUUsYUFBdUI7U0FDL0IsQ0FBQztJQUNKLENBQUM7SUFDRCxNQUFNLEVBQUUsS0FBSyxHQUFHLFFBQVEsRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFFLGNBQWMsR0FBRyxLQUFLLEVBQUUsR0FBRyxNQUFNLENBQUM7SUFFbkYsT0FBTyxLQUFLLElBQUksQ0FBQztRQUNmLENBQUMsQ0FBQyxRQUFRO1FBQ1YsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTtZQUM3QixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDZCxJQUFJLFFBQTZCLENBQUM7WUFDbEMsTUFBTSxpQkFBaUIsR0FBRyxHQUFHLEVBQUU7Z0JBQzdCLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztnQkFDdEIsUUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQ3pCLHdCQUF3QixDQUN0QixVQUFVLEVBQ1YsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDUixnQ0FBZ0M7b0JBQ2hDLElBQUksY0FBYyxFQUFFLENBQUM7d0JBQ25CLEtBQUssR0FBRyxDQUFDLENBQUM7b0JBQ1osQ0FBQztvQkFDRCxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUN6QixDQUFDO2dCQUNELDhDQUE4QztnQkFDOUMsU0FBUyxFQUNULENBQUMsR0FBRyxFQUFFLEVBQUU7b0JBQ04sSUFBSSxLQUFLLEVBQUUsR0FBRyxLQUFLLEVBQUUsQ0FBQzt3QkFDcEIscUNBQXFDO3dCQUNyQyxNQUFNLEtBQUssR0FBRyxHQUFHLEVBQUU7NEJBQ2pCLElBQUksUUFBUSxFQUFFLENBQUM7Z0NBQ2IsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO2dDQUN2QixRQUFRLEdBQUcsSUFBSSxDQUFDO2dDQUNoQixpQkFBaUIsRUFBRSxDQUFDOzRCQUN0QixDQUFDO2lDQUFNLENBQUM7Z0NBQ04sU0FBUyxHQUFHLElBQUksQ0FBQzs0QkFDbkIsQ0FBQzt3QkFDSCxDQUFDLENBQUM7d0JBRUYsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFLENBQUM7NEJBQ2xCLG9DQUFvQzs0QkFDcEMsa0VBQWtFOzRCQUNsRSxnREFBZ0Q7NEJBQ2hELE1BQU0sUUFBUSxHQUFHLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDOzRCQUN6RixNQUFNLGtCQUFrQixHQUFHLHdCQUF3QixDQUNqRCxVQUFVLEVBQ1YsR0FBRyxFQUFFO2dDQUNILDBDQUEwQztnQ0FDMUMsK0RBQStEO2dDQUMvRCxvQ0FBb0M7Z0NBQ3BDLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxDQUFDO2dDQUNqQyxLQUFLLEVBQUUsQ0FBQzs0QkFDVixDQUFDLEVBQ0QsR0FBRyxFQUFFO2dDQUNILDJDQUEyQztnQ0FDM0Msa0RBQWtEO2dDQUNsRCxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7NEJBQ3hCLENBQUMsQ0FDRixDQUFDOzRCQUNGLFFBQVEsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsQ0FBQzt3QkFDekMsQ0FBQzs2QkFBTSxDQUFDOzRCQUNOLHVEQUF1RDs0QkFDdkQsS0FBSyxFQUFFLENBQUM7d0JBQ1YsQ0FBQztvQkFDSCxDQUFDO3lCQUFNLENBQUM7d0JBQ04sNENBQTRDO3dCQUM1Qyw2QkFBNkI7d0JBQzdCLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3hCLENBQUM7Z0JBQ0gsQ0FBQyxDQUNGLENBQ0YsQ0FBQztnQkFDRixJQUFJLFNBQVMsRUFBRSxDQUFDO29CQUNkLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztvQkFDdkIsUUFBUSxHQUFHLElBQUksQ0FBQztvQkFDaEIsaUJBQWlCLEVBQUUsQ0FBQztnQkFDdEIsQ0FBQztZQUNILENBQUMsQ0FBQztZQUNGLGlCQUFpQixFQUFFLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFDVCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvcmV0cnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSAnLi4vdXRpbC9pZGVudGl0eSc7XG5pbXBvcnQgeyB0aW1lciB9IGZyb20gJy4uL29ic2VydmFibGUvdGltZXInO1xuaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgcmV0cnl9IG9wZXJhdG9yIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBgcmV0cnlgIGVpdGhlciBhY2NlcHRzIGEgYG51bWJlcmBcbiAqIG9yIGFuIG9iamVjdCBkZXNjcmliZWQgYnkgdGhpcyBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmV0cnlDb25maWcge1xuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5LiBJZiBgY291bnRgIGlzIG9taXR0ZWQsIGByZXRyeWAgd2lsbCB0cnkgdG9cbiAgICogcmVzdWJzY3JpYmUgb24gZXJyb3JzIGluZmluaXRlIG51bWJlciBvZiB0aW1lcy5cbiAgICovXG4gIGNvdW50PzogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgYmVmb3JlIHJldHJ5aW5nLCBPUiBhIGZ1bmN0aW9uIHRvXG4gICAqIHJldHVybiBhIG5vdGlmaWVyIGZvciBkZWxheWluZy4gSWYgYSBmdW5jdGlvbiBpcyBnaXZlbiwgdGhhdCBmdW5jdGlvbiBzaG91bGRcbiAgICogcmV0dXJuIGEgbm90aWZpZXIgdGhhdCwgd2hlbiBpdCBlbWl0cyB3aWxsIHJldHJ5IHRoZSBzb3VyY2UuIElmIHRoZSBub3RpZmllclxuICAgKiBjb21wbGV0ZXMgX3dpdGhvdXRfIGVtaXR0aW5nLCB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSB3aXRob3V0IGVycm9yLFxuICAgKiBpZiB0aGUgbm90aWZpZXIgZXJyb3JzLCB0aGUgZXJyb3Igd2lsbCBiZSBwdXNoZWQgdG8gdGhlIHJlc3VsdC5cbiAgICovXG4gIGRlbGF5PzogbnVtYmVyIHwgKChlcnJvcjogYW55LCByZXRyeUNvdW50OiBudW1iZXIpID0+IE9ic2VydmFibGVJbnB1dDxhbnk+KTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIHJlc2V0IHRoZSByZXRyeSBjb3VudGVyIHdoZW4gdGhlIHJldHJpZWQgc3Vic2NyaXB0aW9uXG4gICAqIGVtaXRzIGl0cyBmaXJzdCB2YWx1ZS5cbiAgICovXG4gIHJlc2V0T25TdWNjZXNzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5PFQ+KGNvdW50PzogbnVtYmVyKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5PFQ+KGNvbmZpZzogUmV0cnlDb25maWcpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD47XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGFuIGBlcnJvcmAuXG4gKlxuICogSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGNhbGxzIGBlcnJvcmAsIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGZvciBhIG1heGltdW0gb2ZcbiAqIGBjb3VudGAgcmVzdWJzY3JpcHRpb25zIHJhdGhlciB0aGFuIHByb3BhZ2F0aW5nIHRoZSBgZXJyb3JgIGNhbGwuXG4gKlxuICogIVtdKHJldHJ5LnBuZylcbiAqXG4gKiBUaGUgbnVtYmVyIG9mIHJldHJpZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgYGNvdW50YCBwYXJhbWV0ZXIuIEl0IGNhbiBiZSBzZXQgZWl0aGVyIGJ5IHBhc3NpbmcgYSBudW1iZXIgdG9cbiAqIGByZXRyeWAgZnVuY3Rpb24gb3IgYnkgc2V0dGluZyBgY291bnRgIHByb3BlcnR5IHdoZW4gYHJldHJ5YCBpcyBjb25maWd1cmVkIHVzaW5nIHtAbGluayBSZXRyeUNvbmZpZ30uIElmXG4gKiBgY291bnRgIGlzIG9taXR0ZWQsIGByZXRyeWAgd2lsbCB0cnkgdG8gcmVzdWJzY3JpYmUgb24gZXJyb3JzIGluZmluaXRlIG51bWJlciBvZiB0aW1lcy5cbiAqXG4gKiBBbnkgYW5kIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlLCBldmVuIHRob3NlXG4gKiBlbWl0dGVkIGR1cmluZyBmYWlsZWQgc3Vic2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIGlmIGFuIE9ic2VydmFibGUgZmFpbHMgYXQgZmlyc3QgYnV0IGVtaXRzIGBbMSwgMl1gIHRoZW5cbiAqIHN1Y2NlZWRzIHRoZSBzZWNvbmQgdGltZSBhbmQgZW1pdHM6IGBbMSwgMiwgMywgNCwgNSwgY29tcGxldGVdYCB0aGVuIHRoZSBjb21wbGV0ZSBzdHJlYW0gb2YgZW1pc3Npb25zIGFuZFxuICogbm90aWZpY2F0aW9ucyB3b3VsZCBiZTogYFsxLCAyLCAxLCAyLCAzLCA0LCA1LCBjb21wbGV0ZV1gLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaW50ZXJ2YWwsIG1lcmdlTWFwLCB0aHJvd0Vycm9yLCBvZiwgcmV0cnkgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UgPSBpbnRlcnZhbCgxMDAwKTtcbiAqIGNvbnN0IHJlc3VsdCA9IHNvdXJjZS5waXBlKFxuICogICBtZXJnZU1hcCh2YWwgPT4gdmFsID4gNSA/IHRocm93RXJyb3IoKCkgPT4gJ0Vycm9yIScpIDogb2YodmFsKSksXG4gKiAgIHJldHJ5KDIpIC8vIHJldHJ5IDIgdGltZXMgb24gZXJyb3JcbiAqICk7XG4gKlxuICogcmVzdWx0LnN1YnNjcmliZSh7XG4gKiAgIG5leHQ6IHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSxcbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmxvZyhgJHsgZXJyIH06IFJldHJpZWQgMiB0aW1lcyB0aGVuIHF1aXQhYClcbiAqIH0pO1xuICpcbiAqIC8vIE91dHB1dDpcbiAqIC8vIDAuLjEuLjIuLjMuLjQuLjUuLlxuICogLy8gMC4uMS4uMi4uMy4uNC4uNS4uXG4gKiAvLyAwLi4xLi4yLi4zLi40Li41Li5cbiAqIC8vICdFcnJvciE6IFJldHJpZWQgMiB0aW1lcyB0aGVuIHF1aXQhJ1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgcmV0cnlXaGVufVxuICpcbiAqIEBwYXJhbSBjb25maWdPckNvdW50IC0gRWl0aGVyIG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBiZWZvcmUgZmFpbGluZyBvciBhIHtAbGluayBSZXRyeUNvbmZpZ30gb2JqZWN0LlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgd2lsbCByZXN1YnNjcmliZSB0byB0aGVcbiAqIHNvdXJjZSBzdHJlYW0gd2hlbiB0aGUgc291cmNlIHN0cmVhbSBlcnJvcnMsIGF0IG1vc3QgYGNvdW50YCB0aW1lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5PFQ+KGNvbmZpZ09yQ291bnQ6IG51bWJlciB8IFJldHJ5Q29uZmlnID0gSW5maW5pdHkpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4ge1xuICBsZXQgY29uZmlnOiBSZXRyeUNvbmZpZztcbiAgaWYgKGNvbmZpZ09yQ291bnQgJiYgdHlwZW9mIGNvbmZpZ09yQ291bnQgPT09ICdvYmplY3QnKSB7XG4gICAgY29uZmlnID0gY29uZmlnT3JDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSB7XG4gICAgICBjb3VudDogY29uZmlnT3JDb3VudCBhcyBudW1iZXIsXG4gICAgfTtcbiAgfVxuICBjb25zdCB7IGNvdW50ID0gSW5maW5pdHksIGRlbGF5LCByZXNldE9uU3VjY2VzczogcmVzZXRPblN1Y2Nlc3MgPSBmYWxzZSB9ID0gY29uZmlnO1xuXG4gIHJldHVybiBjb3VudCA8PSAwXG4gICAgPyBpZGVudGl0eVxuICAgIDogb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgIGxldCBzb0ZhciA9IDA7XG4gICAgICAgIGxldCBpbm5lclN1YjogU3Vic2NyaXB0aW9uIHwgbnVsbDtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlRm9yUmV0cnkgPSAoKSA9PiB7XG4gICAgICAgICAgbGV0IHN5bmNVbnN1YiA9IGZhbHNlO1xuICAgICAgICAgIGlubmVyU3ViID0gc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgcmVzZXR0aW5nIG9uIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAocmVzZXRPblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHNvRmFyID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gQ29tcGxldGlvbnMgYXJlIHBhc3NlZCB0aHJvdWdoIHRvIGNvbnN1bWVyLlxuICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc29GYXIrKyA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3RpbGwgdW5kZXIgb3VyIHJldHJ5IGNvdW50XG4gICAgICAgICAgICAgICAgICBjb25zdCByZXN1YiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyU3ViKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lclN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlRm9yUmV0cnkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzeW5jVW5zdWIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZGVsYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBzcGVjaWZpZWQgYSByZXRyeSBkZWxheS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBnYXZlIHVzIGEgbnVtYmVyLCB1c2UgYSB0aW1lciwgb3RoZXJ3aXNlLCBpdCdzIGEgZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSdyZSBnb2luZyB0byBjYWxsIGl0IHRvIGdldCBhIG5vdGlmaWVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RpZmllciA9IHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgPyB0aW1lcihkZWxheSkgOiBpbm5lckZyb20oZGVsYXkoZXJyLCBzb0ZhcikpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RpZmllclN1YnNjcmliZXIgPSBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciB3ZSBnZXQgdGhlIGZpcnN0IG5vdGlmaWNhdGlvbiwgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gdGhlIG5vdGlmaWVyLCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYW55bW9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdlIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmllclN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3ViKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm90aWZpZXIgY29tcGxldGVkIHdpdGhvdXQgZW1pdHRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXV0aG9yIGlzIHRlbGxpbmcgdXMgdGhleSB3YW50IHRvIGNvbXBsZXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpZXIuc3Vic2NyaWJlKG5vdGlmaWVyU3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSB3YXMgbm8gbm90aWZpZXIgZ2l2ZW4uIEp1c3QgcmVzdWIgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgICAgIHJlc3ViKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHBhc3Qgb3VyIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMuXG4gICAgICAgICAgICAgICAgICAvLyBKdXN0IHNlbmQgYWxvbmcgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHN5bmNVbnN1Yikge1xuICAgICAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGlubmVyU3ViID0gbnVsbDtcbiAgICAgICAgICAgIHN1YnNjcmliZUZvclJldHJ5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdWJzY3JpYmVGb3JSZXRyeSgpO1xuICAgICAgfSk7XG59XG4iXX0=
