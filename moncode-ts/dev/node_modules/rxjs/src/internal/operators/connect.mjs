import { Subject } from '../Subject.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
import { operate } from '../util/lift.mjs';
import { fromSubscribable } from '../observable/fromSubscribable.mjs';
/**
 * The default configuration for `connect`.
 */
const DEFAULT_CONFIG = {
    connector: () => new Subject(),
};
/**
 * Creates an observable by multicasting the source within a function that
 * allows the developer to define the usage of the multicast prior to connection.
 *
 * This is particularly useful if the observable source you wish to multicast could
 * be synchronous or asynchronous. This sets it apart from {@link share}, which, in the
 * case of totally synchronous sources will fail to share a single subscription with
 * multiple consumers, as by the time the subscription to the result of {@link share}
 * has returned, if the source is synchronous its internal reference count will jump from
 * 0 to 1 back to 0 and reset.
 *
 * To use `connect`, you provide a `selector` function that will give you
 * a multicast observable that is not yet connected. You then use that multicast observable
 * to create a resulting observable that, when subscribed, will set up your multicast. This is
 * generally, but not always, accomplished with {@link merge}.
 *
 * Note that using a {@link takeUntil} inside of `connect`'s `selector` _might_ mean you were looking
 * to use the {@link takeWhile} operator instead.
 *
 * When you subscribe to the result of `connect`, the `selector` function will be called. After
 * the `selector` function returns, the observable it returns will be subscribed to, _then_ the
 * multicast will be connected to the source.
 *
 * ## Example
 *
 * Sharing a totally synchronous observable
 *
 * ```ts
 * import { of, tap, connect, merge, map, filter } from 'rxjs';
 *
 * const source$ = of(1, 2, 3, 4, 5).pipe(
 *   tap({
 *     subscribe: () => console.log('subscription started'),
 *     next: n => console.log(`source emitted ${ n }`)
 *   })
 * );
 *
 * source$.pipe(
 *   // Notice in here we're merging 3 subscriptions to `shared$`.
 *   connect(shared$ => merge(
 *     shared$.pipe(map(n => `all ${ n }`)),
 *     shared$.pipe(filter(n => n % 2 === 0), map(n => `even ${ n }`)),
 *     shared$.pipe(filter(n => n % 2 === 1), map(n => `odd ${ n }`))
 *   ))
 * )
 * .subscribe(console.log);
 *
 * // Expected output: (notice only one subscription)
 * 'subscription started'
 * 'source emitted 1'
 * 'all 1'
 * 'odd 1'
 * 'source emitted 2'
 * 'all 2'
 * 'even 2'
 * 'source emitted 3'
 * 'all 3'
 * 'odd 3'
 * 'source emitted 4'
 * 'all 4'
 * 'even 4'
 * 'source emitted 5'
 * 'all 5'
 * 'odd 5'
 * ```
 *
 * @param selector A function used to set up the multicast. Gives you a multicast observable
 * that is not yet connected. With that, you're expected to create and return
 * and Observable, that when subscribed to, will utilize the multicast observable.
 * After this function is executed -- and its return value subscribed to -- the
 * operator will subscribe to the source, and the connection will be made.
 * @param config The configuration object for `connect`.
 */
export function connect(selector, config = DEFAULT_CONFIG) {
    const { connector } = config;
    return operate((source, subscriber) => {
        const subject = connector();
        innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvY29ubmVjdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3JDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBYWxFOztHQUVHO0FBQ0gsTUFBTSxjQUFjLEdBQTJCO0lBQzdDLFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLE9BQU8sRUFBVztDQUN4QyxDQUFDO0FBRUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdFRztBQUNILE1BQU0sVUFBVSxPQUFPLENBQ3JCLFFBQXNDLEVBQ3RDLFNBQTJCLGNBQWM7SUFFekMsTUFBTSxFQUFFLFNBQVMsRUFBRSxHQUFHLE1BQU0sQ0FBQztJQUM3QixPQUFPLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTtRQUNwQyxNQUFNLE9BQU8sR0FBRyxTQUFTLEVBQUUsQ0FBQztRQUM1QixTQUFTLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDNUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvY29ubmVjdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGVJbnB1dCwgT2JzZXJ2ZWRWYWx1ZU9mLCBTdWJqZWN0TGlrZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgZnJvbVN1YnNjcmliYWJsZSB9IGZyb20gJy4uL29ic2VydmFibGUvZnJvbVN1YnNjcmliYWJsZSc7XG5cbi8qKlxuICogQW4gb2JqZWN0IHVzZWQgdG8gY29uZmlndXJlIHtAbGluayBjb25uZWN0fSBvcGVyYXRvci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0Q29uZmlnPFQ+IHtcbiAgLyoqXG4gICAqIEEgZmFjdG9yeSBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSB0aGUgU3ViamVjdCB0aHJvdWdoIHdoaWNoIHRoZSBzb3VyY2VcbiAgICogaXMgbXVsdGljYXN0LiBCeSBkZWZhdWx0LCB0aGlzIGNyZWF0ZXMgYSB7QGxpbmsgU3ViamVjdH0uXG4gICAqL1xuICBjb25uZWN0b3I6ICgpID0+IFN1YmplY3RMaWtlPFQ+O1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIGBjb25uZWN0YC5cbiAqL1xuY29uc3QgREVGQVVMVF9DT05GSUc6IENvbm5lY3RDb25maWc8dW5rbm93bj4gPSB7XG4gIGNvbm5lY3RvcjogKCkgPT4gbmV3IFN1YmplY3Q8dW5rbm93bj4oKSxcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXRcbiAqIGFsbG93cyB0aGUgZGV2ZWxvcGVyIHRvIGRlZmluZSB0aGUgdXNhZ2Ugb2YgdGhlIG11bHRpY2FzdCBwcmlvciB0byBjb25uZWN0aW9uLlxuICpcbiAqIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBpZiB0aGUgb2JzZXJ2YWJsZSBzb3VyY2UgeW91IHdpc2ggdG8gbXVsdGljYXN0IGNvdWxkXG4gKiBiZSBzeW5jaHJvbm91cyBvciBhc3luY2hyb25vdXMuIFRoaXMgc2V0cyBpdCBhcGFydCBmcm9tIHtAbGluayBzaGFyZX0sIHdoaWNoLCBpbiB0aGVcbiAqIGNhc2Ugb2YgdG90YWxseSBzeW5jaHJvbm91cyBzb3VyY2VzIHdpbGwgZmFpbCB0byBzaGFyZSBhIHNpbmdsZSBzdWJzY3JpcHRpb24gd2l0aFxuICogbXVsdGlwbGUgY29uc3VtZXJzLCBhcyBieSB0aGUgdGltZSB0aGUgc3Vic2NyaXB0aW9uIHRvIHRoZSByZXN1bHQgb2Yge0BsaW5rIHNoYXJlfVxuICogaGFzIHJldHVybmVkLCBpZiB0aGUgc291cmNlIGlzIHN5bmNocm9ub3VzIGl0cyBpbnRlcm5hbCByZWZlcmVuY2UgY291bnQgd2lsbCBqdW1wIGZyb21cbiAqIDAgdG8gMSBiYWNrIHRvIDAgYW5kIHJlc2V0LlxuICpcbiAqIFRvIHVzZSBgY29ubmVjdGAsIHlvdSBwcm92aWRlIGEgYHNlbGVjdG9yYCBmdW5jdGlvbiB0aGF0IHdpbGwgZ2l2ZSB5b3VcbiAqIGEgbXVsdGljYXN0IG9ic2VydmFibGUgdGhhdCBpcyBub3QgeWV0IGNvbm5lY3RlZC4gWW91IHRoZW4gdXNlIHRoYXQgbXVsdGljYXN0IG9ic2VydmFibGVcbiAqIHRvIGNyZWF0ZSBhIHJlc3VsdGluZyBvYnNlcnZhYmxlIHRoYXQsIHdoZW4gc3Vic2NyaWJlZCwgd2lsbCBzZXQgdXAgeW91ciBtdWx0aWNhc3QuIFRoaXMgaXNcbiAqIGdlbmVyYWxseSwgYnV0IG5vdCBhbHdheXMsIGFjY29tcGxpc2hlZCB3aXRoIHtAbGluayBtZXJnZX0uXG4gKlxuICogTm90ZSB0aGF0IHVzaW5nIGEge0BsaW5rIHRha2VVbnRpbH0gaW5zaWRlIG9mIGBjb25uZWN0YCdzIGBzZWxlY3RvcmAgX21pZ2h0XyBtZWFuIHlvdSB3ZXJlIGxvb2tpbmdcbiAqIHRvIHVzZSB0aGUge0BsaW5rIHRha2VXaGlsZX0gb3BlcmF0b3IgaW5zdGVhZC5cbiAqXG4gKiBXaGVuIHlvdSBzdWJzY3JpYmUgdG8gdGhlIHJlc3VsdCBvZiBgY29ubmVjdGAsIHRoZSBgc2VsZWN0b3JgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkLiBBZnRlclxuICogdGhlIGBzZWxlY3RvcmAgZnVuY3Rpb24gcmV0dXJucywgdGhlIG9ic2VydmFibGUgaXQgcmV0dXJucyB3aWxsIGJlIHN1YnNjcmliZWQgdG8sIF90aGVuXyB0aGVcbiAqIG11bHRpY2FzdCB3aWxsIGJlIGNvbm5lY3RlZCB0byB0aGUgc291cmNlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBTaGFyaW5nIGEgdG90YWxseSBzeW5jaHJvbm91cyBvYnNlcnZhYmxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mLCB0YXAsIGNvbm5lY3QsIG1lcmdlLCBtYXAsIGZpbHRlciB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IHNvdXJjZSQgPSBvZigxLCAyLCAzLCA0LCA1KS5waXBlKFxuICogICB0YXAoe1xuICogICAgIHN1YnNjcmliZTogKCkgPT4gY29uc29sZS5sb2coJ3N1YnNjcmlwdGlvbiBzdGFydGVkJyksXG4gKiAgICAgbmV4dDogbiA9PiBjb25zb2xlLmxvZyhgc291cmNlIGVtaXR0ZWQgJHsgbiB9YClcbiAqICAgfSlcbiAqICk7XG4gKlxuICogc291cmNlJC5waXBlKFxuICogICAvLyBOb3RpY2UgaW4gaGVyZSB3ZSdyZSBtZXJnaW5nIDMgc3Vic2NyaXB0aW9ucyB0byBgc2hhcmVkJGAuXG4gKiAgIGNvbm5lY3Qoc2hhcmVkJCA9PiBtZXJnZShcbiAqICAgICBzaGFyZWQkLnBpcGUobWFwKG4gPT4gYGFsbCAkeyBuIH1gKSksXG4gKiAgICAgc2hhcmVkJC5waXBlKGZpbHRlcihuID0+IG4gJSAyID09PSAwKSwgbWFwKG4gPT4gYGV2ZW4gJHsgbiB9YCkpLFxuICogICAgIHNoYXJlZCQucGlwZShmaWx0ZXIobiA9PiBuICUgMiA9PT0gMSksIG1hcChuID0+IGBvZGQgJHsgbiB9YCkpXG4gKiAgICkpXG4gKiApXG4gKiAuc3Vic2NyaWJlKGNvbnNvbGUubG9nKTtcbiAqXG4gKiAvLyBFeHBlY3RlZCBvdXRwdXQ6IChub3RpY2Ugb25seSBvbmUgc3Vic2NyaXB0aW9uKVxuICogJ3N1YnNjcmlwdGlvbiBzdGFydGVkJ1xuICogJ3NvdXJjZSBlbWl0dGVkIDEnXG4gKiAnYWxsIDEnXG4gKiAnb2RkIDEnXG4gKiAnc291cmNlIGVtaXR0ZWQgMidcbiAqICdhbGwgMidcbiAqICdldmVuIDInXG4gKiAnc291cmNlIGVtaXR0ZWQgMydcbiAqICdhbGwgMydcbiAqICdvZGQgMydcbiAqICdzb3VyY2UgZW1pdHRlZCA0J1xuICogJ2FsbCA0J1xuICogJ2V2ZW4gNCdcbiAqICdzb3VyY2UgZW1pdHRlZCA1J1xuICogJ2FsbCA1J1xuICogJ29kZCA1J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNlbGVjdG9yIEEgZnVuY3Rpb24gdXNlZCB0byBzZXQgdXAgdGhlIG11bHRpY2FzdC4gR2l2ZXMgeW91IGEgbXVsdGljYXN0IG9ic2VydmFibGVcbiAqIHRoYXQgaXMgbm90IHlldCBjb25uZWN0ZWQuIFdpdGggdGhhdCwgeW91J3JlIGV4cGVjdGVkIHRvIGNyZWF0ZSBhbmQgcmV0dXJuXG4gKiBhbmQgT2JzZXJ2YWJsZSwgdGhhdCB3aGVuIHN1YnNjcmliZWQgdG8sIHdpbGwgdXRpbGl6ZSB0aGUgbXVsdGljYXN0IG9ic2VydmFibGUuXG4gKiBBZnRlciB0aGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIC0tIGFuZCBpdHMgcmV0dXJuIHZhbHVlIHN1YnNjcmliZWQgdG8gLS0gdGhlXG4gKiBvcGVyYXRvciB3aWxsIHN1YnNjcmliZSB0byB0aGUgc291cmNlLCBhbmQgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBtYWRlLlxuICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBjb25uZWN0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3Q8VCwgTyBleHRlbmRzIE9ic2VydmFibGVJbnB1dDx1bmtub3duPj4oXG4gIHNlbGVjdG9yOiAoc2hhcmVkOiBPYnNlcnZhYmxlPFQ+KSA9PiBPLFxuICBjb25maWc6IENvbm5lY3RDb25maWc8VD4gPSBERUZBVUxUX0NPTkZJR1xuKTogT3BlcmF0b3JGdW5jdGlvbjxULCBPYnNlcnZlZFZhbHVlT2Y8Tz4+IHtcbiAgY29uc3QgeyBjb25uZWN0b3IgfSA9IGNvbmZpZztcbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIGNvbnN0IHN1YmplY3QgPSBjb25uZWN0b3IoKTtcbiAgICBpbm5lckZyb20oc2VsZWN0b3IoZnJvbVN1YnNjcmliYWJsZShzdWJqZWN0KSkpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICBzdWJzY3JpYmVyLmFkZChzb3VyY2Uuc3Vic2NyaWJlKHN1YmplY3QpKTtcbiAgfSk7XG59XG4iXX0=
