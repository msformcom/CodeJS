import { asyncScheduler } from '../scheduler/async.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Emits an object containing the current value, and the time that has
 * passed between emitting the current value and the previous value, which is
 * calculated by using the provided `scheduler`'s `now()` method to retrieve
 * the current time at each emission, then calculating the difference. The `scheduler`
 * defaults to {@link asyncScheduler}, so by default, the `interval` will be in
 * milliseconds.
 *
 * <span class="informal">Convert an Observable that emits items into one that
 * emits indications of the amount of time elapsed between those emissions.</span>
 *
 * ![](timeInterval.png)
 *
 * ## Example
 *
 * Emit interval between current value with the last value
 *
 * ```ts
 * import { interval, timeInterval } from 'rxjs';
 *
 * const seconds = interval(1000);
 *
 * seconds
 *   .pipe(timeInterval())
 *   .subscribe(value => console.log(value));
 *
 * // NOTE: The values will never be this precise,
 * // intervals created with `interval` or `setInterval`
 * // are non-deterministic.
 *
 * // { value: 0, interval: 1000 }
 * // { value: 1, interval: 1000 }
 * // { value: 2, interval: 1000 }
 * ```
 *
 * @param {SchedulerLike} [scheduler] Scheduler used to get the current time.
 * @return A function that returns an Observable that emits information about
 * value and interval.
 */
export function timeInterval(scheduler = asyncScheduler) {
    return operate((source, subscriber) => {
        let last = scheduler.now();
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            const now = scheduler.now();
            const interval = now - last;
            last = now;
            subscriber.next(new TimeInterval(value, interval));
        }));
    });
}
// TODO(benlesh): make this an interface, export the interface, but not the implemented class,
// there's no reason users should be manually creating this type.
export class TimeInterval {
    /**
     * @deprecated Internal implementation detail, do not construct directly. Will be made an interface in v8.
     */
    constructor(value, interval) {
        this.value = value;
        this.interval = interval;
    }
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZUludGVydmFsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVwRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRWhFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNDRztBQUNILE1BQU0sVUFBVSxZQUFZLENBQUksWUFBMkIsY0FBYztJQUN2RSxPQUFPLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTtRQUNwQyxJQUFJLElBQUksR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDM0IsTUFBTSxDQUFDLFNBQVMsQ0FDZCx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUM3QyxNQUFNLEdBQUcsR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDNUIsTUFBTSxRQUFRLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQztZQUM1QixJQUFJLEdBQUcsR0FBRyxDQUFDO1lBQ1gsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLFlBQVksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNyRCxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsOEZBQThGO0FBQzlGLGlFQUFpRTtBQUVqRSxNQUFNLE9BQU8sWUFBWTtJQUN2Qjs7T0FFRztJQUNILFlBQW1CLEtBQVEsRUFBUyxRQUFnQjtRQUFqQyxVQUFLLEdBQUwsS0FBSyxDQUFHO1FBQVMsYUFBUSxHQUFSLFFBQVEsQ0FBUTtJQUFHLENBQUM7Q0FDekQiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy90aW1lSW50ZXJ2YWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3luY1NjaGVkdWxlciB9IGZyb20gJy4uL3NjaGVkdWxlci9hc3luYyc7XG5pbXBvcnQgeyBTY2hlZHVsZXJMaWtlLCBPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5cbi8qKlxuICogRW1pdHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgdmFsdWUsIGFuZCB0aGUgdGltZSB0aGF0IGhhc1xuICogcGFzc2VkIGJldHdlZW4gZW1pdHRpbmcgdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHRoZSBwcmV2aW91cyB2YWx1ZSwgd2hpY2ggaXNcbiAqIGNhbGN1bGF0ZWQgYnkgdXNpbmcgdGhlIHByb3ZpZGVkIGBzY2hlZHVsZXJgJ3MgYG5vdygpYCBtZXRob2QgdG8gcmV0cmlldmVcbiAqIHRoZSBjdXJyZW50IHRpbWUgYXQgZWFjaCBlbWlzc2lvbiwgdGhlbiBjYWxjdWxhdGluZyB0aGUgZGlmZmVyZW5jZS4gVGhlIGBzY2hlZHVsZXJgXG4gKiBkZWZhdWx0cyB0byB7QGxpbmsgYXN5bmNTY2hlZHVsZXJ9LCBzbyBieSBkZWZhdWx0LCB0aGUgYGludGVydmFsYCB3aWxsIGJlIGluXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbnZlcnQgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGludG8gb25lIHRoYXRcbiAqIGVtaXRzIGluZGljYXRpb25zIG9mIHRoZSBhbW91bnQgb2YgdGltZSBlbGFwc2VkIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLjwvc3Bhbj5cbiAqXG4gKiAhW10odGltZUludGVydmFsLnBuZylcbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogRW1pdCBpbnRlcnZhbCBiZXR3ZWVuIGN1cnJlbnQgdmFsdWUgd2l0aCB0aGUgbGFzdCB2YWx1ZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpbnRlcnZhbCwgdGltZUludGVydmFsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3Qgc2Vjb25kcyA9IGludGVydmFsKDEwMDApO1xuICpcbiAqIHNlY29uZHNcbiAqICAgLnBpcGUodGltZUludGVydmFsKCkpXG4gKiAgIC5zdWJzY3JpYmUodmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpKTtcbiAqXG4gKiAvLyBOT1RFOiBUaGUgdmFsdWVzIHdpbGwgbmV2ZXIgYmUgdGhpcyBwcmVjaXNlLFxuICogLy8gaW50ZXJ2YWxzIGNyZWF0ZWQgd2l0aCBgaW50ZXJ2YWxgIG9yIGBzZXRJbnRlcnZhbGBcbiAqIC8vIGFyZSBub24tZGV0ZXJtaW5pc3RpYy5cbiAqXG4gKiAvLyB7IHZhbHVlOiAwLCBpbnRlcnZhbDogMTAwMCB9XG4gKiAvLyB7IHZhbHVlOiAxLCBpbnRlcnZhbDogMTAwMCB9XG4gKiAvLyB7IHZhbHVlOiAyLCBpbnRlcnZhbDogMTAwMCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1NjaGVkdWxlckxpa2V9IFtzY2hlZHVsZXJdIFNjaGVkdWxlciB1c2VkIHRvIGdldCB0aGUgY3VycmVudCB0aW1lLlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHZhbHVlIGFuZCBpbnRlcnZhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVJbnRlcnZhbDxUPihzY2hlZHVsZXI6IFNjaGVkdWxlckxpa2UgPSBhc3luY1NjaGVkdWxlcik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVGltZUludGVydmFsPFQ+PiB7XG4gIHJldHVybiBvcGVyYXRlKChzb3VyY2UsIHN1YnNjcmliZXIpID0+IHtcbiAgICBsZXQgbGFzdCA9IHNjaGVkdWxlci5ub3coKTtcbiAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBub3cgPSBzY2hlZHVsZXIubm93KCk7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gbm93IC0gbGFzdDtcbiAgICAgICAgbGFzdCA9IG5vdztcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KG5ldyBUaW1lSW50ZXJ2YWwodmFsdWUsIGludGVydmFsKSk7XG4gICAgICB9KVxuICAgICk7XG4gIH0pO1xufVxuXG4vLyBUT0RPKGJlbmxlc2gpOiBtYWtlIHRoaXMgYW4gaW50ZXJmYWNlLCBleHBvcnQgdGhlIGludGVyZmFjZSwgYnV0IG5vdCB0aGUgaW1wbGVtZW50ZWQgY2xhc3MsXG4vLyB0aGVyZSdzIG5vIHJlYXNvbiB1c2VycyBzaG91bGQgYmUgbWFudWFsbHkgY3JlYXRpbmcgdGhpcyB0eXBlLlxuXG5leHBvcnQgY2xhc3MgVGltZUludGVydmFsPFQ+IHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEludGVybmFsIGltcGxlbWVudGF0aW9uIGRldGFpbCwgZG8gbm90IGNvbnN0cnVjdCBkaXJlY3RseS4gV2lsbCBiZSBtYWRlIGFuIGludGVyZmFjZSBpbiB2OC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB2YWx1ZTogVCwgcHVibGljIGludGVydmFsOiBudW1iZXIpIHt9XG59XG4iXX0=
