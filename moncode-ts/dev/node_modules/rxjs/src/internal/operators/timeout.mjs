import { asyncScheduler } from '../scheduler/async.mjs';
import { isValidDate } from '../util/isDate.mjs';
import { operate } from '../util/lift.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
import { createErrorClass } from '../util/createErrorClass.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { executeSchedule } from '../util/executeSchedule.mjs';
/**
 * An error thrown by the {@link timeout} operator.
 *
 * Provided so users can use as a type and do quality comparisons.
 * We recommend you do not subclass this or create instances of this class directly.
 * If you have need of a error representing a timeout, you should
 * create your own error class and use that.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
export const TimeoutError = createErrorClass((_super) => function TimeoutErrorImpl(info = null) {
    _super(this);
    this.message = 'Timeout has occurred';
    this.name = 'TimeoutError';
    this.info = info;
});
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * ![](timeout.png)
 *
 * @see {@link timeoutWith}
 *
 * @return A function that returns an Observable that mirrors behaviour of the
 * source Observable, unless timeout happens when it throws an error.
 */
export function timeout(config, schedulerArg) {
    // Intentionally terse code.
    // If the first argument is a valid `Date`, then we use it as the `first` config.
    // Otherwise, if the first argument is a `number`, then we use it as the `each` config.
    // Otherwise, it can be assumed the first argument is the configuration object itself, and
    // we destructure that into what we're going to use, setting important defaults as we do.
    // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or
    // it will default to the `asyncScheduler`.
    const { first, each, with: _with = timeoutErrorFactory, scheduler = schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler, meta = null, } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config);
    if (first == null && each == null) {
        // Ensure timeout was provided at runtime.
        throw new TypeError('No timeout provided.');
    }
    return operate((source, subscriber) => {
        // This subscription encapsulates our subscription to the
        // source for this operator. We're capturing it separately,
        // because if there is a `with` observable to fail over to,
        // we want to unsubscribe from our original subscription, and
        // hand of the subscription to that one.
        let originalSourceSubscription;
        // The subscription for our timeout timer. This changes
        // every time we get a new value.
        let timerSubscription;
        // A bit of state we pass to our with and error factories to
        // tell what the last value we saw was.
        let lastValue = null;
        // A bit of state we pass to the with and error factories to
        // tell how many values we have seen so far.
        let seen = 0;
        const startTimer = (delay) => {
            timerSubscription = executeSchedule(subscriber, scheduler, () => {
                try {
                    originalSourceSubscription.unsubscribe();
                    innerFrom(_with({
                        meta,
                        lastValue,
                        seen,
                    })).subscribe(subscriber);
                }
                catch (err) {
                    subscriber.error(err);
                }
            }, delay);
        };
        originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            // clear the timer so we can emit and start another one.
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
            seen++;
            // Emit
            subscriber.next((lastValue = value));
            // null | undefined are both < 0. Thanks, JavaScript.
            each > 0 && startTimer(each);
        }, undefined, undefined, () => {
            if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
            }
            // Be sure not to hold the last value in memory after unsubscription
            // it could be quite large.
            lastValue = null;
        }));
        // Intentionally terse code.
        // If we've `seen` a value, that means the "first" clause was met already, if it existed.
        //   it also means that a timer was already started for "each" (in the next handler above).
        // If `first` was provided, and it's a number, then use it.
        // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and "now".
        // If `first` was not provided at all, then our first timer will be the value from `each`.
        !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);
    });
}
/**
 * The default function to use to emit an error when timeout occurs and a `with` function
 * is not specified.
 * @param info The information about the timeout to pass along to the error
 */
function timeoutErrorFactory(info) {
    throw new TimeoutError(info);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZW91dC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFcEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTdDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFFdkMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzVELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQWtFMUQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxNQUFNLENBQUMsTUFBTSxZQUFZLEdBQXFCLGdCQUFnQixDQUM1RCxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQ1QsU0FBUyxnQkFBZ0IsQ0FBWSxPQUFnQyxJQUFJO0lBQ3ZFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNiLElBQUksQ0FBQyxPQUFPLEdBQUcsc0JBQXNCLENBQUM7SUFDdEMsSUFBSSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUM7SUFDM0IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDbkIsQ0FBQyxDQUNKLENBQUM7QUFnTUY7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsTUFBTSxVQUFVLE9BQU8sQ0FDckIsTUFBOEMsRUFDOUMsWUFBNEI7SUFFNUIsNEJBQTRCO0lBQzVCLGlGQUFpRjtJQUNqRix1RkFBdUY7SUFDdkYsMEZBQTBGO0lBQzFGLHlGQUF5RjtJQUN6RixzRkFBc0Y7SUFDdEYsMkNBQTJDO0lBQzNDLE1BQU0sRUFDSixLQUFLLEVBQ0wsSUFBSSxFQUNKLElBQUksRUFBRSxLQUFLLEdBQUcsbUJB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LEtBQUssS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsU0FBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUssQ0FBQyxDQUFDO0lBQy9HLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLG1CQUFtQixDQUFDLElBQXNCO0lBQ2pELE1BQU0sSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDL0IsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVvdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3luY1NjaGVkdWxlciB9IGZyb20gJy4uL3NjaGVkdWxlci9hc3luYyc7XG5pbXBvcnQgeyBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sIFNjaGVkdWxlckxpa2UsIE9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGVJbnB1dCwgT2JzZXJ2ZWRWYWx1ZU9mIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNWYWxpZERhdGUgfSBmcm9tICcuLi91dGlsL2lzRGF0ZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpbm5lckZyb20gfSBmcm9tICcuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSc7XG5pbXBvcnQgeyBjcmVhdGVFcnJvckNsYXNzIH0gZnJvbSAnLi4vdXRpbC9jcmVhdGVFcnJvckNsYXNzJztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IGV4ZWN1dGVTY2hlZHVsZSB9IGZyb20gJy4uL3V0aWwvZXhlY3V0ZVNjaGVkdWxlJztcblxuZXhwb3J0IGludGVyZmFjZSBUaW1lb3V0Q29uZmlnPFQsIE8gZXh0ZW5kcyBPYnNlcnZhYmxlSW5wdXQ8dW5rbm93bj4gPSBPYnNlcnZhYmxlSW5wdXQ8VD4sIE0gPSB1bmtub3duPiB7XG4gIC8qKlxuICAgKiBUaGUgdGltZSBhbGxvd2VkIGJldHdlZW4gdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBiZWZvcmUgdGltZW91dCBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuICBlYWNoPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVsYXRpdmUgdGltZSBhcyBhIGBudW1iZXJgIGluIG1pbGxpc2Vjb25kcywgb3IgYSBzcGVjaWZpYyB0aW1lIGFzIGEgYERhdGVgIG9iamVjdCxcbiAgICogYnkgd2hpY2ggdGhlIGZpcnN0IHZhbHVlIG11c3QgYXJyaXZlIGZyb20gdGhlIHNvdXJjZSBiZWZvcmUgdGltZW91dCBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuICBmaXJzdD86IG51bWJlciB8IERhdGU7XG5cbiAgLyoqXG4gICAqIFRoZSBzY2hlZHVsZXIgdG8gdXNlIHdpdGggdGltZS1yZWxhdGVkIG9wZXJhdGlvbnMgd2l0aGluIHRoaXMgb3BlcmF0b3IuIERlZmF1bHRzIHRvIHtAbGluayBhc3luY1NjaGVkdWxlcn1cbiAgICovXG4gIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2U7XG5cbiAgLyoqXG4gICAqIEEgZmFjdG9yeSB1c2VkIHRvIGNyZWF0ZSBvYnNlcnZhYmxlIHRvIHN3aXRjaCB0byB3aGVuIHRpbWVvdXQgb2NjdXJzLiBQcm92aWRlc1xuICAgKiBhIHtAbGluayBUaW1lb3V0SW5mb30gYWJvdXQgdGhlIHNvdXJjZSBvYnNlcnZhYmxlJ3MgZW1pc3Npb25zIGFuZCB3aGF0IGRlbGF5IG9yXG4gICAqIGV4YWN0IHRpbWUgdHJpZ2dlcmVkIHRoZSB0aW1lb3V0LlxuICAgKi9cbiAgd2l0aD86IChpbmZvOiBUaW1lb3V0SW5mbzxULCBNPikgPT4gTztcblxuICAvKipcbiAgICogT3B0aW9uYWwgYWRkaXRpb25hbCBtZXRhZGF0YSB5b3UgY2FuIHByb3ZpZGUgdG8gY29kZSB0aGF0IGhhbmRsZXNcbiAgICogdGhlIHRpbWVvdXQsIHdpbGwgYmUgcHJvdmlkZWQgdGhyb3VnaCB0aGUge0BsaW5rIFRpbWVvdXRFcnJvcn0uXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaGVscCBpZGVudGlmeSB0aGUgc291cmNlIG9mIGEgdGltZW91dCBvciBwYXNzIGFsb25nXG4gICAqIG90aGVyIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIHRpbWVvdXQuXG4gICAqL1xuICBtZXRhPzogTTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lb3V0SW5mbzxULCBNID0gdW5rbm93bj4ge1xuICAvKiogT3B0aW9uYWwgbWV0YWRhdGEgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIHRpbWVvdXQgY29uZmlndXJhdGlvbi4gKi9cbiAgcmVhZG9ubHkgbWV0YTogTTtcbiAgLyoqIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgc2VlbiBiZWZvcmUgdGhlIHRpbWVvdXQgKi9cbiAgcmVhZG9ubHkgc2VlbjogbnVtYmVyO1xuICAvKiogVGhlIGxhc3QgbWVzc2FnZSBzZWVuICovXG4gIHJlYWRvbmx5IGxhc3RWYWx1ZTogVCB8IG51bGw7XG59XG5cbi8qKlxuICogQW4gZXJyb3IgZW1pdHRlZCB3aGVuIGEgdGltZW91dCBvY2N1cnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGltZW91dEVycm9yPFQgPSB1bmtub3duLCBNID0gdW5rbm93bj4gZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBUaGUgaW5mb3JtYXRpb24gcHJvdmlkZWQgdG8gdGhlIGVycm9yIGJ5IHRoZSB0aW1lb3V0XG4gICAqIG9wZXJhdGlvbiB0aGF0IGNyZWF0ZWQgdGhlIGVycm9yLiBXaWxsIGJlIGBudWxsYCBpZlxuICAgKiB1c2VkIGRpcmVjdGx5IGluIG5vbi1SeEpTIGNvZGUgd2l0aCBhbiBlbXB0eSBjb25zdHJ1Y3Rvci5cbiAgICogKE5vdGUgdGhhdCB1c2luZyB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5IGlzIG5vdCByZWNvbW1lbmRlZCxcbiAgICogeW91IHNob3VsZCBjcmVhdGUgeW91ciBvd24gZXJyb3JzKVxuICAgKi9cbiAgaW5mbzogVGltZW91dEluZm88VCwgTT4gfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVvdXRFcnJvckN0b3Ige1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gZGV0YWlsLiBEbyBub3QgY29uc3RydWN0IGVycm9yIGluc3RhbmNlcy5cbiAgICogQ2Fubm90IGJlIHRhZ2dlZCBhcyBpbnRlcm5hbDogaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9yeGpzL2lzc3Vlcy82MjY5XG4gICAqL1xuICBuZXcgPFQgPSB1bmtub3duLCBNID0gdW5rbm93bj4oaW5mbz86IFRpbWVvdXRJbmZvPFQsIE0+KTogVGltZW91dEVycm9yPFQsIE0+O1xufVxuXG4vKipcbiAqIEFuIGVycm9yIHRocm93biBieSB0aGUge0BsaW5rIHRpbWVvdXR9IG9wZXJhdG9yLlxuICpcbiAqIFByb3ZpZGVkIHNvIHVzZXJzIGNhbiB1c2UgYXMgYSB0eXBlIGFuZCBkbyBxdWFsaXR5IGNvbXBhcmlzb25zLlxuICogV2UgcmVjb21tZW5kIHlvdSBkbyBub3Qgc3ViY2xhc3MgdGhpcyBvciBjcmVhdGUgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgZGlyZWN0bHkuXG4gKiBJZiB5b3UgaGF2ZSBuZWVkIG9mIGEgZXJyb3IgcmVwcmVzZW50aW5nIGEgdGltZW91dCwgeW91IHNob3VsZFxuICogY3JlYXRlIHlvdXIgb3duIGVycm9yIGNsYXNzIGFuZCB1c2UgdGhhdC5cbiAqXG4gKiBAc2VlIHtAbGluayB0aW1lb3V0fVxuICpcbiAqIEBjbGFzcyBUaW1lb3V0RXJyb3JcbiAqL1xuZXhwb3J0IGNvbnN0IFRpbWVvdXRFcnJvcjogVGltZW91dEVycm9yQ3RvciA9IGNyZWF0ZUVycm9yQ2xhc3MoXG4gIChfc3VwZXIpID0+XG4gICAgZnVuY3Rpb24gVGltZW91dEVycm9ySW1wbCh0aGlzOiBhbnksIGluZm86IFRpbWVvdXRJbmZvPGFueT4gfCBudWxsID0gbnVsbCkge1xuICAgICAgX3N1cGVyKHRoaXMpO1xuICAgICAgdGhpcy5tZXNzYWdlID0gJ1RpbWVvdXQgaGFzIG9jY3VycmVkJztcbiAgICAgIHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB9XG4pO1xuXG4vKipcbiAqIElmIGB3aXRoYCBpcyBwcm92aWRlZCwgdGhpcyB3aWxsIHJldHVybiBhbiBvYnNlcnZhYmxlIHRoYXQgd2lsbCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgb2JzZXJ2YWJsZSBpZiB0aGUgc291cmNlXG4gKiBkb2VzIG5vdCBwdXNoIHZhbHVlcyB3aXRoaW4gdGhlIHNwZWNpZmllZCB0aW1lIHBhcmFtZXRlcnMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRoZSBtb3N0IGZsZXhpYmxlIG9wdGlvbiBmb3IgY3JlYXRpbmcgYSB0aW1lb3V0IGJlaGF2aW9yLjwvc3Bhbj5cbiAqXG4gKiBUaGUgZmlyc3QgdGhpbmcgdG8ga25vdyBhYm91dCB0aGUgY29uZmlndXJhdGlvbiBpcyBpZiB5b3UgZG8gbm90IHByb3ZpZGUgYSBgd2l0aGAgcHJvcGVydHkgdG8gdGhlIGNvbmZpZ3VyYXRpb24sXG4gKiB3aGVuIHRpbWVvdXQgY29uZGl0aW9ucyBhcmUgbWV0LCB0aGlzIG9wZXJhdG9yIHdpbGwgZW1pdCBhIHtAbGluayBUaW1lb3V0RXJyb3J9LiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBmYWN0b3J5XG4gKiBmdW5jdGlvbiBwcm92aWRlZCBieSBgd2l0aGAsIGFuZCBzd2l0Y2ggeW91ciBzdWJzY3JpcHRpb24gdG8gdGhlIHJlc3VsdCBvZiB0aGF0LiBUaW1lb3V0IGNvbmRpdGlvbnMgYXJlIHByb3ZpZGVkIGJ5XG4gKiB0aGUgc2V0dGluZ3MgaW4gYGZpcnN0YCBhbmQgYGVhY2hgLlxuICpcbiAqIFRoZSBgZmlyc3RgIHByb3BlcnR5IGNhbiBiZSBlaXRoZXIgYSBgRGF0ZWAgZm9yIGEgc3BlY2lmaWMgdGltZSwgYSBgbnVtYmVyYCBmb3IgYSB0aW1lIHBlcmlvZCByZWxhdGl2ZSB0byB0aGVcbiAqIHBvaW50IG9mIHN1YnNjcmlwdGlvbiwgb3IgaXQgY2FuIGJlIHNraXBwZWQuIFRoaXMgcHJvcGVydHkgaXMgdG8gY2hlY2sgdGltZW91dCBjb25kaXRpb25zIGZvciB0aGUgYXJyaXZhbCBvZlxuICogdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIHNvdXJjZSBfb25seV8uIFRoZSB0aW1pbmdzIG9mIGFsbCBzdWJzZXF1ZW50IHZhbHVlcyAgZnJvbSB0aGUgc291cmNlIHdpbGwgYmUgY2hlY2tlZFxuICogYWdhaW5zdCB0aGUgdGltZSBwZXJpb2QgcHJvdmlkZWQgYnkgYGVhY2hgLCBpZiBpdCB3YXMgcHJvdmlkZWQuXG4gKlxuICogVGhlIGBlYWNoYCBwcm9wZXJ0eSBjYW4gYmUgZWl0aGVyIGEgYG51bWJlcmAgb3Igc2tpcHBlZC4gSWYgYSB2YWx1ZSBmb3IgYGVhY2hgIGlzIHByb3ZpZGVkLCBpdCByZXByZXNlbnRzIHRoZSBhbW91bnQgb2ZcbiAqIHRpbWUgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHdpbGwgd2FpdCBiZXR3ZWVuIHRoZSBhcnJpdmFsIG9mIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgYmVmb3JlIHRpbWluZyBvdXQuIE5vdGUgdGhhdCBpZlxuICogYGZpcnN0YCBpcyBfbm90XyBwcm92aWRlZCwgdGhlIHZhbHVlIGZyb20gYGVhY2hgIHdpbGwgYmUgdXNlZCB0byBjaGVjayB0aW1lb3V0IGNvbmRpdGlvbnMgZm9yIHRoZSBhcnJpdmFsIG9mIHRoZSBmaXJzdFxuICogdmFsdWUgYW5kIGFsbCBzdWJzZXF1ZW50IHZhbHVlcy4gSWYgYGZpcnN0YCBfaXNfIHByb3ZpZGVkLCBgZWFjaGAgd2lsbCBvbmx5IGJlIHVzZSB0byBjaGVjayBhbGwgdmFsdWVzIGFmdGVyIHRoZSBmaXJzdC5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIEVtaXQgYSBjdXN0b20gZXJyb3IgaWYgdGhlcmUgaXMgdG9vIG11Y2ggdGltZSBiZXR3ZWVuIHZhbHVlc1xuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpbnRlcnZhbCwgdGltZW91dCwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNsYXNzIEN1c3RvbVRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgc3VwZXIoJ0l0IHdhcyB0b28gc2xvdycpO1xuICogICAgIHRoaXMubmFtZSA9ICdDdXN0b21UaW1lb3V0RXJyb3InO1xuICogICB9XG4gKiB9XG4gKlxuICogY29uc3Qgc2xvdyQgPSBpbnRlcnZhbCg5MDApO1xuICpcbiAqIHNsb3ckLnBpcGUoXG4gKiAgIHRpbWVvdXQoe1xuICogICAgIGVhY2g6IDEwMDAsXG4gKiAgICAgd2l0aDogKCkgPT4gdGhyb3dFcnJvcigoKSA9PiBuZXcgQ3VzdG9tVGltZW91dEVycm9yKCkpXG4gKiAgIH0pXG4gKiApXG4gKiAuc3Vic2NyaWJlKHtcbiAqICAgZXJyb3I6IGNvbnNvbGUuZXJyb3JcbiAqIH0pO1xuICogYGBgXG4gKlxuICogU3dpdGNoIHRvIGEgZmFzdGVyIG9ic2VydmFibGUgaWYgeW91ciBzb3VyY2UgaXMgc2xvdy5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaW50ZXJ2YWwsIHRpbWVvdXQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzbG93JCA9IGludGVydmFsKDkwMCk7XG4gKiBjb25zdCBmYXN0JCA9IGludGVydmFsKDUwMCk7XG4gKlxuICogc2xvdyQucGlwZShcbiAqICAgdGltZW91dCh7XG4gKiAgICAgZWFjaDogMTAwMCxcbiAqICAgICB3aXRoOiAoKSA9PiBmYXN0JCxcbiAqICAgfSlcbiAqIClcbiAqIC5zdWJzY3JpYmUoY29uc29sZS5sb2cpO1xuICogYGBgXG4gKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgdGltZW91dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXQ8VCwgTyBleHRlbmRzIE9ic2VydmFibGVJbnB1dDx1bmtub3duPiwgTSA9IHVua25vd24+KFxuICBjb25maWc6IFRpbWVvdXRDb25maWc8VCwgTywgTT4gJiB7IHdpdGg6IChpbmZvOiBUaW1lb3V0SW5mbzxULCBNPikgPT4gTyB9XG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBPYnNlcnZlZFZhbHVlT2Y8Tz4+O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IHdpbGwgZXJyb3Igb3Igc3dpdGNoIHRvIGEgZGlmZmVyZW50IG9ic2VydmFibGUgaWYgdGhlIHNvdXJjZSBkb2VzIG5vdCBwdXNoIHZhbHVlc1xuICogd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZSBwYXJhbWV0ZXJzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5UaGUgbW9zdCBmbGV4aWJsZSBvcHRpb24gZm9yIGNyZWF0aW5nIGEgdGltZW91dCBiZWhhdmlvci48L3NwYW4+XG4gKlxuICogVGhlIGZpcnN0IHRoaW5nIHRvIGtub3cgYWJvdXQgdGhlIGNvbmZpZ3VyYXRpb24gaXMgaWYgeW91IGRvIG5vdCBwcm92aWRlIGEgYHdpdGhgIHByb3BlcnR5IHRvIHRoZSBjb25maWd1cmF0aW9uLFxuICogd2hlbiB0aW1lb3V0IGNvbmRpdGlvbnMgYXJlIG1ldCwgdGhpcyBvcGVyYXRvciB3aWxsIGVtaXQgYSB7QGxpbmsgVGltZW91dEVycm9yfS4gT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgZmFjdG9yeVxuICogZnVuY3Rpb24gcHJvdmlkZWQgYnkgYHdpdGhgLCBhbmQgc3dpdGNoIHlvdXIgc3Vic2NyaXB0aW9uIHRvIHRoZSByZXN1bHQgb2YgdGhhdC4gVGltZW91dCBjb25kaXRpb25zIGFyZSBwcm92aWRlZCBieVxuICogdGhlIHNldHRpbmdzIGluIGBmaXJzdGAgYW5kIGBlYWNoYC5cbiAqXG4gKiBUaGUgYGZpcnN0YCBwcm9wZXJ0eSBjYW4gYmUgZWl0aGVyIGEgYERhdGVgIGZvciBhIHNwZWNpZmljIHRpbWUsIGEgYG51bWJlcmAgZm9yIGEgdGltZSBwZXJpb2QgcmVsYXRpdmUgdG8gdGhlXG4gKiBwb2ludCBvZiBzdWJzY3JpcHRpb24sIG9yIGl0IGNhbiBiZSBza2lwcGVkLiBUaGlzIHByb3BlcnR5IGlzIHRvIGNoZWNrIHRpbWVvdXQgY29uZGl0aW9ucyBmb3IgdGhlIGFycml2YWwgb2ZcbiAqIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgX29ubHlfLiBUaGUgdGltaW5ncyBvZiBhbGwgc3Vic2VxdWVudCB2YWx1ZXMgIGZyb20gdGhlIHNvdXJjZSB3aWxsIGJlIGNoZWNrZWRcbiAqIGFnYWluc3QgdGhlIHRpbWUgcGVyaW9kIHByb3ZpZGVkIGJ5IGBlYWNoYCwgaWYgaXQgd2FzIHByb3ZpZGVkLlxuICpcbiAqIFRoZSBgZWFjaGAgcHJvcGVydHkgY2FuIGJlIGVpdGhlciBhIGBudW1iZXJgIG9yIHNraXBwZWQuIElmIGEgdmFsdWUgZm9yIGBlYWNoYCBpcyBwcm92aWRlZCwgaXQgcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mXG4gKiB0aW1lIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSB3aWxsIHdhaXQgYmV0d2VlbiB0aGUgYXJyaXZhbCBvZiB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIGJlZm9yZSB0aW1pbmcgb3V0LiBOb3RlIHRoYXQgaWZcbiAqIGBmaXJzdGAgaXMgX25vdF8gcHJvdmlkZWQsIHRoZSB2YWx1ZSBmcm9tIGBlYWNoYCB3aWxsIGJlIHVzZWQgdG8gY2hlY2sgdGltZW91dCBjb25kaXRpb25zIGZvciB0aGUgYXJyaXZhbCBvZiB0aGUgZmlyc3RcbiAqIHZhbHVlIGFuZCBhbGwgc3Vic2VxdWVudCB2YWx1ZXMuIElmIGBmaXJzdGAgX2lzXyBwcm92aWRlZCwgYGVhY2hgIHdpbGwgb25seSBiZSB1c2UgdG8gY2hlY2sgYWxsIHZhbHVlcyBhZnRlciB0aGUgZmlyc3QuXG4gKlxuICogIyMjIEhhbmRsaW5nIFRpbWVvdXRFcnJvcnNcbiAqXG4gKiBJZiBubyBgd2l0aGAgcHJvcGVydHkgd2FzIHByb3ZpZGVkLCBzdWJzY3JpcHRpb25zIHRvIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSBtYXkgZW1pdCBhbiBlcnJvciBvZiB7QGxpbmsgVGltZW91dEVycm9yfS5cbiAqIFRoZSB0aW1lb3V0IGVycm9yIHByb3ZpZGVzIHVzZWZ1bCBpbmZvcm1hdGlvbiB5b3UgY2FuIGV4YW1pbmUgd2hlbiB5b3UncmUgaGFuZGxpbmcgdGhlIGVycm9yLiBUaGUgbW9zdCBjb21tb24gd2F5IHRvIGhhbmRsZVxuICogdGhlIGVycm9yIHdvdWxkIGJlIHdpdGgge0BsaW5rIGNhdGNoRXJyb3J9LCBhbHRob3VnaCB5b3UgY291bGQgdXNlIHtAbGluayB0YXB9IG9yIGp1c3QgdGhlIGVycm9yIGhhbmRsZXIgaW4geW91ciBgc3Vic2NyaWJlYCBjYWxsXG4gKiBkaXJlY3RseSwgaWYgeW91ciBlcnJvciBoYW5kbGluZyBpcyBvbmx5IGEgc2lkZSBlZmZlY3QgKHN1Y2ggYXMgbm90aWZ5aW5nIHRoZSB1c2VyLCBvciBsb2dnaW5nKS5cbiAqXG4gKiBJbiB0aGlzIGNhc2UsIHlvdSB3b3VsZCBjaGVjayB0aGUgZXJyb3IgZm9yIGBpbnN0YW5jZW9mIFRpbWVvdXRFcnJvcmAgdG8gdmFsaWRhdGUgdGhhdCB0aGUgZXJyb3Igd2FzIGluZGVlZCBmcm9tIGB0aW1lb3V0YCwgYW5kXG4gKiBub3QgZnJvbSBzb21lIG90aGVyIHNvdXJjZS4gSWYgaXQncyBub3QgZnJvbSBgdGltZW91dGAsIHlvdSBzaG91bGQgcHJvYmFibHkgcmV0aHJvdyBpdCBpZiB5b3UncmUgaW4gYSBgY2F0Y2hFcnJvcmAuXG4gKlxuICogIyMgRXhhbXBsZXNcbiAqXG4gKiBFbWl0IGEge0BsaW5rIFRpbWVvdXRFcnJvcn0gaWYgdGhlIGZpcnN0IHZhbHVlLCBhbmQgX29ubHlfIHRoZSBmaXJzdCB2YWx1ZSwgZG9lcyBub3QgYXJyaXZlIHdpdGhpbiA1IHNlY29uZHNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaW50ZXJ2YWwsIHRpbWVvdXQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiAvLyBBIHJhbmRvbSBpbnRlcnZhbCB0aGF0IGxhc3RzIGJldHdlZW4gMCBhbmQgMTAgc2Vjb25kcyBwZXIgdGlja1xuICogY29uc3Qgc291cmNlJCA9IGludGVydmFsKE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwXzAwMCkpO1xuICpcbiAqIHNvdXJjZSQucGlwZShcbiAqICAgdGltZW91dCh7IGZpcnN0OiA1XzAwMCB9KVxuICogKVxuICogLnN1YnNjcmliZSh7XG4gKiAgIG5leHQ6IGNvbnNvbGUubG9nLFxuICogICBlcnJvcjogY29uc29sZS5lcnJvclxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBFbWl0IGEge0BsaW5rIFRpbWVvdXRFcnJvcn0gaWYgdGhlIHNvdXJjZSB3YWl0cyBsb25nZXIgdGhhbiA1IHNlY29uZHMgYmV0d2VlbiBhbnkgdHdvIHZhbHVlcyBvciB0aGUgZmlyc3QgdmFsdWVcbiAqIGFuZCBzdWJzY3JpcHRpb24uXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHRpbWVyLCB0aW1lb3V0LCBleHBhbmQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBnZXRSYW5kb21UaW1lID0gKCkgPT4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTBfMDAwKTtcbiAqXG4gKiAvLyBBbiBvYnNlcnZhYmxlIHRoYXQgd2FpdHMgYSByYW5kb20gYW1vdW50IG9mIHRpbWUgYmV0d2VlbiBlYWNoIGRlbGl2ZXJlZCB2YWx1ZVxuICogY29uc3Qgc291cmNlJCA9IHRpbWVyKGdldFJhbmRvbVRpbWUoKSlcbiAqICAgLnBpcGUoZXhwYW5kKCgpID0+IHRpbWVyKGdldFJhbmRvbVRpbWUoKSkpKTtcbiAqXG4gKiBzb3VyY2UkXG4gKiAgIC5waXBlKHRpbWVvdXQoeyBlYWNoOiA1XzAwMCB9KSlcbiAqICAgLnN1YnNjcmliZSh7XG4gKiAgICAgbmV4dDogY29uc29sZS5sb2csXG4gKiAgICAgZXJyb3I6IGNvbnNvbGUuZXJyb3JcbiAqICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBFbWl0IGEge0BsaW5rIFRpbWVvdXRFcnJvcn0gaWYgdGhlIHNvdXJjZSBkb2VzIG5vdCBlbWl0IGJlZm9yZSA3IHNlY29uZHMsIF9vcl8gaWYgdGhlIHNvdXJjZSB3YWl0cyBsb25nZXIgdGhhblxuICogNSBzZWNvbmRzIGJldHdlZW4gYW55IHR3byB2YWx1ZXMgYWZ0ZXIgdGhlIGZpcnN0LlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyB0aW1lciwgdGltZW91dCwgZXhwYW5kIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgZ2V0UmFuZG9tVGltZSA9ICgpID0+IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwXzAwMCk7XG4gKlxuICogLy8gQW4gb2JzZXJ2YWJsZSB0aGF0IHdhaXRzIGEgcmFuZG9tIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gZWFjaCBkZWxpdmVyZWQgdmFsdWVcbiAqIGNvbnN0IHNvdXJjZSQgPSB0aW1lcihnZXRSYW5kb21UaW1lKCkpXG4gKiAgIC5waXBlKGV4cGFuZCgoKSA9PiB0aW1lcihnZXRSYW5kb21UaW1lKCkpKSk7XG4gKlxuICogc291cmNlJFxuICogICAucGlwZSh0aW1lb3V0KHsgZmlyc3Q6IDdfMDAwLCBlYWNoOiA1XzAwMCB9KSlcbiAqICAgLnN1YnNjcmliZSh7XG4gKiAgICAgbmV4dDogY29uc29sZS5sb2csXG4gKiAgICAgZXJyb3I6IGNvbnNvbGUuZXJyb3JcbiAqICAgfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXQ8VCwgTSA9IHVua25vd24+KGNvbmZpZzogT21pdDxUaW1lb3V0Q29uZmlnPFQsIGFueSwgTT4sICd3aXRoJz4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQ+O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IHdpbGwgZXJyb3IgaWYgdGhlIHNvdXJjZSBkb2VzIG5vdCBwdXNoIGl0cyBmaXJzdCB2YWx1ZSBiZWZvcmUgdGhlIHNwZWNpZmllZCB0aW1lIHBhc3NlZCBhcyBhIGBEYXRlYC5cbiAqIFRoaXMgaXMgZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIGB0aW1lb3V0KHsgZmlyc3Q6IHNvbWVEYXRlIH0pYC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RXJyb3JzIGlmIHRoZSBmaXJzdCB2YWx1ZSBkb2Vzbid0IHNob3cgdXAgYmVmb3JlIHRoZSBnaXZlbiBkYXRlIGFuZCB0aW1lPC9zcGFuPlxuICpcbiAqICFbXSh0aW1lb3V0LnBuZylcbiAqXG4gKiBAcGFyYW0gZmlyc3QgVGhlIGRhdGUgdG8gYXQgd2hpY2ggdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHdpbGwgdGltZW91dCBpZiB0aGUgc291cmNlIG9ic2VydmFibGVcbiAqIGRvZXMgbm90IGVtaXQgYXQgbGVhc3Qgb25lIHZhbHVlLlxuICogQHBhcmFtIHNjaGVkdWxlciBUaGUgc2NoZWR1bGVyIHRvIHVzZS4gRGVmYXVsdHMgdG8ge0BsaW5rIGFzeW5jU2NoZWR1bGVyfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXQ8VD4oZmlyc3Q6IERhdGUsIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2UpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD47XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgd2lsbCBlcnJvciBpZiB0aGUgc291cmNlIGRvZXMgbm90IHB1c2ggYSB2YWx1ZSB3aXRoaW4gdGhlIHNwZWNpZmllZCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqIFRoaXMgaXMgZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIGB0aW1lb3V0KHsgZWFjaDogbWlsbGlzZWNvbmRzIH0pYC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RXJyb3JzIGlmIGl0IHdhaXRzIHRvbyBsb25nIGJldHdlZW4gYW55IHZhbHVlPC9zcGFuPlxuICpcbiAqICFbXSh0aW1lb3V0LnBuZylcbiAqXG4gKiBAcGFyYW0gZWFjaCBUaGUgdGltZSBhbGxvd2VkIGJldHdlZW4gZWFjaCBwdXNoZWQgdmFsdWUgZnJvbSB0aGUgc291cmNlIGJlZm9yZSB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGVcbiAqIHdpbGwgdGltZW91dC5cbiAqIEBwYXJhbSBzY2hlZHVsZXIgVGhlIHNjaGVkdWxlciB0byB1c2UuIERlZmF1bHRzIHRvIHtAbGluayBhc3luY1NjaGVkdWxlcn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0PFQ+KGVhY2g6IG51bWJlciwgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZSk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPjtcblxuLyoqXG4gKlxuICogRXJyb3JzIGlmIE9ic2VydmFibGUgZG9lcyBub3QgZW1pdCBhIHZhbHVlIGluIGdpdmVuIHRpbWUgc3Bhbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGltZW91dHMgb24gT2JzZXJ2YWJsZSB0aGF0IGRvZXNuJ3QgZW1pdCB2YWx1ZXMgZmFzdCBlbm91Z2guPC9zcGFuPlxuICpcbiAqICFbXSh0aW1lb3V0LnBuZylcbiAqXG4gKiBAc2VlIHtAbGluayB0aW1lb3V0V2l0aH1cbiAqXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIGJlaGF2aW91ciBvZiB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLCB1bmxlc3MgdGltZW91dCBoYXBwZW5zIHdoZW4gaXQgdGhyb3dzIGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGltZW91dDxULCBPIGV4dGVuZHMgT2JzZXJ2YWJsZUlucHV0PGFueT4sIE0+KFxuICBjb25maWc6IG51bWJlciB8IERhdGUgfCBUaW1lb3V0Q29uZmlnPFQsIE8sIE0+LFxuICBzY2hlZHVsZXJBcmc/OiBTY2hlZHVsZXJMaWtlXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBPYnNlcnZlZFZhbHVlT2Y8Tz4+IHtcbiAgLy8gSW50ZW50aW9uYWxseSB0ZXJzZSBjb2RlLlxuICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSB2YWxpZCBgRGF0ZWAsIHRoZW4gd2UgdXNlIGl0IGFzIHRoZSBgZmlyc3RgIGNvbmZpZy5cbiAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBgbnVtYmVyYCwgdGhlbiB3ZSB1c2UgaXQgYXMgdGhlIGBlYWNoYCBjb25maWcuXG4gIC8vIE90aGVyd2lzZSwgaXQgY2FuIGJlIGFzc3VtZWQgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBpdHNlbGYsIGFuZFxuICAvLyB3ZSBkZXN0cnVjdHVyZSB0aGF0IGludG8gd2hhdCB3ZSdyZSBnb2luZyB0byB1c2UsIHNldHRpbmcgaW1wb3J0YW50IGRlZmF1bHRzIGFzIHdlIGRvLlxuICAvLyBOT1RFOiBUaGUgZGVmYXVsdCBmb3IgYHNjaGVkdWxlcmAgd2lsbCBiZSB0aGUgYHNjaGVkdWxlcmAgYXJndW1lbnQgaWYgaXQgZXhpc3RzLCBvclxuICAvLyBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIGBhc3luY1NjaGVkdWxlcmAuXG4gIGNvbnN0IHtcbiAgICBmaXJzdCxcbiAgICBlYWNoLFxuICAgIHdpdGg6IF93aXRoID0gdGltZW91dEVycm9yRmFjdG9yeSxcbiAgICBzY2hlZHVsZXIgPSBzY2hlZHVsZXJBcmcgPz8gYXN5bmNTY2hlZHVsZXIsXG4gICAgbWV0YSA9IG51bGwhLFxuICB9ID0gKGlzVmFsaWREYXRlKGNvbmZpZykgPyB7IGZpcnN0OiBjb25maWcgfSA6IHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInID8geyBlYWNoOiBjb25maWcgfSA6IGNvbmZpZykgYXMgVGltZW91dENvbmZpZzxULCBPLCBNPjtcblxuICBpZiAoZmlyc3QgPT0gbnVsbCAmJiBlYWNoID09IG51bGwpIHtcbiAgICAvLyBFbnN1cmUgdGltZW91dCB3YXMgcHJvdmlkZWQgYXQgcnVudGltZS5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyB0aW1lb3V0IHByb3ZpZGVkLicpO1xuICB9XG5cbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIC8vIFRoaXMgc3Vic2NyaXB0aW9uIGVuY2Fwc3VsYXRlcyBvdXIgc3Vic2NyaXB0aW9uIHRvIHRoZVxuICAgIC8vIHNvdXJjZSBmb3IgdGhpcyBvcGVyYXRvci4gV2UncmUgY2FwdHVyaW5nIGl0IHNlcGFyYXRlbHksXG4gICAgLy8gYmVjYXVzZSBpZiB0aGVyZSBpcyBhIGB3aXRoYCBvYnNlcnZhYmxlIHRvIGZhaWwgb3ZlciB0byxcbiAgICAvLyB3ZSB3YW50IHRvIHVuc3Vic2NyaWJlIGZyb20gb3VyIG9yaWdpbmFsIHN1YnNjcmlwdGlvbiwgYW5kXG4gICAgLy8gaGFuZCBvZiB0aGUgc3Vic2NyaXB0aW9uIHRvIHRoYXQgb25lLlxuICAgIGxldCBvcmlnaW5hbFNvdXJjZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIC8vIFRoZSBzdWJzY3JpcHRpb24gZm9yIG91ciB0aW1lb3V0IHRpbWVyLiBUaGlzIGNoYW5nZXNcbiAgICAvLyBldmVyeSB0aW1lIHdlIGdldCBhIG5ldyB2YWx1ZS5cbiAgICBsZXQgdGltZXJTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICAvLyBBIGJpdCBvZiBzdGF0ZSB3ZSBwYXNzIHRvIG91ciB3aXRoIGFuZCBlcnJvciBmYWN0b3JpZXMgdG9cbiAgICAvLyB0ZWxsIHdoYXQgdGhlIGxhc3QgdmFsdWUgd2Ugc2F3IHdhcy5cbiAgICBsZXQgbGFzdFZhbHVlOiBUIHwgbnVsbCA9IG51bGw7XG4gICAgLy8gQSBiaXQgb2Ygc3RhdGUgd2UgcGFzcyB0byB0aGUgd2l0aCBhbmQgZXJyb3IgZmFjdG9yaWVzIHRvXG4gICAgLy8gdGVsbCBob3cgbWFueSB2YWx1ZXMgd2UgaGF2ZSBzZWVuIHNvIGZhci5cbiAgICBsZXQgc2VlbiA9IDA7XG4gICAgY29uc3Qgc3RhcnRUaW1lciA9IChkZWxheTogbnVtYmVyKSA9PiB7XG4gICAgICB0aW1lclN1YnNjcmlwdGlvbiA9IGV4ZWN1dGVTY2hlZHVsZShcbiAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgc2NoZWR1bGVyLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9yaWdpbmFsU291cmNlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBpbm5lckZyb20oXG4gICAgICAgICAgICAgIF93aXRoISh7XG4gICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICBsYXN0VmFsdWUsXG4gICAgICAgICAgICAgICAgc2VlbixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVsYXlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIG9yaWdpbmFsU291cmNlU3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShcbiAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgKHZhbHVlOiBUKSA9PiB7XG4gICAgICAgICAgLy8gY2xlYXIgdGhlIHRpbWVyIHNvIHdlIGNhbiBlbWl0IGFuZCBzdGFydCBhbm90aGVyIG9uZS5cbiAgICAgICAgICB0aW1lclN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBzZWVuKys7XG4gICAgICAgICAgLy8gRW1pdFxuICAgICAgICAgIHN1YnNjcmliZXIubmV4dCgobGFzdFZhbHVlID0gdmFsdWUpKTtcbiAgICAgICAgICAvLyBudWxsIHwgdW5kZWZpbmVkIGFyZSBib3RoIDwgMC4gVGhhbmtzLCBKYXZhU2NyaXB0LlxuICAgICAgICAgIGVhY2ghID4gMCAmJiBzdGFydFRpbWVyKGVhY2ghKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRpbWVyU3Vic2NyaXB0aW9uPy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRpbWVyU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCZSBzdXJlIG5vdCB0byBob2xkIHRoZSBsYXN0IHZhbHVlIGluIG1lbW9yeSBhZnRlciB1bnN1YnNjcmlwdGlvblxuICAgICAgICAgIC8vIGl0IGNvdWxkIGJlIHF1aXRlIGxhcmdlLlxuICAgICAgICAgIGxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gSW50ZW50aW9uYWxseSB0ZXJzZSBjb2RlLlxuICAgIC8vIElmIHdlJ3ZlIGBzZWVuYCBhIHZhbHVlLCB0aGF0IG1lYW5zIHRoZSBcImZpcnN0XCIgY2xhdXNlIHdhcyBtZXQgYWxyZWFkeSwgaWYgaXQgZXhpc3RlZC5cbiAgICAvLyAgIGl0IGFsc28gbWVhbnMgdGhhdCBhIHRpbWVyIHdhcyBhbHJlYWR5IHN0YXJ0ZWQgZm9yIFwiZWFjaFwiIChpbiB0aGUgbmV4dCBoYW5kbGVyIGFib3ZlKS5cbiAgICAvLyBJZiBgZmlyc3RgIHdhcyBwcm92aWRlZCwgYW5kIGl0J3MgYSBudW1iZXIsIHRoZW4gdXNlIGl0LlxuICAgIC8vIElmIGBmaXJzdGAgd2FzIHByb3ZpZGVkIGFuZCBpdCdzIG5vdCBhIG51bWJlciwgaXQncyBhIERhdGUsIGFuZCB3ZSBnZXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBpdCBhbmQgXCJub3dcIi5cbiAgICAvLyBJZiBgZmlyc3RgIHdhcyBub3QgcHJvdmlkZWQgYXQgYWxsLCB0aGVuIG91ciBmaXJzdCB0aW1lciB3aWxsIGJlIHRoZSB2YWx1ZSBmcm9tIGBlYWNoYC5cbiAgICAhc2VlbiAmJiBzdGFydFRpbWVyKGZpcnN0ICE9IG51bGwgPyAodHlwZW9mIGZpcnN0ID09PSAnbnVtYmVyJyA/IGZpcnN0IDogK2ZpcnN0IC0gc2NoZWR1bGVyIS5ub3coKSkgOiBlYWNoISk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIHVzZSB0byBlbWl0IGFuIGVycm9yIHdoZW4gdGltZW91dCBvY2N1cnMgYW5kIGEgYHdpdGhgIGZ1bmN0aW9uXG4gKiBpcyBub3Qgc3BlY2lmaWVkLlxuICogQHBhcmFtIGluZm8gVGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0aW1lb3V0IHRvIHBhc3MgYWxvbmcgdG8gdGhlIGVycm9yXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXRFcnJvckZhY3RvcnkoaW5mbzogVGltZW91dEluZm88YW55Pik6IE9ic2VydmFibGU8bmV2ZXI+IHtcbiAgdGhyb3cgbmV3IFRpbWVvdXRFcnJvcihpbmZvKTtcbn1cbiJdfQ==
