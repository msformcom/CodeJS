import { Subject } from '../Subject.mjs';
import { Subscription } from '../Subscription.mjs';
import { operate } from '../util/lift.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { noop } from '../util/noop.mjs';
import { arrRemove } from '../util/arrRemove.mjs';
/**
 * Branch out the source Observable values as a nested Observable starting from
 * an emission from `openings` and ending when the output of `closingSelector`
 * emits.
 *
 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
 * Observable instead of an array.</span>
 *
 * ![](windowToggle.png)
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows that contain those items
 * emitted by the source Observable between the time when the `openings`
 * Observable emits an item and when the Observable returned by
 * `closingSelector` emits an item.
 *
 * ## Example
 *
 * Every other second, emit the click events from the next 500ms
 *
 * ```ts
 * import { fromEvent, interval, windowToggle, EMPTY, mergeAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const openings = interval(1000);
 * const result = clicks.pipe(
 *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),
 *   mergeAll()
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowWhen}
 * @see {@link bufferToggle}
 *
 * @param {Observable<O>} openings An observable of notifications to start new
 * windows.
 * @param {function(value: O): Observable} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns an Observable,
 * which, when it emits a next notification, signals that the
 * associated window should complete.
 * @return A function that returns an Observable of windows, which in turn are
 * Observables.
 */
export function windowToggle(openings, closingSelector) {
    return operate((source, subscriber) => {
        const windows = [];
        const handleError = (err) => {
            while (0 < windows.length) {
                windows.shift().error(err);
            }
            subscriber.error(err);
        };
        innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, (openValue) => {
            const window = new Subject();
            windows.push(window);
            const closingSubscription = new Subscription();
            const closeWindow = () => {
                arrRemove(windows, window);
                window.complete();
                closingSubscription.unsubscribe();
            };
            let closingNotifier;
            try {
                closingNotifier = innerFrom(closingSelector(openValue));
            }
            catch (err) {
                handleError(err);
                return;
            }
            subscriber.next(window.asObservable());
            closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError)));
        }, noop));
        // Subscribe to the source to get things started.
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            // Copy the windows array before we emit to
            // make sure we don't have issues with reentrant code.
            const windowsCopy = windows.slice();
            for (const window of windowsCopy) {
                window.next(value);
            }
        }, () => {
            // Complete all of our windows before we complete.
            while (0 < windows.length) {
                windows.shift().complete();
            }
            subscriber.complete();
        }, handleError, () => {
            // Add this finalization so that all window subjects are
            // disposed of. This way, if a user tries to subscribe
            // to a window *after* the outer subscription has been unsubscribed,
            // they will get an error, instead of waiting forever to
            // see if a value arrives.
            while (0 < windows.length) {
                windows.shift().unsubscribe();
            }
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93VG9nZ2xlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDckMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRS9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDcEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRTlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOENHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FDMUIsUUFBNEIsRUFDNUIsZUFBdUQ7SUFFdkQsT0FBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDcEMsTUFBTSxPQUFPLEdBQWlCLEVBQUUsQ0FBQztRQUVqQyxNQUFNLFdBQVcsR0FBRyxDQUFDLEdBQVEsRUFBRSxFQUFFO1lBQy9CLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDMUIsT0FBTyxDQUFDLEtBQUssRUFBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM5QixDQUFDO1lBQ0QsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4QixDQUFDLENBQUM7UUFFRixTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsU0FBUyxDQUMzQix3QkFBd0IsQ0FDdEIsVUFBVSxFQUNWLENBQUMsU0FBUyxFQUFFLEVBQUU7WUFDWixNQUFNLE1BQU0sR0FBRyxJQUFJLE9BQU8sRUFBSyxDQUFDO1lBQ2hDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDckIsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQy9DLE1BQU0sV0FBVyxHQUFHLEdBQUcsRUFBRTtnQkFDdkIsU0FBUyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFDM0IsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNsQixtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNwQyxDQUFDLENBQUM7WUFFRixJQUFJLGVBQWdDLENBQUM7WUFDckMsSUFBSSxDQUFDO2dCQUNILGVBQWUsR0FBRyxTQUFTLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDMUQsQ0FBQztZQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7Z0JBQ2IsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNqQixPQUFPO1lBQ1QsQ0FBQztZQUVELFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7WUFFdkMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsd0JBQXdCLENBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNILENBQUMsRUFDRCxJQUFJLENBQ0wsQ0FDRixDQUFDO1FBRUYsaURBQWlEO1FBQ2pELE1BQU0sQ0FBQyxTQUFTLENBQ2Qsd0JBQXdCLENBQ3RCLFVBQVUsRUFDVixDQUFDLEtBQVEsRUFBRSxFQUFFO1lBQ1gsMkNBQTJDO1lBQzNDLHNEQUFzRDtZQUN0RCxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDcEMsS0FBSyxNQUFNLE1BQU0sSUFBSSxXQUFXLEVBQUUsQ0FBQztnQkFDakMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNyQixDQUFDO1FBQ0gsQ0FBQyxFQUNELEdBQUcsRUFBRTtZQUNILGtEQUFrRDtZQUNsRCxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQzFCLE9BQU8sQ0FBQyxLQUFLLEVBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUM5QixDQUFDO1lBQ0QsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3hCLENBQUMsRUFDRCxXQUFXLEVBQ1gsR0FBRyxFQUFFO1lBQ0gsd0RBQXdEO1lBQ3hELHNEQUFzRDtZQUN0RCxvRUFBb0U7WUFDcEUsd0RBQXdEO1lBQ3hELDBCQUEwQjtZQUMxQixPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQzFCLE9BQU8sQ0FBQyxLQUFLLEVBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNqQyxDQUFDO1FBQ0gsQ0FBQyxDQUNGLENBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd1RvZ2dsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlSW5wdXQsIE9wZXJhdG9yRnVuY3Rpb24gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlsL25vb3AnO1xuaW1wb3J0IHsgYXJyUmVtb3ZlIH0gZnJvbSAnLi4vdXRpbC9hcnJSZW1vdmUnO1xuXG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHN0YXJ0aW5nIGZyb21cbiAqIGFuIGVtaXNzaW9uIGZyb20gYG9wZW5pbmdzYCBhbmQgZW5kaW5nIHdoZW4gdGhlIG91dHB1dCBvZiBgY2xvc2luZ1NlbGVjdG9yYFxuICogZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfSwgYnV0IGVtaXRzIGEgbmVzdGVkXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqICFbXSh3aW5kb3dUb2dnbGUucG5nKVxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgd2luZG93cyB0aGF0IGNvbnRhaW4gdGhvc2UgaXRlbXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJldHdlZW4gdGhlIHRpbWUgd2hlbiB0aGUgYG9wZW5pbmdzYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhbiBpdGVtIGFuZCB3aGVuIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgY2xvc2luZ1NlbGVjdG9yYCBlbWl0cyBhbiBpdGVtLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBFdmVyeSBvdGhlciBzZWNvbmQsIGVtaXQgdGhlIGNsaWNrIGV2ZW50cyBmcm9tIHRoZSBuZXh0IDUwMG1zXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21FdmVudCwgaW50ZXJ2YWwsIHdpbmRvd1RvZ2dsZSwgRU1QVFksIG1lcmdlQWxsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IG9wZW5pbmdzID0gaW50ZXJ2YWwoMTAwMCk7XG4gKiBjb25zdCByZXN1bHQgPSBjbGlja3MucGlwZShcbiAqICAgd2luZG93VG9nZ2xlKG9wZW5pbmdzLCBpID0+IGkgJSAyID8gaW50ZXJ2YWwoNTAwKSA6IEVNUFRZKSxcbiAqICAgbWVyZ2VBbGwoKVxuICogKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dDb3VudH1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZTxPPn0gb3BlbmluZ3MgQW4gb2JzZXJ2YWJsZSBvZiBub3RpZmljYXRpb25zIHRvIHN0YXJ0IG5ld1xuICogd2luZG93cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IE8pOiBPYnNlcnZhYmxlfSBjbG9zaW5nU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzXG4gKiB0aGUgdmFsdWUgZW1pdHRlZCBieSB0aGUgYG9wZW5pbmdzYCBvYnNlcnZhYmxlIGFuZCByZXR1cm5zIGFuIE9ic2VydmFibGUsXG4gKiB3aGljaCwgd2hlbiBpdCBlbWl0cyBhIG5leHQgbm90aWZpY2F0aW9uLCBzaWduYWxzIHRoYXQgdGhlXG4gKiBhc3NvY2lhdGVkIHdpbmRvdyBzaG91bGQgY29tcGxldGUuXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggaW4gdHVybiBhcmVcbiAqIE9ic2VydmFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd2luZG93VG9nZ2xlPFQsIE8+KFxuICBvcGVuaW5nczogT2JzZXJ2YWJsZUlucHV0PE8+LFxuICBjbG9zaW5nU2VsZWN0b3I6IChvcGVuVmFsdWU6IE8pID0+IE9ic2VydmFibGVJbnB1dDxhbnk+XG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIE9ic2VydmFibGU8VD4+IHtcbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIGNvbnN0IHdpbmRvd3M6IFN1YmplY3Q8VD5bXSA9IFtdO1xuXG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyOiBhbnkpID0+IHtcbiAgICAgIHdoaWxlICgwIDwgd2luZG93cy5sZW5ndGgpIHtcbiAgICAgICAgd2luZG93cy5zaGlmdCgpIS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgIH07XG5cbiAgICBpbm5lckZyb20ob3BlbmluZ3MpLnN1YnNjcmliZShcbiAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgKG9wZW5WYWx1ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHdpbmRvdyA9IG5ldyBTdWJqZWN0PFQ+KCk7XG4gICAgICAgICAgd2luZG93cy5wdXNoKHdpbmRvdyk7XG4gICAgICAgICAgY29uc3QgY2xvc2luZ1N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICBjb25zdCBjbG9zZVdpbmRvdyA9ICgpID0+IHtcbiAgICAgICAgICAgIGFyclJlbW92ZSh3aW5kb3dzLCB3aW5kb3cpO1xuICAgICAgICAgICAgd2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICBjbG9zaW5nU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGxldCBjbG9zaW5nTm90aWZpZXI6IE9ic2VydmFibGU8YW55PjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xvc2luZ05vdGlmaWVyID0gaW5uZXJGcm9tKGNsb3NpbmdTZWxlY3RvcihvcGVuVmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHdpbmRvdy5hc09ic2VydmFibGUoKSk7XG5cbiAgICAgICAgICBjbG9zaW5nU3Vic2NyaXB0aW9uLmFkZChjbG9zaW5nTm90aWZpZXIuc3Vic2NyaWJlKGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBjbG9zZVdpbmRvdywgbm9vcCwgaGFuZGxlRXJyb3IpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG5vb3BcbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgdG8gZ2V0IHRoaW5ncyBzdGFydGVkLlxuICAgIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoXG4gICAgICAgIHN1YnNjcmliZXIsXG4gICAgICAgICh2YWx1ZTogVCkgPT4ge1xuICAgICAgICAgIC8vIENvcHkgdGhlIHdpbmRvd3MgYXJyYXkgYmVmb3JlIHdlIGVtaXQgdG9cbiAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBpc3N1ZXMgd2l0aCByZWVudHJhbnQgY29kZS5cbiAgICAgICAgICBjb25zdCB3aW5kb3dzQ29weSA9IHdpbmRvd3Muc2xpY2UoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHdpbmRvdyBvZiB3aW5kb3dzQ29weSkge1xuICAgICAgICAgICAgd2luZG93Lm5leHQodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIENvbXBsZXRlIGFsbCBvZiBvdXIgd2luZG93cyBiZWZvcmUgd2UgY29tcGxldGUuXG4gICAgICAgICAgd2hpbGUgKDAgPCB3aW5kb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgd2luZG93cy5zaGlmdCgpIS5jb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gQWRkIHRoaXMgZmluYWxpemF0aW9uIHNvIHRoYXQgYWxsIHdpbmRvdyBzdWJqZWN0cyBhcmVcbiAgICAgICAgICAvLyBkaXNwb3NlZCBvZi4gVGhpcyB3YXksIGlmIGEgdXNlciB0cmllcyB0byBzdWJzY3JpYmVcbiAgICAgICAgICAvLyB0byBhIHdpbmRvdyAqYWZ0ZXIqIHRoZSBvdXRlciBzdWJzY3JpcHRpb24gaGFzIGJlZW4gdW5zdWJzY3JpYmVkLFxuICAgICAgICAgIC8vIHRoZXkgd2lsbCBnZXQgYW4gZXJyb3IsIGluc3RlYWQgb2Ygd2FpdGluZyBmb3JldmVyIHRvXG4gICAgICAgICAgLy8gc2VlIGlmIGEgdmFsdWUgYXJyaXZlcy5cbiAgICAgICAgICB3aGlsZSAoMCA8IHdpbmRvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkhLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSk7XG59XG4iXX0=
