import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
/**
 * Compares all values of two observables in sequence using an optional comparator function
 * and returns an observable of a single boolean value representing whether or not the two sequences
 * are equal.
 *
 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
 *
 * ![](sequenceEqual.png)
 *
 * `sequenceEqual` subscribes to source observable and `compareTo` `ObservableInput` (that internally
 * gets converted to an observable) and buffers incoming values from each observable. Whenever either
 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
 * observables completes, the operator will wait for the other observable to complete; If the other
 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
 * completes or emits after the other completes, the returned observable will never complete.
 *
 * ## Example
 *
 * Figure out if the Konami code matches
 *
 * ```ts
 * import { from, fromEvent, map, bufferCount, mergeMap, sequenceEqual } from 'rxjs';
 *
 * const codes = from([
 *   'ArrowUp',
 *   'ArrowUp',
 *   'ArrowDown',
 *   'ArrowDown',
 *   'ArrowLeft',
 *   'ArrowRight',
 *   'ArrowLeft',
 *   'ArrowRight',
 *   'KeyB',
 *   'KeyA',
 *   'Enter', // no start key, clearly.
 * ]);
 *
 * const keys = fromEvent<KeyboardEvent>(document, 'keyup').pipe(map(e => e.code));
 * const matches = keys.pipe(
 *   bufferCount(11, 1),
 *   mergeMap(last11 => from(last11).pipe(sequenceEqual(codes)))
 * );
 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
 * ```
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 * @see {@link withLatestFrom}
 *
 * @param compareTo The `ObservableInput` sequence to compare the source sequence to.
 * @param comparator An optional function to compare each value pair.
 *
 * @return A function that returns an Observable that emits a single boolean
 * value representing whether or not the values emitted by the source
 * Observable and provided `ObservableInput` were equal in sequence.
 */
export function sequenceEqual(compareTo, comparator = (a, b) => a === b) {
    return operate((source, subscriber) => {
        // The state for the source observable
        const aState = createState();
        // The state for the compareTo observable;
        const bState = createState();
        /** A utility to emit and complete */
        const emit = (isEqual) => {
            subscriber.next(isEqual);
            subscriber.complete();
        };
        /**
         * Creates a subscriber that subscribes to one of the sources, and compares its collected
         * state -- `selfState` -- to the other source's collected state -- `otherState`. This
         * is used for both streams.
         */
        const createSubscriber = (selfState, otherState) => {
            const sequenceEqualSubscriber = createOperatorSubscriber(subscriber, (a) => {
                const { buffer, complete } = otherState;
                if (buffer.length === 0) {
                    // If there's no values in the other buffer
                    // and the other stream is complete, we know
                    // this isn't a match, because we got one more value.
                    // Otherwise, we push onto our buffer, so when the other
                    // stream emits, it can pull this value off our buffer and check it
                    // at the appropriate time.
                    complete ? emit(false) : selfState.buffer.push(a);
                }
                else {
                    // If the other stream *does* have values in its buffer,
                    // pull the oldest one off so we can compare it to what we
                    // just got. If it wasn't a match, emit `false` and complete.
                    !comparator(a, buffer.shift()) && emit(false);
                }
            }, () => {
                // Or observable completed
                selfState.complete = true;
                const { complete, buffer } = otherState;
                // If the other observable is also complete, and there's
                // still stuff left in their buffer, it doesn't match, if their
                // buffer is empty, then it does match. This is because we can't
                // possibly get more values here anymore.
                complete && emit(buffer.length === 0);
                // Be sure to clean up our stream as soon as possible if we can.
                sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
            });
            return sequenceEqualSubscriber;
        };
        // Subscribe to each source.
        source.subscribe(createSubscriber(aState, bState));
        innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
    });
}
/**
 * Creates a simple structure that is used to represent
 * data used to test each sequence.
 */
function createState() {
    return {
        buffer: [],
        complete: false,
    };
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc2VxdWVuY2VFcXVhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUVwRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F3REc7QUFDSCxNQUFNLFVBQVUsYUFBYSxDQUMzQixTQUE2QixFQUM3QixhQUFzQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDO0lBRXZELE9BQU8sT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxFQUFFO1FBQ3BDLHNDQUFzQztRQUN0QyxNQUFNLE1BQU0sR0FBRyxXQUFXLEVBQUssQ0FBQztRQUNoQywwQ0FBMEM7UUFDMUMsTUFBTSxNQUFNLEdBQUcsV0FBVyxFQUFLLENBQUM7UUFFaEMscUNBQXFDO1FBQ3JDLE1BQU0sSUFBSSxHQUFHLENBQUMsT0FBZ0IsRUFBRSxFQUFFO1lBQ2hDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDekIsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3hCLENBQUMsQ0FBQztRQUVGOzs7O1dBSUc7UUFDSCxNQUFNLGdCQUFnQixHQUFHLENBQUMsU0FBMkIsRUFBRSxVQUE0QixFQUFFLEVBQUU7WUFDckYsTUFBTSx1QkFBdUIsR0FBRyx3QkFBd0IsQ0FDdEQsVUFBVSxFQUNWLENBQUMsQ0FBSSxFQUFFLEVBQUU7Z0JBQ1AsTUFBTSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxVQUFVLENBQUM7Z0JBQ3hDLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztvQkFDeEIsMkNBQTJDO29CQUMzQyw0Q0FBNEM7b0JBQzVDLHFEQUFxRDtvQkFDckQsd0RBQXdEO29CQUN4RCxtRUFBbUU7b0JBQ25FLDJCQUEyQjtvQkFDM0IsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNwRCxDQUFDO3FCQUFNLENBQUM7b0JBQ04sd0RBQXdEO29CQUN4RCwwREFBMEQ7b0JBQzFELDZEQUE2RDtvQkFDN0QsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDakQsQ0FBQztZQUNILENBQUMsRUFDRCxHQUFHLEVBQUU7Z0JBQ0gsMEJBQTBCO2dCQUMxQixTQUFTLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztnQkFDMUIsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsR0FBRyxVQUFVLENBQUM7Z0JBQ3hDLHdEQUF3RDtnQkFDeEQsK0RBQStEO2dCQUMvRCxnRUFBZ0U7Z0JBQ2hFLHlDQUF5QztnQkFDekMsUUFBUSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUN0QyxnRUFBZ0U7Z0JBQ2hFLHVCQUF1QixhQUF2Qix1QkFBdUIsdUJBQXZCLHVCQUF1QixDQUFFLFdBQVcsRUFBRSxDQUFDO1lBQ3pDLENBQUMsQ0FDRixDQUFDO1lBRUYsT0FBTyx1QkFBdUIsQ0FBQztRQUNqQyxDQUFDLENBQUM7UUFFRiw0QkFBNEI7UUFDNUIsTUFBTSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNuRCxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ25FLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQVlEOzs7R0FHRztBQUNILFNBQVMsV0FBVztJQUNsQixPQUFPO1FBQ0wsTUFBTSxFQUFFLEVBQUU7UUFDVixRQUFRLEVBQUUsS0FBSztLQUNoQixDQUFDO0FBQ0osQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3NlcXVlbmNlRXF1YWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcblxuLyoqXG4gKiBDb21wYXJlcyBhbGwgdmFsdWVzIG9mIHR3byBvYnNlcnZhYmxlcyBpbiBzZXF1ZW5jZSB1c2luZyBhbiBvcHRpb25hbCBjb21wYXJhdG9yIGZ1bmN0aW9uXG4gKiBhbmQgcmV0dXJucyBhbiBvYnNlcnZhYmxlIG9mIGEgc2luZ2xlIGJvb2xlYW4gdmFsdWUgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSB0d28gc2VxdWVuY2VzXG4gKiBhcmUgZXF1YWwuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNoZWNrcyB0byBzZWUgb2YgYWxsIHZhbHVlcyBlbWl0dGVkIGJ5IGJvdGggb2JzZXJ2YWJsZXMgYXJlIGVxdWFsLCBpbiBvcmRlci48L3NwYW4+XG4gKlxuICogIVtdKHNlcXVlbmNlRXF1YWwucG5nKVxuICpcbiAqIGBzZXF1ZW5jZUVxdWFsYCBzdWJzY3JpYmVzIHRvIHNvdXJjZSBvYnNlcnZhYmxlIGFuZCBgY29tcGFyZVRvYCBgT2JzZXJ2YWJsZUlucHV0YCAodGhhdCBpbnRlcm5hbGx5XG4gKiBnZXRzIGNvbnZlcnRlZCB0byBhbiBvYnNlcnZhYmxlKSBhbmQgYnVmZmVycyBpbmNvbWluZyB2YWx1ZXMgZnJvbSBlYWNoIG9ic2VydmFibGUuIFdoZW5ldmVyIGVpdGhlclxuICogb2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLCB0aGUgdmFsdWUgaXMgYnVmZmVyZWQgYW5kIHRoZSBidWZmZXJzIGFyZSBzaGlmdGVkIGFuZCBjb21wYXJlZCBmcm9tIHRoZSBib3R0b21cbiAqIHVwOyBJZiBhbnkgdmFsdWUgcGFpciBkb2Vzbid0IG1hdGNoLCB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSB3aWxsIGVtaXQgYGZhbHNlYCBhbmQgY29tcGxldGUuIElmIG9uZSBvZiB0aGVcbiAqIG9ic2VydmFibGVzIGNvbXBsZXRlcywgdGhlIG9wZXJhdG9yIHdpbGwgd2FpdCBmb3IgdGhlIG90aGVyIG9ic2VydmFibGUgdG8gY29tcGxldGU7IElmIHRoZSBvdGhlclxuICogb2JzZXJ2YWJsZSBlbWl0cyBiZWZvcmUgY29tcGxldGluZywgdGhlIHJldHVybmVkIG9ic2VydmFibGUgd2lsbCBlbWl0IGBmYWxzZWAgYW5kIGNvbXBsZXRlLiBJZiBvbmUgb2JzZXJ2YWJsZSBuZXZlclxuICogY29tcGxldGVzIG9yIGVtaXRzIGFmdGVyIHRoZSBvdGhlciBjb21wbGV0ZXMsIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdpbGwgbmV2ZXIgY29tcGxldGUuXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIEZpZ3VyZSBvdXQgaWYgdGhlIEtvbmFtaSBjb2RlIG1hdGNoZXNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbSwgZnJvbUV2ZW50LCBtYXAsIGJ1ZmZlckNvdW50LCBtZXJnZU1hcCwgc2VxdWVuY2VFcXVhbCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IGNvZGVzID0gZnJvbShbXG4gKiAgICdBcnJvd1VwJyxcbiAqICAgJ0Fycm93VXAnLFxuICogICAnQXJyb3dEb3duJyxcbiAqICAgJ0Fycm93RG93bicsXG4gKiAgICdBcnJvd0xlZnQnLFxuICogICAnQXJyb3dSaWdodCcsXG4gKiAgICdBcnJvd0xlZnQnLFxuICogICAnQXJyb3dSaWdodCcsXG4gKiAgICdLZXlCJyxcbiAqICAgJ0tleUEnLFxuICogICAnRW50ZXInLCAvLyBubyBzdGFydCBrZXksIGNsZWFybHkuXG4gKiBdKTtcbiAqXG4gKiBjb25zdCBrZXlzID0gZnJvbUV2ZW50PEtleWJvYXJkRXZlbnQ+KGRvY3VtZW50LCAna2V5dXAnKS5waXBlKG1hcChlID0+IGUuY29kZSkpO1xuICogY29uc3QgbWF0Y2hlcyA9IGtleXMucGlwZShcbiAqICAgYnVmZmVyQ291bnQoMTEsIDEpLFxuICogICBtZXJnZU1hcChsYXN0MTEgPT4gZnJvbShsYXN0MTEpLnBpcGUoc2VxdWVuY2VFcXVhbChjb2RlcykpKVxuICogKTtcbiAqIG1hdGNoZXMuc3Vic2NyaWJlKG1hdGNoZWQgPT4gY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWwgY2hlYXQgYXQgQ29udHJhPyAnLCBtYXRjaGVkKSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICogQHNlZSB7QGxpbmsgemlwfVxuICogQHNlZSB7QGxpbmsgd2l0aExhdGVzdEZyb219XG4gKlxuICogQHBhcmFtIGNvbXBhcmVUbyBUaGUgYE9ic2VydmFibGVJbnB1dGAgc2VxdWVuY2UgdG8gY29tcGFyZSB0aGUgc291cmNlIHNlcXVlbmNlIHRvLlxuICogQHBhcmFtIGNvbXBhcmF0b3IgQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gY29tcGFyZSBlYWNoIHZhbHVlIHBhaXIuXG4gKlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBzaW5nbGUgYm9vbGVhblxuICogdmFsdWUgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGFuZCBwcm92aWRlZCBgT2JzZXJ2YWJsZUlucHV0YCB3ZXJlIGVxdWFsIGluIHNlcXVlbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVuY2VFcXVhbDxUPihcbiAgY29tcGFyZVRvOiBPYnNlcnZhYmxlSW5wdXQ8VD4sXG4gIGNvbXBhcmF0b3I6IChhOiBULCBiOiBUKSA9PiBib29sZWFuID0gKGEsIGIpID0+IGEgPT09IGJcbik6IE9wZXJhdG9yRnVuY3Rpb248VCwgYm9vbGVhbj4ge1xuICByZXR1cm4gb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgLy8gVGhlIHN0YXRlIGZvciB0aGUgc291cmNlIG9ic2VydmFibGVcbiAgICBjb25zdCBhU3RhdGUgPSBjcmVhdGVTdGF0ZTxUPigpO1xuICAgIC8vIFRoZSBzdGF0ZSBmb3IgdGhlIGNvbXBhcmVUbyBvYnNlcnZhYmxlO1xuICAgIGNvbnN0IGJTdGF0ZSA9IGNyZWF0ZVN0YXRlPFQ+KCk7XG5cbiAgICAvKiogQSB1dGlsaXR5IHRvIGVtaXQgYW5kIGNvbXBsZXRlICovXG4gICAgY29uc3QgZW1pdCA9IChpc0VxdWFsOiBib29sZWFuKSA9PiB7XG4gICAgICBzdWJzY3JpYmVyLm5leHQoaXNFcXVhbCk7XG4gICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdWJzY3JpYmVyIHRoYXQgc3Vic2NyaWJlcyB0byBvbmUgb2YgdGhlIHNvdXJjZXMsIGFuZCBjb21wYXJlcyBpdHMgY29sbGVjdGVkXG4gICAgICogc3RhdGUgLS0gYHNlbGZTdGF0ZWAgLS0gdG8gdGhlIG90aGVyIHNvdXJjZSdzIGNvbGxlY3RlZCBzdGF0ZSAtLSBgb3RoZXJTdGF0ZWAuIFRoaXNcbiAgICAgKiBpcyB1c2VkIGZvciBib3RoIHN0cmVhbXMuXG4gICAgICovXG4gICAgY29uc3QgY3JlYXRlU3Vic2NyaWJlciA9IChzZWxmU3RhdGU6IFNlcXVlbmNlU3RhdGU8VD4sIG90aGVyU3RhdGU6IFNlcXVlbmNlU3RhdGU8VD4pID0+IHtcbiAgICAgIGNvbnN0IHNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyID0gY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAoYTogVCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgYnVmZmVyLCBjb21wbGV0ZSB9ID0gb3RoZXJTdGF0ZTtcbiAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyB2YWx1ZXMgaW4gdGhlIG90aGVyIGJ1ZmZlclxuICAgICAgICAgICAgLy8gYW5kIHRoZSBvdGhlciBzdHJlYW0gaXMgY29tcGxldGUsIHdlIGtub3dcbiAgICAgICAgICAgIC8vIHRoaXMgaXNuJ3QgYSBtYXRjaCwgYmVjYXVzZSB3ZSBnb3Qgb25lIG1vcmUgdmFsdWUuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHB1c2ggb250byBvdXIgYnVmZmVyLCBzbyB3aGVuIHRoZSBvdGhlclxuICAgICAgICAgICAgLy8gc3RyZWFtIGVtaXRzLCBpdCBjYW4gcHVsbCB0aGlzIHZhbHVlIG9mZiBvdXIgYnVmZmVyIGFuZCBjaGVjayBpdFxuICAgICAgICAgICAgLy8gYXQgdGhlIGFwcHJvcHJpYXRlIHRpbWUuXG4gICAgICAgICAgICBjb21wbGV0ZSA/IGVtaXQoZmFsc2UpIDogc2VsZlN0YXRlLmJ1ZmZlci5wdXNoKGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb3RoZXIgc3RyZWFtICpkb2VzKiBoYXZlIHZhbHVlcyBpbiBpdHMgYnVmZmVyLFxuICAgICAgICAgICAgLy8gcHVsbCB0aGUgb2xkZXN0IG9uZSBvZmYgc28gd2UgY2FuIGNvbXBhcmUgaXQgdG8gd2hhdCB3ZVxuICAgICAgICAgICAgLy8ganVzdCBnb3QuIElmIGl0IHdhc24ndCBhIG1hdGNoLCBlbWl0IGBmYWxzZWAgYW5kIGNvbXBsZXRlLlxuICAgICAgICAgICAgIWNvbXBhcmF0b3IoYSwgYnVmZmVyLnNoaWZ0KCkhKSAmJiBlbWl0KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBPciBvYnNlcnZhYmxlIGNvbXBsZXRlZFxuICAgICAgICAgIHNlbGZTdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgY29uc3QgeyBjb21wbGV0ZSwgYnVmZmVyIH0gPSBvdGhlclN0YXRlO1xuICAgICAgICAgIC8vIElmIHRoZSBvdGhlciBvYnNlcnZhYmxlIGlzIGFsc28gY29tcGxldGUsIGFuZCB0aGVyZSdzXG4gICAgICAgICAgLy8gc3RpbGwgc3R1ZmYgbGVmdCBpbiB0aGVpciBidWZmZXIsIGl0IGRvZXNuJ3QgbWF0Y2gsIGlmIHRoZWlyXG4gICAgICAgICAgLy8gYnVmZmVyIGlzIGVtcHR5LCB0aGVuIGl0IGRvZXMgbWF0Y2guIFRoaXMgaXMgYmVjYXVzZSB3ZSBjYW4ndFxuICAgICAgICAgIC8vIHBvc3NpYmx5IGdldCBtb3JlIHZhbHVlcyBoZXJlIGFueW1vcmUuXG4gICAgICAgICAgY29tcGxldGUgJiYgZW1pdChidWZmZXIubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAvLyBCZSBzdXJlIHRvIGNsZWFuIHVwIG91ciBzdHJlYW0gYXMgc29vbiBhcyBwb3NzaWJsZSBpZiB3ZSBjYW4uXG4gICAgICAgICAgc2VxdWVuY2VFcXVhbFN1YnNjcmliZXI/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBzZXF1ZW5jZUVxdWFsU3Vic2NyaWJlcjtcbiAgICB9O1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIGVhY2ggc291cmNlLlxuICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihhU3RhdGUsIGJTdGF0ZSkpO1xuICAgIGlubmVyRnJvbShjb21wYXJlVG8pLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKGJTdGF0ZSwgYVN0YXRlKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIHN0cnVjdHVyZSBmb3IgdGhlIGRhdGEgdXNlZCB0byB0ZXN0IGVhY2ggc2VxdWVuY2VcbiAqL1xuaW50ZXJmYWNlIFNlcXVlbmNlU3RhdGU8VD4ge1xuICAvKiogQSB0ZW1wb3Jhcnkgc3RvcmUgZm9yIGFycml2ZWQgdmFsdWVzIGJlZm9yZSB0aGV5IGFyZSBjaGVja2VkICovXG4gIGJ1ZmZlcjogVFtdO1xuICAvKiogV2hldGhlciBvciBub3QgdGhlIHNlcXVlbmNlIHNvdXJjZSBoYXMgY29tcGxldGVkLiAqL1xuICBjb21wbGV0ZTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2ltcGxlIHN0cnVjdHVyZSB0aGF0IGlzIHVzZWQgdG8gcmVwcmVzZW50XG4gKiBkYXRhIHVzZWQgdG8gdGVzdCBlYWNoIHNlcXVlbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZTxUPigpOiBTZXF1ZW5jZVN0YXRlPFQ+IHtcbiAgcmV0dXJuIHtcbiAgICBidWZmZXI6IFtdLFxuICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgfTtcbn1cbiJdfQ==
