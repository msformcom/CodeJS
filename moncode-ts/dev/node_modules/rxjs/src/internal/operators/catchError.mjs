import { innerFrom } from '../observable/innerFrom.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { operate } from '../util/lift.mjs';
/* tslint:enable:max-line-length */
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <span class="informal">
 * It only listens to the error channel and ignores notifications.
 * Handles errors from the source observable, and maps them to a new observable.
 * The error may also be rethrown, or a new error can be thrown to emit an error from the result.
 * </span>
 *
 * ![](catch.png)
 *
 * This operator handles errors, but forwards along all other events to the resulting observable.
 * If the source observable terminates with an error, it will map that error to a new observable,
 * subscribe to it, and forward all of its events to the resulting observable.
 *
 * ## Examples
 *
 * Continue with a different Observable when there's an error
 *
 * ```ts
 * import { of, map, catchError } from 'rxjs';
 *
 * of(1, 2, 3, 4, 5)
 *   .pipe(
 *     map(n => {
 *       if (n === 4) {
 *         throw 'four!';
 *       }
 *       return n;
 *     }),
 *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))
 *   )
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 * ```
 *
 * Retry the caught source Observable again in case of error, similar to `retry()` operator
 *
 * ```ts
 * import { of, map, catchError, take } from 'rxjs';
 *
 * of(1, 2, 3, 4, 5)
 *   .pipe(
 *     map(n => {
 *       if (n === 4) {
 *         throw 'four!';
 *       }
 *       return n;
 *     }),
 *     catchError((err, caught) => caught),
 *     take(30)
 *   )
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 * ```
 *
 * Throw a new error when the source Observable throws an error
 *
 * ```ts
 * import { of, map, catchError } from 'rxjs';
 *
 * of(1, 2, 3, 4, 5)
 *   .pipe(
 *     map(n => {
 *       if (n === 4) {
 *         throw 'four!';
 *       }
 *       return n;
 *     }),
 *     catchError(err => {
 *       throw 'error in source. Details: ' + err;
 *     })
 *   )
 *   .subscribe({
 *     next: x => console.log(x),
 *     error: err => console.log(err)
 *   });
 *   // 1, 2, 3, error in source. Details: four!
 * ```
 *
 * @see {@link onErrorResumeNext}
 * @see {@link repeat}
 * @see {@link repeatWhen}
 * @see {@link retry }
 * @see {@link retryWhen}
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 * is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 * is returned by the `selector` will be used to continue the observable chain.
 * @return A function that returns an Observable that originates from either
 * the source or the Observable returned by the `selector` function.
 */
export function catchError(selector) {
    return operate((source, subscriber) => {
        let innerSub = null;
        let syncUnsub = false;
        let handledResult;
        innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, (err) => {
            handledResult = innerFrom(selector(err, catchError(selector)(source)));
            if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                handledResult.subscribe(subscriber);
            }
            else {
                // We don't have an innerSub yet, that means the error was synchronous
                // because the subscribe call hasn't returned yet.
                syncUnsub = true;
            }
        }));
        if (syncUnsub) {
            // We have a synchronous error, we need to make sure to
            // finalize right away. This ensures that callbacks in the `finalize` operator are called
            // at the right time, and that finalization occurs at the expected
            // time between the source error and the subscription to the
            // next observable.
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
        }
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvY2F0Y2hFcnJvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDaEUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQU12QyxtQ0FBbUM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EyRkc7QUFDSCxNQUFNLFVBQVUsVUFBVSxDQUN4QixRQUFnRDtJQUVoRCxPQUFPLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTtRQUNwQyxJQUFJLFFBQVEsR0FBd0IsSUFBSSxDQUFDO1FBQ3pDLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLGFBQTZDLENBQUM7UUFFbEQsUUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQ3pCLHdCQUF3QixDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDakUsYUFBYSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkUsSUFBSSxRQUFRLEVBQUUsQ0FBQztnQkFDYixRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQ3ZCLFFBQVEsR0FBRyxJQUFJLENBQUM7Z0JBQ2hCLGFBQWEsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEMsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLHNFQUFzRTtnQkFDdEUsa0RBQWtEO2dCQUNsRCxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ25CLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FDSCxDQUFDO1FBRUYsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUNkLHVEQUF1RDtZQUN2RCx5RkFBeUY7WUFDekYsa0VBQWtFO1lBQ2xFLDREQUE0RDtZQUM1RCxtQkFBbUI7WUFDbkIsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ3ZCLFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDaEIsYUFBYyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN2QyxDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvY2F0Y2hFcnJvci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcblxuaW1wb3J0IHsgT2JzZXJ2YWJsZUlucHV0LCBPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZlZFZhbHVlT2YgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhdGNoRXJyb3I8VCwgTyBleHRlbmRzIE9ic2VydmFibGVJbnB1dDxhbnk+PihcbiAgc2VsZWN0b3I6IChlcnI6IGFueSwgY2F1Z2h0OiBPYnNlcnZhYmxlPFQ+KSA9PiBPXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBPYnNlcnZlZFZhbHVlT2Y8Tz4+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBDYXRjaGVzIGVycm9ycyBvbiB0aGUgb2JzZXJ2YWJsZSB0byBiZSBoYW5kbGVkIGJ5IHJldHVybmluZyBhIG5ldyBvYnNlcnZhYmxlIG9yIHRocm93aW5nIGFuIGVycm9yLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5cbiAqIEl0IG9ubHkgbGlzdGVucyB0byB0aGUgZXJyb3IgY2hhbm5lbCBhbmQgaWdub3JlcyBub3RpZmljYXRpb25zLlxuICogSGFuZGxlcyBlcnJvcnMgZnJvbSB0aGUgc291cmNlIG9ic2VydmFibGUsIGFuZCBtYXBzIHRoZW0gdG8gYSBuZXcgb2JzZXJ2YWJsZS5cbiAqIFRoZSBlcnJvciBtYXkgYWxzbyBiZSByZXRocm93biwgb3IgYSBuZXcgZXJyb3IgY2FuIGJlIHRocm93biB0byBlbWl0IGFuIGVycm9yIGZyb20gdGhlIHJlc3VsdC5cbiAqIDwvc3Bhbj5cbiAqXG4gKiAhW10oY2F0Y2gucG5nKVxuICpcbiAqIFRoaXMgb3BlcmF0b3IgaGFuZGxlcyBlcnJvcnMsIGJ1dCBmb3J3YXJkcyBhbG9uZyBhbGwgb3RoZXIgZXZlbnRzIHRvIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZS5cbiAqIElmIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSB0ZXJtaW5hdGVzIHdpdGggYW4gZXJyb3IsIGl0IHdpbGwgbWFwIHRoYXQgZXJyb3IgdG8gYSBuZXcgb2JzZXJ2YWJsZSxcbiAqIHN1YnNjcmliZSB0byBpdCwgYW5kIGZvcndhcmQgYWxsIG9mIGl0cyBldmVudHMgdG8gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlLlxuICpcbiAqICMjIEV4YW1wbGVzXG4gKlxuICogQ29udGludWUgd2l0aCBhIGRpZmZlcmVudCBPYnNlcnZhYmxlIHdoZW4gdGhlcmUncyBhbiBlcnJvclxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBvZiwgbWFwLCBjYXRjaEVycm9yIH0gZnJvbSAncnhqcyc7XG4gKlxuICogb2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLnBpcGUoXG4gKiAgICAgbWFwKG4gPT4ge1xuICogICAgICAgaWYgKG4gPT09IDQpIHtcbiAqICAgICAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICAgIH1cbiAqICAgICAgIHJldHVybiBuO1xuICogICAgIH0pLFxuICogICAgIGNhdGNoRXJyb3IoZXJyID0+IG9mKCdJJywgJ0lJJywgJ0lJSScsICdJVicsICdWJykpXG4gKiAgIClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqICAgLy8gMSwgMiwgMywgSSwgSUksIElJSSwgSVYsIFZcbiAqIGBgYFxuICpcbiAqIFJldHJ5IHRoZSBjYXVnaHQgc291cmNlIE9ic2VydmFibGUgYWdhaW4gaW4gY2FzZSBvZiBlcnJvciwgc2ltaWxhciB0byBgcmV0cnkoKWAgb3BlcmF0b3JcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgb2YsIG1hcCwgY2F0Y2hFcnJvciwgdGFrZSB9IGZyb20gJ3J4anMnO1xuICpcbiAqIG9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5waXBlKFxuICogICAgIG1hcChuID0+IHtcbiAqICAgICAgIGlmIChuID09PSA0KSB7XG4gKiAgICAgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4gbjtcbiAqICAgICB9KSxcbiAqICAgICBjYXRjaEVycm9yKChlcnIsIGNhdWdodCkgPT4gY2F1Z2h0KSxcbiAqICAgICB0YWtlKDMwKVxuICogICApXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiAgIC8vIDEsIDIsIDMsIDEsIDIsIDMsIC4uLlxuICogYGBgXG4gKlxuICogVGhyb3cgYSBuZXcgZXJyb3Igd2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgdGhyb3dzIGFuIGVycm9yXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mLCBtYXAsIGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBvZigxLCAyLCAzLCA0LCA1KVxuICogICAucGlwZShcbiAqICAgICBtYXAobiA9PiB7XG4gKiAgICAgICBpZiAobiA9PT0gNCkge1xuICogICAgICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgICAgfVxuICogICAgICAgcmV0dXJuIG47XG4gKiAgICAgfSksXG4gKiAgICAgY2F0Y2hFcnJvcihlcnIgPT4ge1xuICogICAgICAgdGhyb3cgJ2Vycm9yIGluIHNvdXJjZS4gRGV0YWlsczogJyArIGVycjtcbiAqICAgICB9KVxuICogICApXG4gKiAgIC5zdWJzY3JpYmUoe1xuICogICAgIG5leHQ6IHggPT4gY29uc29sZS5sb2coeCksXG4gKiAgICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmxvZyhlcnIpXG4gKiAgIH0pO1xuICogICAvLyAxLCAyLCAzLCBlcnJvciBpbiBzb3VyY2UuIERldGFpbHM6IGZvdXIhXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBvbkVycm9yUmVzdW1lTmV4dH1cbiAqIEBzZWUge0BsaW5rIHJlcGVhdH1cbiAqIEBzZWUge0BsaW5rIHJlcGVhdFdoZW59XG4gKiBAc2VlIHtAbGluayByZXRyeSB9XG4gKiBAc2VlIHtAbGluayByZXRyeVdoZW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc2VsZWN0b3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFzIGFyZ3VtZW50cyBgZXJyYCwgd2hpY2ggaXMgdGhlIGVycm9yLCBhbmQgYGNhdWdodGAsIHdoaWNoXG4gKiBpcyB0aGUgc291cmNlIG9ic2VydmFibGUsIGluIGNhc2UgeW91J2QgbGlrZSB0byBcInJldHJ5XCIgdGhhdCBvYnNlcnZhYmxlIGJ5IHJldHVybmluZyBpdCBhZ2Fpbi4gV2hhdGV2ZXIgb2JzZXJ2YWJsZVxuICogaXMgcmV0dXJuZWQgYnkgdGhlIGBzZWxlY3RvcmAgd2lsbCBiZSB1c2VkIHRvIGNvbnRpbnVlIHRoZSBvYnNlcnZhYmxlIGNoYWluLlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgb3JpZ2luYXRlcyBmcm9tIGVpdGhlclxuICogdGhlIHNvdXJjZSBvciB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBieSB0aGUgYHNlbGVjdG9yYCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhdGNoRXJyb3I8VCwgTyBleHRlbmRzIE9ic2VydmFibGVJbnB1dDxhbnk+PihcbiAgc2VsZWN0b3I6IChlcnI6IGFueSwgY2F1Z2h0OiBPYnNlcnZhYmxlPFQ+KSA9PiBPXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBPYnNlcnZlZFZhbHVlT2Y8Tz4+IHtcbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIGxldCBpbm5lclN1YjogU3Vic2NyaXB0aW9uIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHN5bmNVbnN1YiA9IGZhbHNlO1xuICAgIGxldCBoYW5kbGVkUmVzdWx0OiBPYnNlcnZhYmxlPE9ic2VydmVkVmFsdWVPZjxPPj47XG5cbiAgICBpbm5lclN1YiA9IHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlZFJlc3VsdCA9IGlubmVyRnJvbShzZWxlY3RvcihlcnIsIGNhdGNoRXJyb3Ioc2VsZWN0b3IpKHNvdXJjZSkpKTtcbiAgICAgICAgaWYgKGlubmVyU3ViKSB7XG4gICAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBpbm5lclN1YiA9IG51bGw7XG4gICAgICAgICAgaGFuZGxlZFJlc3VsdC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbiBpbm5lclN1YiB5ZXQsIHRoYXQgbWVhbnMgdGhlIGVycm9yIHdhcyBzeW5jaHJvbm91c1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHN1YnNjcmliZSBjYWxsIGhhc24ndCByZXR1cm5lZCB5ZXQuXG4gICAgICAgICAgc3luY1Vuc3ViID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgaWYgKHN5bmNVbnN1Yikge1xuICAgICAgLy8gV2UgaGF2ZSBhIHN5bmNocm9ub3VzIGVycm9yLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0b1xuICAgICAgLy8gZmluYWxpemUgcmlnaHQgYXdheS4gVGhpcyBlbnN1cmVzIHRoYXQgY2FsbGJhY2tzIGluIHRoZSBgZmluYWxpemVgIG9wZXJhdG9yIGFyZSBjYWxsZWRcbiAgICAgIC8vIGF0IHRoZSByaWdodCB0aW1lLCBhbmQgdGhhdCBmaW5hbGl6YXRpb24gb2NjdXJzIGF0IHRoZSBleHBlY3RlZFxuICAgICAgLy8gdGltZSBiZXR3ZWVuIHRoZSBzb3VyY2UgZXJyb3IgYW5kIHRoZSBzdWJzY3JpcHRpb24gdG8gdGhlXG4gICAgICAvLyBuZXh0IG9ic2VydmFibGUuXG4gICAgICBpbm5lclN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgaW5uZXJTdWIgPSBudWxsO1xuICAgICAgaGFuZGxlZFJlc3VsdCEuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH1cbiAgfSk7XG59XG4iXX0=
