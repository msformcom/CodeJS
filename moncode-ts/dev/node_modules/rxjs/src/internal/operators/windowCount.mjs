import { Subject } from '../Subject.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Branch out the source Observable values as a nested Observable with each
 * nested Observable emitting at most `windowSize` values.
 *
 * <span class="informal">It's like {@link bufferCount}, but emits a nested
 * Observable instead of an array.</span>
 *
 * ![](windowCount.png)
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows every `startWindowEvery`
 * items, each containing no more than `windowSize` items. When the source
 * Observable completes or encounters an error, the output Observable emits
 * the current window and propagates the notification from the source
 * Observable. If `startWindowEvery` is not provided, then new windows are
 * started immediately at the start of the source and when each window completes
 * with size `windowSize`.
 *
 * ## Examples
 *
 * Ignore every 3rd click event, starting from the first one
 *
 * ```ts
 * import { fromEvent, windowCount, map, skip, mergeAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(
 *   windowCount(3),
 *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks
 *   mergeAll()                     // flatten the Observable-of-Observables
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * Ignore every 3rd click event, starting from the third one
 *
 * ```ts
 * import { fromEvent, windowCount, mergeAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(
 *   windowCount(2, 3),
 *   mergeAll() // flatten the Observable-of-Observables
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link window}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferCount}
 *
 * @param {number} windowSize The maximum number of values emitted by each
 * window.
 * @param {number} [startWindowEvery] Interval at which to start a new window.
 * For example if `startWindowEvery` is `2`, then a new window will be started
 * on every other value from the source. A new window is started at the
 * beginning of the source by default.
 * @return A function that returns an Observable of windows, which in turn are
 * Observable of values.
 */
export function windowCount(windowSize, startWindowEvery = 0) {
    const startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return operate((source, subscriber) => {
        let windows = [new Subject()];
        let starts = [];
        let count = 0;
        // Open the first window.
        subscriber.next(windows[0].asObservable());
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            // Emit the value through all current windows.
            // We don't need to create a new window yet, we
            // do that as soon as we close one.
            for (const window of windows) {
                window.next(value);
            }
            // Here we're using the size of the window array to figure
            // out if the oldest window has emitted enough values. We can do this
            // because the size of the window array is a function of the values
            // seen by the subscription. If it's time to close it, we complete
            // it and remove it.
            const c = count - windowSize + 1;
            if (c >= 0 && c % startEvery === 0) {
                windows.shift().complete();
            }
            // Look to see if the next count tells us it's time to open a new window.
            // TODO: We need to figure out if this really makes sense. We're technically
            // emitting windows *before* we have a value to emit them for. It's probably
            // more expected that we should be emitting the window when the start
            // count is reached -- not before.
            if (++count % startEvery === 0) {
                const window = new Subject();
                windows.push(window);
                subscriber.next(window.asObservable());
            }
        }, () => {
            while (windows.length > 0) {
                windows.shift().complete();
            }
            subscriber.complete();
        }, (err) => {
            while (windows.length > 0) {
                windows.shift().error(err);
            }
            subscriber.error(err);
        }, () => {
            starts = null;
            windows = null;
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93Q291bnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFlBQVksQ0FBQztBQUVyQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRWhFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkRHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBSSxVQUFrQixFQUFFLG1CQUEyQixDQUFDO0lBQzdFLE1BQU0sVUFBVSxHQUFHLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUV4RSxPQUFPLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTtRQUNwQyxJQUFJLE9BQU8sR0FBRyxDQUFDLElBQUksT0FBTyxFQUFLLENBQUMsQ0FBQztRQUNqQyxJQUFJLE1BQU0sR0FBYSxFQUFFLENBQUM7UUFDMUIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBRWQseUJBQXlCO1FBQ3pCLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7UUFFM0MsTUFBTSxDQUFDLFNBQVMsQ0FDZCx3QkFBd0IsQ0FDdEIsVUFBVSxFQUNWLENBQUMsS0FBUSxFQUFFLEVBQUU7WUFDWCw4Q0FBOEM7WUFDOUMsK0NBQStDO1lBQy9DLG1DQUFtQztZQUNuQyxLQUFLLE1BQU0sTUFBTSxJQUFJLE9BQU8sRUFBRSxDQUFDO2dCQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JCLENBQUM7WUFDRCwwREFBMEQ7WUFDMUQscUVBQXFFO1lBQ3JFLG1FQUFtRTtZQUNuRSxrRUFBa0U7WUFDbEUsb0JBQW9CO1lBQ3BCLE1BQU0sQ0FBQyxHQUFHLEtBQUssR0FBRyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUNuQyxPQUFPLENBQUMsS0FBSyxFQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDOUIsQ0FBQztZQUVELHlFQUF5RTtZQUN6RSw0RUFBNEU7WUFDNUUsNEVBQTRFO1lBQzVFLHFFQUFxRTtZQUNyRSxrQ0FBa0M7WUFDbEMsSUFBSSxFQUFFLEtBQUssR0FBRyxVQUFVLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQy9CLE1BQU0sTUFBTSxHQUFHLElBQUksT0FBTyxFQUFLLENBQUM7Z0JBQ2hDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3JCLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7WUFDekMsQ0FBQztRQUNILENBQUMsRUFDRCxHQUFHLEVBQUU7WUFDSCxPQUFPLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0JBQzFCLE9BQU8sQ0FBQyxLQUFLLEVBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUM5QixDQUFDO1lBQ0QsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3hCLENBQUMsRUFDRCxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQ04sT0FBTyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUMxQixPQUFPLENBQUMsS0FBSyxFQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzlCLENBQUM7WUFDRCxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLENBQUMsRUFDRCxHQUFHLEVBQUU7WUFDSCxNQUFNLEdBQUcsSUFBSyxDQUFDO1lBQ2YsT0FBTyxHQUFHLElBQUssQ0FBQztRQUNsQixDQUFDLENBQ0YsQ0FDRixDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93Q291bnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAnLi4vU3ViamVjdCc7XG5pbXBvcnQgeyBPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5cbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgd2l0aCBlYWNoXG4gKiBuZXN0ZWQgT2JzZXJ2YWJsZSBlbWl0dGluZyBhdCBtb3N0IGB3aW5kb3dTaXplYCB2YWx1ZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyQ291bnR9LCBidXQgZW1pdHMgYSBuZXN0ZWRcbiAqIE9ic2VydmFibGUgaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogIVtdKHdpbmRvd0NvdW50LnBuZylcbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aW5kb3dzIG9mIGl0ZW1zIGl0IGNvbGxlY3RzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIHdpbmRvd3MgZXZlcnkgYHN0YXJ0V2luZG93RXZlcnlgXG4gKiBpdGVtcywgZWFjaCBjb250YWluaW5nIG5vIG1vcmUgdGhhbiBgd2luZG93U2l6ZWAgaXRlbXMuIFdoZW4gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBjb21wbGV0ZXMgb3IgZW5jb3VudGVycyBhbiBlcnJvciwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzXG4gKiB0aGUgY3VycmVudCB3aW5kb3cgYW5kIHByb3BhZ2F0ZXMgdGhlIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIElmIGBzdGFydFdpbmRvd0V2ZXJ5YCBpcyBub3QgcHJvdmlkZWQsIHRoZW4gbmV3IHdpbmRvd3MgYXJlXG4gKiBzdGFydGVkIGltbWVkaWF0ZWx5IGF0IHRoZSBzdGFydCBvZiB0aGUgc291cmNlIGFuZCB3aGVuIGVhY2ggd2luZG93IGNvbXBsZXRlc1xuICogd2l0aCBzaXplIGB3aW5kb3dTaXplYC5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIElnbm9yZSBldmVyeSAzcmQgY2xpY2sgZXZlbnQsIHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0IG9uZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIHdpbmRvd0NvdW50LCBtYXAsIHNraXAsIG1lcmdlQWxsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGNsaWNrcy5waXBlKFxuICogICB3aW5kb3dDb3VudCgzKSxcbiAqICAgbWFwKHdpbiA9PiB3aW4ucGlwZShza2lwKDEpKSksIC8vIHNraXAgZmlyc3Qgb2YgZXZlcnkgMyBjbGlja3NcbiAqICAgbWVyZ2VBbGwoKSAgICAgICAgICAgICAgICAgICAgIC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqICk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogYGBgXG4gKlxuICogSWdub3JlIGV2ZXJ5IDNyZCBjbGljayBldmVudCwgc3RhcnRpbmcgZnJvbSB0aGUgdGhpcmQgb25lXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21FdmVudCwgd2luZG93Q291bnQsIG1lcmdlQWxsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGNsaWNrcy5waXBlKFxuICogICB3aW5kb3dDb3VudCgyLCAzKSxcbiAqICAgbWVyZ2VBbGwoKSAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpbmRvd1NpemUgVGhlIG1heGltdW0gbnVtYmVyIG9mIHZhbHVlcyBlbWl0dGVkIGJ5IGVhY2hcbiAqIHdpbmRvdy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRXaW5kb3dFdmVyeV0gSW50ZXJ2YWwgYXQgd2hpY2ggdG8gc3RhcnQgYSBuZXcgd2luZG93LlxuICogRm9yIGV4YW1wbGUgaWYgYHN0YXJ0V2luZG93RXZlcnlgIGlzIGAyYCwgdGhlbiBhIG5ldyB3aW5kb3cgd2lsbCBiZSBzdGFydGVkXG4gKiBvbiBldmVyeSBvdGhlciB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UuIEEgbmV3IHdpbmRvdyBpcyBzdGFydGVkIGF0IHRoZVxuICogYmVnaW5uaW5nIG9mIHRoZSBzb3VyY2UgYnkgZGVmYXVsdC5cbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSBvZiB3aW5kb3dzLCB3aGljaCBpbiB0dXJuIGFyZVxuICogT2JzZXJ2YWJsZSBvZiB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aW5kb3dDb3VudDxUPih3aW5kb3dTaXplOiBudW1iZXIsIHN0YXJ0V2luZG93RXZlcnk6IG51bWJlciA9IDApOiBPcGVyYXRvckZ1bmN0aW9uPFQsIE9ic2VydmFibGU8VD4+IHtcbiAgY29uc3Qgc3RhcnRFdmVyeSA9IHN0YXJ0V2luZG93RXZlcnkgPiAwID8gc3RhcnRXaW5kb3dFdmVyeSA6IHdpbmRvd1NpemU7XG5cbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIGxldCB3aW5kb3dzID0gW25ldyBTdWJqZWN0PFQ+KCldO1xuICAgIGxldCBzdGFydHM6IG51bWJlcltdID0gW107XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIC8vIE9wZW4gdGhlIGZpcnN0IHdpbmRvdy5cbiAgICBzdWJzY3JpYmVyLm5leHQod2luZG93c1swXS5hc09ic2VydmFibGUoKSk7XG5cbiAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAodmFsdWU6IFQpID0+IHtcbiAgICAgICAgICAvLyBFbWl0IHRoZSB2YWx1ZSB0aHJvdWdoIGFsbCBjdXJyZW50IHdpbmRvd3MuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYSBuZXcgd2luZG93IHlldCwgd2VcbiAgICAgICAgICAvLyBkbyB0aGF0IGFzIHNvb24gYXMgd2UgY2xvc2Ugb25lLlxuICAgICAgICAgIGZvciAoY29uc3Qgd2luZG93IG9mIHdpbmRvd3MpIHtcbiAgICAgICAgICAgIHdpbmRvdy5uZXh0KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSGVyZSB3ZSdyZSB1c2luZyB0aGUgc2l6ZSBvZiB0aGUgd2luZG93IGFycmF5IHRvIGZpZ3VyZVxuICAgICAgICAgIC8vIG91dCBpZiB0aGUgb2xkZXN0IHdpbmRvdyBoYXMgZW1pdHRlZCBlbm91Z2ggdmFsdWVzLiBXZSBjYW4gZG8gdGhpc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHNpemUgb2YgdGhlIHdpbmRvdyBhcnJheSBpcyBhIGZ1bmN0aW9uIG9mIHRoZSB2YWx1ZXNcbiAgICAgICAgICAvLyBzZWVuIGJ5IHRoZSBzdWJzY3JpcHRpb24uIElmIGl0J3MgdGltZSB0byBjbG9zZSBpdCwgd2UgY29tcGxldGVcbiAgICAgICAgICAvLyBpdCBhbmQgcmVtb3ZlIGl0LlxuICAgICAgICAgIGNvbnN0IGMgPSBjb3VudCAtIHdpbmRvd1NpemUgKyAxO1xuICAgICAgICAgIGlmIChjID49IDAgJiYgYyAlIHN0YXJ0RXZlcnkgPT09IDApIHtcbiAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKSEuY29tcGxldGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBMb29rIHRvIHNlZSBpZiB0aGUgbmV4dCBjb3VudCB0ZWxscyB1cyBpdCdzIHRpbWUgdG8gb3BlbiBhIG5ldyB3aW5kb3cuXG4gICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgcmVhbGx5IG1ha2VzIHNlbnNlLiBXZSdyZSB0ZWNobmljYWxseVxuICAgICAgICAgIC8vIGVtaXR0aW5nIHdpbmRvd3MgKmJlZm9yZSogd2UgaGF2ZSBhIHZhbHVlIHRvIGVtaXQgdGhlbSBmb3IuIEl0J3MgcHJvYmFibHlcbiAgICAgICAgICAvLyBtb3JlIGV4cGVjdGVkIHRoYXQgd2Ugc2hvdWxkIGJlIGVtaXR0aW5nIHRoZSB3aW5kb3cgd2hlbiB0aGUgc3RhcnRcbiAgICAgICAgICAvLyBjb3VudCBpcyByZWFjaGVkIC0tIG5vdCBiZWZvcmUuXG4gICAgICAgICAgaWYgKCsrY291bnQgJSBzdGFydEV2ZXJ5ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCB3aW5kb3cgPSBuZXcgU3ViamVjdDxUPigpO1xuICAgICAgICAgICAgd2luZG93cy5wdXNoKHdpbmRvdyk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQod2luZG93LmFzT2JzZXJ2YWJsZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB3aGlsZSAod2luZG93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkhLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKSEuZXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RhcnRzID0gbnVsbCE7XG4gICAgICAgICAgd2luZG93cyA9IG51bGwhO1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSk7XG59XG4iXX0=
