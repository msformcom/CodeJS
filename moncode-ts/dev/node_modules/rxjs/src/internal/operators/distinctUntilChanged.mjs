import { identity } from '../util/identity.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Returns a result {@link Observable} that emits all values pushed by the source observable if they
 * are distinct in comparison to the last value the result observable emitted.
 *
 * When provided without parameters or with the first parameter (`{@link distinctUntilChanged#comparator comparator}`),
 * it behaves like this:
 *
 * 1. It will always emit the first value from the source.
 * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values
 *    using the provided `comparator` or an `===` equality check.
 * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and
 *    becomes the new "previously emitted value" internally.
 *
 * When the second parameter (`{@link distinctUntilChanged#keySelector keySelector}`) is provided, the behavior
 * changes:
 *
 * 1. It will always emit the first value from the source.
 * 2. The `keySelector` will be run against all values, including the first value.
 * 3. For all values after the first, the selected key will be compared against the key selected from
 *    the previously emitted value using the `comparator`.
 * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted
 *    and the selected key from that value is saved for future comparisons against other keys.
 *
 * ## Examples
 *
 * A very basic example with no `{@link distinctUntilChanged#comparator comparator}`. Note that `1` is emitted more than once,
 * because it's distinct in comparison to the _previously emitted_ value,
 * not in comparison to _all other emitted values_.
 *
 * ```ts
 * import { of, distinctUntilChanged } from 'rxjs';
 *
 * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3)
 *   .pipe(distinctUntilChanged())
 *   .subscribe(console.log);
 * // Logs: 1, 2, 1, 3
 * ```
 *
 * With a `{@link distinctUntilChanged#comparator comparator}`, you can do custom comparisons. Let's say
 * you only want to emit a value when all of its components have
 * changed:
 *
 * ```ts
 * import { of, distinctUntilChanged } from 'rxjs';
 *
 * const totallyDifferentBuilds$ = of(
 *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },
 *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },
 *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },
 *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },
 *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }
 * ).pipe(
 *   distinctUntilChanged((prev, curr) => {
 *     return (
 *       prev.engineVersion === curr.engineVersion ||
 *       prev.transmissionVersion === curr.transmissionVersion
 *     );
 *   })
 * );
 *
 * totallyDifferentBuilds$.subscribe(console.log);
 *
 * // Logs:
 * // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }
 * // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }
 * // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }
 * ```
 *
 * You can also provide a custom `{@link distinctUntilChanged#comparator comparator}` to check that emitted
 * changes are only in one direction. Let's say you only want to get
 * the next record temperature:
 *
 * ```ts
 * import { of, distinctUntilChanged } from 'rxjs';
 *
 * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);
 *
 * const recordHighs$ = temps$.pipe(
 *   distinctUntilChanged((prevHigh, temp) => {
 *     // If the current temp is less than
 *     // or the same as the previous record,
 *     // the record hasn't changed.
 *     return temp <= prevHigh;
 *   })
 * );
 *
 * recordHighs$.subscribe(console.log);
 * // Logs: 30, 31, 34, 35
 * ```
 *
 * Selecting update events only when the `updatedBy` field shows
 * the account changed hands.
 *
 * ```ts
 * import { of, distinctUntilChanged } from 'rxjs';
 *
 * // A stream of updates to a given account
 * const accountUpdates$ = of(
 *   { updatedBy: 'blesh', data: [] },
 *   { updatedBy: 'blesh', data: [] },
 *   { updatedBy: 'ncjamieson', data: [] },
 *   { updatedBy: 'ncjamieson', data: [] },
 *   { updatedBy: 'blesh', data: [] }
 * );
 *
 * // We only want the events where it changed hands
 * const changedHands$ = accountUpdates$.pipe(
 *   distinctUntilChanged(undefined, update => update.updatedBy)
 * );
 *
 * changedHands$.subscribe(console.log);
 * // Logs:
 * // { updatedBy: 'blesh', data: Array[0] }
 * // { updatedBy: 'ncjamieson', data: Array[0] }
 * // { updatedBy: 'blesh', data: Array[0] }
 * ```
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param comparator A function used to compare the previous and current keys for
 * equality. Defaults to a `===` check.
 * @param keySelector Used to select a key value to be passed to the `comparator`.
 *
 * @return A function that returns an Observable that emits items from the
 * source Observable with distinct values.
 */
export function distinctUntilChanged(comparator, keySelector = identity) {
    // We've been allowing `null` do be passed as the `compare`, so we can't do
    // a default value for the parameter, because that will only work
    // for `undefined`.
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return operate((source, subscriber) => {
        // The previous key, used to compare against keys selected
        // from new arrivals to determine "distinctiveness".
        let previousKey;
        // Whether or not this is the first value we've gotten.
        let first = true;
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            // We always call the key selector.
            const currentKey = keySelector(value);
            // If it's the first value, we always emit it.
            // Otherwise, we compare this key to the previous key, and
            // if the comparer returns false, we emit.
            if (first || !comparator(previousKey, currentKey)) {
                // Update our state *before* we emit the value
                // as emission can be the source of re-entrant code
                // in functional libraries like this. We only really
                // need to do this if it's the first value, or if the
                // key we're tracking in previous needs to change.
                first = false;
                previousKey = currentKey;
                // Emit the value!
                subscriber.next(value);
            }
        }));
    });
}
function defaultCompare(a, b) {
    return a === b;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvZGlzdGluY3RVbnRpbENoYW5nZWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFRaEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQThIRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FDbEMsVUFBaUQsRUFDakQsY0FBK0IsUUFBMkI7SUFFMUQsMkVBQTJFO0lBQzNFLGlFQUFpRTtJQUNqRSxtQkFBbUI7SUFDbkIsVUFBVSxHQUFHLFVBQVUsYUFBVixVQUFVLGNBQVYsVUFBVSxHQUFJLGNBQWMsQ0FBQztJQUUxQyxPQUFPLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTtRQUNwQywwREFBMEQ7UUFDMUQsb0RBQW9EO1FBQ3BELElBQUksV0FBYyxDQUFDO1FBQ25CLHVEQUF1RDtRQUN2RCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUM7UUFFakIsTUFBTSxDQUFDLFNBQVMsQ0FDZCx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUM3QyxtQ0FBbUM7WUFDbkMsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRXRDLDhDQUE4QztZQUM5QywwREFBMEQ7WUFDMUQsMENBQTBDO1lBQzFDLElBQUksS0FBSyxJQUFJLENBQUMsVUFBVyxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsRUFBRSxDQUFDO2dCQUNuRCw4Q0FBOEM7Z0JBQzlDLG1EQUFtRDtnQkFDbkQsb0RBQW9EO2dCQUNwRCxxREFBcUQ7Z0JBQ3JELGtEQUFrRDtnQkFDbEQsS0FBSyxHQUFHLEtBQUssQ0FBQztnQkFDZCxXQUFXLEdBQUcsVUFBVSxDQUFDO2dCQUV6QixrQkFBa0I7Z0JBQ2xCLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDekIsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxDQUFNLEVBQUUsQ0FBTTtJQUNwQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakIsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxDaGFuZ2VkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICcuLi91dGlsL2lkZW50aXR5JztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGluY3RVbnRpbENoYW5nZWQ8VD4oY29tcGFyYXRvcj86IChwcmV2aW91czogVCwgY3VycmVudDogVCkgPT4gYm9vbGVhbik6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPjtcbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZDxULCBLPihcbiAgY29tcGFyYXRvcjogKHByZXZpb3VzOiBLLCBjdXJyZW50OiBLKSA9PiBib29sZWFuLFxuICBrZXlTZWxlY3RvcjogKHZhbHVlOiBUKSA9PiBLXG4pOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD47XG5cbi8qKlxuICogUmV0dXJucyBhIHJlc3VsdCB7QGxpbmsgT2JzZXJ2YWJsZX0gdGhhdCBlbWl0cyBhbGwgdmFsdWVzIHB1c2hlZCBieSB0aGUgc291cmNlIG9ic2VydmFibGUgaWYgdGhleVxuICogYXJlIGRpc3RpbmN0IGluIGNvbXBhcmlzb24gdG8gdGhlIGxhc3QgdmFsdWUgdGhlIHJlc3VsdCBvYnNlcnZhYmxlIGVtaXR0ZWQuXG4gKlxuICogV2hlbiBwcm92aWRlZCB3aXRob3V0IHBhcmFtZXRlcnMgb3Igd2l0aCB0aGUgZmlyc3QgcGFyYW1ldGVyIChge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkI2NvbXBhcmF0b3IgY29tcGFyYXRvcn1gKSxcbiAqIGl0IGJlaGF2ZXMgbGlrZSB0aGlzOlxuICpcbiAqIDEuIEl0IHdpbGwgYWx3YXlzIGVtaXQgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIHNvdXJjZS5cbiAqIDIuIEZvciBhbGwgc3Vic2VxdWVudCB2YWx1ZXMgcHVzaGVkIGJ5IHRoZSBzb3VyY2UsIHRoZXkgd2lsbCBiZSBjb21wYXJlZCB0byB0aGUgcHJldmlvdXNseSBlbWl0dGVkIHZhbHVlc1xuICogICAgdXNpbmcgdGhlIHByb3ZpZGVkIGBjb21wYXJhdG9yYCBvciBhbiBgPT09YCBlcXVhbGl0eSBjaGVjay5cbiAqIDMuIElmIHRoZSB2YWx1ZSBwdXNoZWQgYnkgdGhlIHNvdXJjZSBpcyBkZXRlcm1pbmVkIHRvIGJlIHVuZXF1YWwgYnkgdGhpcyBjaGVjaywgdGhhdCB2YWx1ZSBpcyBlbWl0dGVkIGFuZFxuICogICAgYmVjb21lcyB0aGUgbmV3IFwicHJldmlvdXNseSBlbWl0dGVkIHZhbHVlXCIgaW50ZXJuYWxseS5cbiAqXG4gKiBXaGVuIHRoZSBzZWNvbmQgcGFyYW1ldGVyIChge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkI2tleVNlbGVjdG9yIGtleVNlbGVjdG9yfWApIGlzIHByb3ZpZGVkLCB0aGUgYmVoYXZpb3JcbiAqIGNoYW5nZXM6XG4gKlxuICogMS4gSXQgd2lsbCBhbHdheXMgZW1pdCB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgc291cmNlLlxuICogMi4gVGhlIGBrZXlTZWxlY3RvcmAgd2lsbCBiZSBydW4gYWdhaW5zdCBhbGwgdmFsdWVzLCBpbmNsdWRpbmcgdGhlIGZpcnN0IHZhbHVlLlxuICogMy4gRm9yIGFsbCB2YWx1ZXMgYWZ0ZXIgdGhlIGZpcnN0LCB0aGUgc2VsZWN0ZWQga2V5IHdpbGwgYmUgY29tcGFyZWQgYWdhaW5zdCB0aGUga2V5IHNlbGVjdGVkIGZyb21cbiAqICAgIHRoZSBwcmV2aW91c2x5IGVtaXR0ZWQgdmFsdWUgdXNpbmcgdGhlIGBjb21wYXJhdG9yYC5cbiAqIDQuIElmIHRoZSBrZXlzIGFyZSBkZXRlcm1pbmVkIHRvIGJlIHVuZXF1YWwgYnkgdGhpcyBjaGVjaywgdGhlIHZhbHVlIChub3QgdGhlIGtleSksIGlzIGVtaXR0ZWRcbiAqICAgIGFuZCB0aGUgc2VsZWN0ZWQga2V5IGZyb20gdGhhdCB2YWx1ZSBpcyBzYXZlZCBmb3IgZnV0dXJlIGNvbXBhcmlzb25zIGFnYWluc3Qgb3RoZXIga2V5cy5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIEEgdmVyeSBiYXNpYyBleGFtcGxlIHdpdGggbm8gYHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZCNjb21wYXJhdG9yIGNvbXBhcmF0b3J9YC4gTm90ZSB0aGF0IGAxYCBpcyBlbWl0dGVkIG1vcmUgdGhhbiBvbmNlLFxuICogYmVjYXVzZSBpdCdzIGRpc3RpbmN0IGluIGNvbXBhcmlzb24gdG8gdGhlIF9wcmV2aW91c2x5IGVtaXR0ZWRfIHZhbHVlLFxuICogbm90IGluIGNvbXBhcmlzb24gdG8gX2FsbCBvdGhlciBlbWl0dGVkIHZhbHVlc18uXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIG9mKDEsIDEsIDEsIDIsIDIsIDIsIDEsIDEsIDMsIDMpXG4gKiAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpXG4gKiAgIC5zdWJzY3JpYmUoY29uc29sZS5sb2cpO1xuICogLy8gTG9nczogMSwgMiwgMSwgM1xuICogYGBgXG4gKlxuICogV2l0aCBhIGB7QGxpbmsgZGlzdGluY3RVbnRpbENoYW5nZWQjY29tcGFyYXRvciBjb21wYXJhdG9yfWAsIHlvdSBjYW4gZG8gY3VzdG9tIGNvbXBhcmlzb25zLiBMZXQncyBzYXlcbiAqIHlvdSBvbmx5IHdhbnQgdG8gZW1pdCBhIHZhbHVlIHdoZW4gYWxsIG9mIGl0cyBjb21wb25lbnRzIGhhdmVcbiAqIGNoYW5nZWQ6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IHRvdGFsbHlEaWZmZXJlbnRCdWlsZHMkID0gb2YoXG4gKiAgIHsgZW5naW5lVmVyc2lvbjogJzEuMS4wJywgdHJhbnNtaXNzaW9uVmVyc2lvbjogJzEuMi4wJyB9LFxuICogICB7IGVuZ2luZVZlcnNpb246ICcxLjEuMCcsIHRyYW5zbWlzc2lvblZlcnNpb246ICcxLjQuMCcgfSxcbiAqICAgeyBlbmdpbmVWZXJzaW9uOiAnMS4zLjAnLCB0cmFuc21pc3Npb25WZXJzaW9uOiAnMS40LjAnIH0sXG4gKiAgIHsgZW5naW5lVmVyc2lvbjogJzEuMy4wJywgdHJhbnNtaXNzaW9uVmVyc2lvbjogJzEuNS4wJyB9LFxuICogICB7IGVuZ2luZVZlcnNpb246ICcyLjAuMCcsIHRyYW5zbWlzc2lvblZlcnNpb246ICcxLjUuMCcgfVxuICogKS5waXBlKFxuICogICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgocHJldiwgY3VycikgPT4ge1xuICogICAgIHJldHVybiAoXG4gKiAgICAgICBwcmV2LmVuZ2luZVZlcnNpb24gPT09IGN1cnIuZW5naW5lVmVyc2lvbiB8fFxuICogICAgICAgcHJldi50cmFuc21pc3Npb25WZXJzaW9uID09PSBjdXJyLnRyYW5zbWlzc2lvblZlcnNpb25cbiAqICAgICApO1xuICogICB9KVxuICogKTtcbiAqXG4gKiB0b3RhbGx5RGlmZmVyZW50QnVpbGRzJC5zdWJzY3JpYmUoY29uc29sZS5sb2cpO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyB7IGVuZ2luZVZlcnNpb246ICcxLjEuMCcsIHRyYW5zbWlzc2lvblZlcnNpb246ICcxLjIuMCcgfVxuICogLy8geyBlbmdpbmVWZXJzaW9uOiAnMS4zLjAnLCB0cmFuc21pc3Npb25WZXJzaW9uOiAnMS40LjAnIH1cbiAqIC8vIHsgZW5naW5lVmVyc2lvbjogJzIuMC4wJywgdHJhbnNtaXNzaW9uVmVyc2lvbjogJzEuNS4wJyB9XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIGN1c3RvbSBge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkI2NvbXBhcmF0b3IgY29tcGFyYXRvcn1gIHRvIGNoZWNrIHRoYXQgZW1pdHRlZFxuICogY2hhbmdlcyBhcmUgb25seSBpbiBvbmUgZGlyZWN0aW9uLiBMZXQncyBzYXkgeW91IG9ubHkgd2FudCB0byBnZXRcbiAqIHRoZSBuZXh0IHJlY29yZCB0ZW1wZXJhdHVyZTpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgb2YsIGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgdGVtcHMkID0gb2YoMzAsIDMxLCAyMCwgMzQsIDMzLCAyOSwgMzUsIDIwKTtcbiAqXG4gKiBjb25zdCByZWNvcmRIaWdocyQgPSB0ZW1wcyQucGlwZShcbiAqICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKHByZXZIaWdoLCB0ZW1wKSA9PiB7XG4gKiAgICAgLy8gSWYgdGhlIGN1cnJlbnQgdGVtcCBpcyBsZXNzIHRoYW5cbiAqICAgICAvLyBvciB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgcmVjb3JkLFxuICogICAgIC8vIHRoZSByZWNvcmQgaGFzbid0IGNoYW5nZWQuXG4gKiAgICAgcmV0dXJuIHRlbXAgPD0gcHJldkhpZ2g7XG4gKiAgIH0pXG4gKiApO1xuICpcbiAqIHJlY29yZEhpZ2hzJC5zdWJzY3JpYmUoY29uc29sZS5sb2cpO1xuICogLy8gTG9nczogMzAsIDMxLCAzNCwgMzVcbiAqIGBgYFxuICpcbiAqIFNlbGVjdGluZyB1cGRhdGUgZXZlbnRzIG9ubHkgd2hlbiB0aGUgYHVwZGF0ZWRCeWAgZmllbGQgc2hvd3NcbiAqIHRoZSBhY2NvdW50IGNoYW5nZWQgaGFuZHMuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIC8vIEEgc3RyZWFtIG9mIHVwZGF0ZXMgdG8gYSBnaXZlbiBhY2NvdW50XG4gKiBjb25zdCBhY2NvdW50VXBkYXRlcyQgPSBvZihcbiAqICAgeyB1cGRhdGVkQnk6ICdibGVzaCcsIGRhdGE6IFtdIH0sXG4gKiAgIHsgdXBkYXRlZEJ5OiAnYmxlc2gnLCBkYXRhOiBbXSB9LFxuICogICB7IHVwZGF0ZWRCeTogJ25jamFtaWVzb24nLCBkYXRhOiBbXSB9LFxuICogICB7IHVwZGF0ZWRCeTogJ25jamFtaWVzb24nLCBkYXRhOiBbXSB9LFxuICogICB7IHVwZGF0ZWRCeTogJ2JsZXNoJywgZGF0YTogW10gfVxuICogKTtcbiAqXG4gKiAvLyBXZSBvbmx5IHdhbnQgdGhlIGV2ZW50cyB3aGVyZSBpdCBjaGFuZ2VkIGhhbmRzXG4gKiBjb25zdCBjaGFuZ2VkSGFuZHMkID0gYWNjb3VudFVwZGF0ZXMkLnBpcGUoXG4gKiAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKHVuZGVmaW5lZCwgdXBkYXRlID0+IHVwZGF0ZS51cGRhdGVkQnkpXG4gKiApO1xuICpcbiAqIGNoYW5nZWRIYW5kcyQuc3Vic2NyaWJlKGNvbnNvbGUubG9nKTtcbiAqIC8vIExvZ3M6XG4gKiAvLyB7IHVwZGF0ZWRCeTogJ2JsZXNoJywgZGF0YTogQXJyYXlbMF0gfVxuICogLy8geyB1cGRhdGVkQnk6ICduY2phbWllc29uJywgZGF0YTogQXJyYXlbMF0gfVxuICogLy8geyB1cGRhdGVkQnk6ICdibGVzaCcsIGRhdGE6IEFycmF5WzBdIH1cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKlxuICogQHBhcmFtIGNvbXBhcmF0b3IgQSBmdW5jdGlvbiB1c2VkIHRvIGNvbXBhcmUgdGhlIHByZXZpb3VzIGFuZCBjdXJyZW50IGtleXMgZm9yXG4gKiBlcXVhbGl0eS4gRGVmYXVsdHMgdG8gYSBgPT09YCBjaGVjay5cbiAqIEBwYXJhbSBrZXlTZWxlY3RvciBVc2VkIHRvIHNlbGVjdCBhIGtleSB2YWx1ZSB0byBiZSBwYXNzZWQgdG8gdGhlIGBjb21wYXJhdG9yYC5cbiAqXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUgd2l0aCBkaXN0aW5jdCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZDxULCBLPihcbiAgY29tcGFyYXRvcj86IChwcmV2aW91czogSywgY3VycmVudDogSykgPT4gYm9vbGVhbixcbiAga2V5U2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gSyA9IGlkZW50aXR5IGFzICh2YWx1ZTogVCkgPT4gS1xuKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgLy8gV2UndmUgYmVlbiBhbGxvd2luZyBgbnVsbGAgZG8gYmUgcGFzc2VkIGFzIHRoZSBgY29tcGFyZWAsIHNvIHdlIGNhbid0IGRvXG4gIC8vIGEgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHBhcmFtZXRlciwgYmVjYXVzZSB0aGF0IHdpbGwgb25seSB3b3JrXG4gIC8vIGZvciBgdW5kZWZpbmVkYC5cbiAgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgPz8gZGVmYXVsdENvbXBhcmU7XG5cbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIC8vIFRoZSBwcmV2aW91cyBrZXksIHVzZWQgdG8gY29tcGFyZSBhZ2FpbnN0IGtleXMgc2VsZWN0ZWRcbiAgICAvLyBmcm9tIG5ldyBhcnJpdmFscyB0byBkZXRlcm1pbmUgXCJkaXN0aW5jdGl2ZW5lc3NcIi5cbiAgICBsZXQgcHJldmlvdXNLZXk6IEs7XG4gICAgLy8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgd2UndmUgZ290dGVuLlxuICAgIGxldCBmaXJzdCA9IHRydWU7XG5cbiAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBXZSBhbHdheXMgY2FsbCB0aGUga2V5IHNlbGVjdG9yLlxuICAgICAgICBjb25zdCBjdXJyZW50S2V5ID0ga2V5U2VsZWN0b3IodmFsdWUpO1xuXG4gICAgICAgIC8vIElmIGl0J3MgdGhlIGZpcnN0IHZhbHVlLCB3ZSBhbHdheXMgZW1pdCBpdC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBjb21wYXJlIHRoaXMga2V5IHRvIHRoZSBwcmV2aW91cyBrZXksIGFuZFxuICAgICAgICAvLyBpZiB0aGUgY29tcGFyZXIgcmV0dXJucyBmYWxzZSwgd2UgZW1pdC5cbiAgICAgICAgaWYgKGZpcnN0IHx8ICFjb21wYXJhdG9yIShwcmV2aW91c0tleSwgY3VycmVudEtleSkpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgb3VyIHN0YXRlICpiZWZvcmUqIHdlIGVtaXQgdGhlIHZhbHVlXG4gICAgICAgICAgLy8gYXMgZW1pc3Npb24gY2FuIGJlIHRoZSBzb3VyY2Ugb2YgcmUtZW50cmFudCBjb2RlXG4gICAgICAgICAgLy8gaW4gZnVuY3Rpb25hbCBsaWJyYXJpZXMgbGlrZSB0aGlzLiBXZSBvbmx5IHJlYWxseVxuICAgICAgICAgIC8vIG5lZWQgdG8gZG8gdGhpcyBpZiBpdCdzIHRoZSBmaXJzdCB2YWx1ZSwgb3IgaWYgdGhlXG4gICAgICAgICAgLy8ga2V5IHdlJ3JlIHRyYWNraW5nIGluIHByZXZpb3VzIG5lZWRzIHRvIGNoYW5nZS5cbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIHByZXZpb3VzS2V5ID0gY3VycmVudEtleTtcblxuICAgICAgICAgIC8vIEVtaXQgdGhlIHZhbHVlIVxuICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGE6IGFueSwgYjogYW55KSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuIl19
