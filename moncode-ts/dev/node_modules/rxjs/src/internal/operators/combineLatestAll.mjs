import { combineLatest } from '../observable/combineLatest.mjs';
import { joinAllInternals } from './joinAllInternals.mjs';
/**
 * Flattens an Observable-of-Observables by applying {@link combineLatest} when the Observable-of-Observables completes.
 *
 * `combineLatestAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes,
 * it subscribes to all collected Observables and combines their values using the {@link combineLatest} strategy, such that:
 *
 * * Every time an inner Observable emits, the output Observable emits
 * * When the returned observable emits, it emits all of the latest values by:
 *    * If a `project` function is provided, it is called with each recent value from each inner Observable in whatever order they
 *      arrived, and the result of the `project` function is what is emitted by the output Observable.
 *    * If there is no `project` function, an array of all the most recent values is emitted by the output Observable.
 *
 * ## Example
 *
 * Map two click events to a finite interval Observable, then apply `combineLatestAll`
 *
 * ```ts
 * import { fromEvent, map, interval, take, combineLatestAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const higherOrder = clicks.pipe(
 *   map(() => interval(Math.random() * 2000).pipe(take(3))),
 *   take(2)
 * );
 * const result = higherOrder.pipe(combineLatestAll());
 *
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link combineLatest}
 * @see {@link combineLatestWith}
 * @see {@link mergeAll}
 *
 * @param project optional function to map the most recent values from each inner Observable into a new result.
 * Takes each of the most recent values from each collected inner Observable as arguments, in order.
 * @return A function that returns an Observable that flattens Observables
 * emitted by the source Observable.
 */
export function combineLatestAll(project) {
    return joinAllInternals(combineLatest, project);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvY29tYmluZUxhdGVzdEFsbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFNUQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFPdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQ0c7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQUksT0FBc0M7SUFDeEUsT0FBTyxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDbEQsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3RBbGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21iaW5lTGF0ZXN0IH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcbmltcG9ydCB7IE9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGpvaW5BbGxJbnRlcm5hbHMgfSBmcm9tICcuL2pvaW5BbGxJbnRlcm5hbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdEFsbDxUPigpOiBPcGVyYXRvckZ1bmN0aW9uPE9ic2VydmFibGVJbnB1dDxUPiwgVFtdPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0QWxsPFQ+KCk6IE9wZXJhdG9yRnVuY3Rpb248YW55LCBUW10+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3RBbGw8VCwgUj4ocHJvamVjdDogKC4uLnZhbHVlczogVFtdKSA9PiBSKTogT3BlcmF0b3JGdW5jdGlvbjxPYnNlcnZhYmxlSW5wdXQ8VD4sIFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3RBbGw8Uj4ocHJvamVjdDogKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gUik6IE9wZXJhdG9yRnVuY3Rpb248YW55LCBSPjtcblxuLyoqXG4gKiBGbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IGFwcGx5aW5nIHtAbGluayBjb21iaW5lTGF0ZXN0fSB3aGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGNvbXBsZXRlcy5cbiAqXG4gKiBgY29tYmluZUxhdGVzdEFsbGAgdGFrZXMgYW4gT2JzZXJ2YWJsZSBvZiBPYnNlcnZhYmxlcywgYW5kIGNvbGxlY3RzIGFsbCBPYnNlcnZhYmxlcyBmcm9tIGl0LiBPbmNlIHRoZSBvdXRlciBPYnNlcnZhYmxlIGNvbXBsZXRlcyxcbiAqIGl0IHN1YnNjcmliZXMgdG8gYWxsIGNvbGxlY3RlZCBPYnNlcnZhYmxlcyBhbmQgY29tYmluZXMgdGhlaXIgdmFsdWVzIHVzaW5nIHRoZSB7QGxpbmsgY29tYmluZUxhdGVzdH0gc3RyYXRlZ3ksIHN1Y2ggdGhhdDpcbiAqXG4gKiAqIEV2ZXJ5IHRpbWUgYW4gaW5uZXIgT2JzZXJ2YWJsZSBlbWl0cywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzXG4gKiAqIFdoZW4gdGhlIHJldHVybmVkIG9ic2VydmFibGUgZW1pdHMsIGl0IGVtaXRzIGFsbCBvZiB0aGUgbGF0ZXN0IHZhbHVlcyBieTpcbiAqICAgICogSWYgYSBgcHJvamVjdGAgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IGlzIGNhbGxlZCB3aXRoIGVhY2ggcmVjZW50IHZhbHVlIGZyb20gZWFjaCBpbm5lciBPYnNlcnZhYmxlIGluIHdoYXRldmVyIG9yZGVyIHRoZXlcbiAqICAgICAgYXJyaXZlZCwgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGBwcm9qZWN0YCBmdW5jdGlvbiBpcyB3aGF0IGlzIGVtaXR0ZWQgYnkgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogICAgKiBJZiB0aGVyZSBpcyBubyBgcHJvamVjdGAgZnVuY3Rpb24sIGFuIGFycmF5IG9mIGFsbCB0aGUgbW9zdCByZWNlbnQgdmFsdWVzIGlzIGVtaXR0ZWQgYnkgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBNYXAgdHdvIGNsaWNrIGV2ZW50cyB0byBhIGZpbml0ZSBpbnRlcnZhbCBPYnNlcnZhYmxlLCB0aGVuIGFwcGx5IGBjb21iaW5lTGF0ZXN0QWxsYFxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIG1hcCwgaW50ZXJ2YWwsIHRha2UsIGNvbWJpbmVMYXRlc3RBbGwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBjbGlja3MgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogY29uc3QgaGlnaGVyT3JkZXIgPSBjbGlja3MucGlwZShcbiAqICAgbWFwKCgpID0+IGludGVydmFsKE1hdGgucmFuZG9tKCkgKiAyMDAwKS5waXBlKHRha2UoMykpKSxcbiAqICAgdGFrZSgyKVxuICogKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGhpZ2hlck9yZGVyLnBpcGUoY29tYmluZUxhdGVzdEFsbCgpKTtcbiAqXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUxhdGVzdH1cbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVMYXRlc3RXaXRofVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKlxuICogQHBhcmFtIHByb2plY3Qgb3B0aW9uYWwgZnVuY3Rpb24gdG8gbWFwIHRoZSBtb3N0IHJlY2VudCB2YWx1ZXMgZnJvbSBlYWNoIGlubmVyIE9ic2VydmFibGUgaW50byBhIG5ldyByZXN1bHQuXG4gKiBUYWtlcyBlYWNoIG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZXMgZnJvbSBlYWNoIGNvbGxlY3RlZCBpbm5lciBPYnNlcnZhYmxlIGFzIGFyZ3VtZW50cywgaW4gb3JkZXIuXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBmbGF0dGVucyBPYnNlcnZhYmxlc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0QWxsPFI+KHByb2plY3Q/OiAoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKSB7XG4gIHJldHVybiBqb2luQWxsSW50ZXJuYWxzKGNvbWJpbmVMYXRlc3QsIHByb2plY3QpO1xufVxuIl19
