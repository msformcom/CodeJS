import { innerFrom } from '../observable/innerFrom.mjs';
import { Subject } from '../Subject.mjs';
import { SafeSubscriber } from '../Subscriber.mjs';
import { operate } from '../util/lift.mjs';
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for `multicast(() => new Subject()), refCount()`.
 *
 * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),
 * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is
 * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please
 * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart
 * of the source because the error or complete will be forwarded to all subscribers and their subscription will be
 * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the
 * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.
 *
 * ![](share.png)
 *
 * ## Example
 *
 * Generate new multicast Observable from the `source` Observable value
 *
 * ```ts
 * import { interval, tap, map, take, share } from 'rxjs';
 *
 * const source = interval(1000).pipe(
 *   tap(x => console.log('Processing: ', x)),
 *   map(x => x * x),
 *   take(6),
 *   share()
 * );
 *
 * source.subscribe(x => console.log('subscription 1: ', x));
 * source.subscribe(x => console.log('subscription 2: ', x));
 *
 * // Logs:
 * // Processing: 0
 * // subscription 1: 0
 * // subscription 2: 0
 * // Processing: 1
 * // subscription 1: 1
 * // subscription 2: 1
 * // Processing: 2
 * // subscription 1: 4
 * // subscription 2: 4
 * // Processing: 3
 * // subscription 1: 9
 * // subscription 2: 9
 * // Processing: 4
 * // subscription 1: 16
 * // subscription 2: 16
 * // Processing: 5
 * // subscription 1: 25
 * // subscription 2: 25
 * ```
 *
 * ## Example with notifier factory: Delayed reset
 *
 * ```ts
 * import { interval, take, share, timer } from 'rxjs';
 *
 * const source = interval(1000).pipe(
 *   take(3),
 *   share({
 *     resetOnRefCountZero: () => timer(1000)
 *   })
 * );
 *
 * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));
 * setTimeout(() => subscriptionOne.unsubscribe(), 1300);
 *
 * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);
 *
 * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);
 *
 * // Logs:
 * // subscription 1:  0
 * // (subscription 1 unsubscribes here)
 * // (subscription 2 subscribes here ~400ms later, source was not reset)
 * // subscription 2:  1
 * // subscription 2:  2
 * // (subscription 2 unsubscribes here)
 * // (subscription 3 subscribes here ~2000ms later, source did reset before)
 * // subscription 3:  0
 * // subscription 3:  1
 * // subscription 3:  2
 * ```
 *
 * @see {@link shareReplay}
 *
 * @return A function that returns an Observable that mirrors the source.
 */
export function share(options = {}) {
    const { connector = () => new Subject(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;
    // It's necessary to use a wrapper here, as the _operator_ must be
    // referentially transparent. Otherwise, it cannot be used in calls to the
    // static `pipe` function - to create a partial pipeline.
    //
    // The _operator function_ - the function returned by the _operator_ - will
    // not be referentially transparent - as it shares its source - but the
    // _operator function_ is called when the complete pipeline is composed via a
    // call to a source observable's `pipe` method - not when the static `pipe`
    // function is called.
    return (wrapperSource) => {
        let connection;
        let resetConnection;
        let subject;
        let refCount = 0;
        let hasCompleted = false;
        let hasErrored = false;
        const cancelReset = () => {
            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
            resetConnection = undefined;
        };
        // Used to reset the internal state to a "cold"
        // state, as though it had never been subscribed to.
        const reset = () => {
            cancelReset();
            connection = subject = undefined;
            hasCompleted = hasErrored = false;
        };
        const resetAndUnsubscribe = () => {
            // We need to capture the connection before
            // we reset (if we need to reset).
            const conn = connection;
            reset();
            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return operate((source, subscriber) => {
            refCount++;
            if (!hasErrored && !hasCompleted) {
                cancelReset();
            }
            // Create the subject if we don't have one yet. Grab a local reference to
            // it as well, which avoids non-null assertions when using it and, if we
            // connect to it now, then error/complete need a reference after it was
            // reset.
            const dest = (subject = subject !== null && subject !== void 0 ? subject : connector());
            // Add the finalization directly to the subscriber - instead of returning it -
            // so that the handling of the subscriber's unsubscription will be wired
            // up _before_ the subscription to the source occurs. This is done so that
            // the assignment to the source connection's `closed` property will be seen
            // by synchronous firehose sources.
            subscriber.add(() => {
                refCount--;
                // If we're resetting on refCount === 0, and it's 0, we only want to do
                // that on "unsubscribe", really. Resetting on error or completion is a different
                // configuration.
                if (refCount === 0 && !hasErrored && !hasCompleted) {
                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
                }
            });
            // The following line adds the subscription to the subscriber passed.
            // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.
            dest.subscribe(subscriber);
            if (!connection &&
                // Check this shareReplay is still activate - it can be reset to 0
                // and be "unsubscribed" _before_ it actually subscribes.
                // If we were to subscribe then, it'd leak and get stuck.
                refCount > 0) {
                // We need to create a subscriber here - rather than pass an observer and
                // assign the returned subscription to connection - because it's possible
                // for reentrant subscriptions to the shared observable to occur and in
                // those situations we want connection to be already-assigned so that we
                // don't create another connection to the source.
                connection = new SafeSubscriber({
                    next: (value) => dest.next(value),
                    error: (err) => {
                        hasErrored = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnError, err);
                        dest.error(err);
                    },
                    complete: () => {
                        hasCompleted = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnComplete);
                        dest.complete();
                    },
                });
                innerFrom(source).subscribe(connection);
            }
        })(wrapperSource);
    };
}
function handleReset(reset, on, ...args) {
    if (on === true) {
        reset();
        return;
    }
    if (on === false) {
        return;
    }
    const onSubscriber = new SafeSubscriber({
        next: () => {
            onSubscriber.unsubscribe();
            reset();
        },
    });
    return innerFrom(on(...args)).subscribe(onSubscriber);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc2hhcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDckMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUcvQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBOEN2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5Rkc7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUFJLFVBQTBCLEVBQUU7SUFDbkQsTUFBTSxFQUFFLFNBQVMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLE9BQU8sRUFBSyxFQUFFLFlBQVksR0FBRyxJQUFJLEVBQUUsZUFBZSxHQUFHLElBQUksRUFBRSxtQkFBbUIsR0FBRyxJQUFJLEVBQUUsR0FBRyxPQUFPLENBQUM7SUFDaEksa0VBQWtFO0lBQ2xFLDBFQUEwRTtJQUMxRSx5REFBeUQ7SUFDekQsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSx1RUFBdUU7SUFDdkUsNkVBQTZFO0lBQzdFLDJFQUEyRTtJQUMzRSxzQkFBc0I7SUFDdEIsT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFO1FBQ3ZCLElBQUksVUFBeUMsQ0FBQztRQUM5QyxJQUFJLGVBQXlDLENBQUM7UUFDOUMsSUFBSSxPQUFtQyxDQUFDO1FBQ3hDLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztRQUNqQixJQUFJLFlBQVksR0FBRyxLQUFLLENBQUM7UUFDekIsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBRXZCLE1BQU0sV0FBVyxHQUFHLEdBQUcsRUFBRTtZQUN2QixlQUFlLGFBQWYsZUFBZSx1QkFB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SCxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNwQixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxXQUFXLENBQ2xCLEtBQWlCLEVBQ2pCLEVBQW9ELEVBQ3BELEdBQUcsSUFBTztJQUVWLElBQUksRUFBRSxLQUFLLElBQUksRUFBRSxDQUFDO1FBQ2hCLEtBQUssRUFBRSxDQUFDO1FBQ1IsT0FBTztJQUNULENBQUM7SUFFRCxJQUFJLEVBQUUsS0FBSyxLQUFLLEVBQUUsQ0FBQztRQUNqQixPQUFPO0lBQ1QsQ0FBQztJQUVELE1BQU0sWUFBWSxHQUFHLElBQUksY0FBYyxDQUFDO1FBQ3RDLElBQUksRUFBRSxHQUFHLEVBQUU7WUFDVCxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDM0IsS0FBSyxFQUFFLENBQUM7UUFDVixDQUFDO0tBQ0YsQ0FBQyxDQUFDO0lBRUgsT0FBTyxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDeEQsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3NoYXJlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgU2FmZVN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sIFN1YmplY3RMaWtlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcblxuZXhwb3J0IGludGVyZmFjZSBTaGFyZUNvbmZpZzxUPiB7XG4gIC8qKlxuICAgKiBUaGUgZmFjdG9yeSB1c2VkIHRvIGNyZWF0ZSB0aGUgc3ViamVjdCB0aGF0IHdpbGwgY29ubmVjdCB0aGUgc291cmNlIG9ic2VydmFibGUgdG9cbiAgICogbXVsdGljYXN0IGNvbnN1bWVycy5cbiAgICovXG4gIGNvbm5lY3Rvcj86ICgpID0+IFN1YmplY3RMaWtlPFQ+O1xuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgd2lsbCByZXNldCBpbnRlcm5hbCBzdGF0ZSBvbiBlcnJvciBmcm9tIHNvdXJjZSBhbmQgcmV0dXJuIHRvIGEgXCJjb2xkXCIgc3RhdGUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSB0byBiZSBcInJldHJpZWRcIiBpbiB0aGUgZXZlbnQgb2YgYW4gZXJyb3IuXG4gICAqIElmIGBmYWxzZWAsIHdoZW4gYW4gZXJyb3IgY29tZXMgZnJvbSB0aGUgc291cmNlIGl0IHdpbGwgcHVzaCB0aGUgZXJyb3IgaW50byB0aGUgY29ubmVjdGluZyBzdWJqZWN0LCBhbmQgdGhlIHN1YmplY3RcbiAgICogd2lsbCByZW1haW4gdGhlIGNvbm5lY3Rpbmcgc3ViamVjdCwgbWVhbmluZyB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgd2lsbCBub3QgZ28gXCJjb2xkXCIgYWdhaW4sIGFuZCBzdWJzZXF1ZW50IHJldHJpZXNcbiAgICogb3IgcmVzdWJzY3JpcHRpb25zIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhhdCBzYW1lIHN1YmplY3QuIEluIGFsbCBjYXNlcywgUnhKUyBzdWJqZWN0cyB3aWxsIGVtaXQgdGhlIHNhbWUgZXJyb3IgYWdhaW4sIGhvd2V2ZXJcbiAgICoge0BsaW5rIFJlcGxheVN1YmplY3R9IHdpbGwgYWxzbyBwdXNoIGl0cyBidWZmZXJlZCB2YWx1ZXMgYmVmb3JlIHB1c2hpbmcgdGhlIGVycm9yLlxuICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHBhc3MgYSBub3RpZmllciBmYWN0b3J5IHJldHVybmluZyBhbiBgT2JzZXJ2YWJsZUlucHV0YCBpbnN0ZWFkIHdoaWNoIGdyYW50cyBtb3JlIGZpbmUtZ3JhaW5lZFxuICAgKiBjb250cm9sIG92ZXIgaG93IGFuZCB3aGVuIHRoZSByZXNldCBzaG91bGQgaGFwcGVuLiBUaGlzIGFsbG93cyBiZWhhdmlvcnMgbGlrZSBjb25kaXRpb25hbCBvciBkZWxheWVkIHJlc2V0cy5cbiAgICovXG4gIHJlc2V0T25FcnJvcj86IGJvb2xlYW4gfCAoKGVycm9yOiBhbnkpID0+IE9ic2VydmFibGVJbnB1dDxhbnk+KTtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHdpbGwgcmVzZXQgaW50ZXJuYWwgc3RhdGUgb24gY29tcGxldGlvbiBmcm9tIHNvdXJjZSBhbmQgcmV0dXJuIHRvIGEgXCJjb2xkXCIgc3RhdGUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSB0byBiZSBcInJlcGVhdGVkXCIgYWZ0ZXIgaXQgaXMgZG9uZS5cbiAgICogSWYgYGZhbHNlYCwgd2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcywgaXQgd2lsbCBwdXNoIHRoZSBjb21wbGV0aW9uIHRocm91Z2ggdGhlIGNvbm5lY3Rpbmcgc3ViamVjdCwgYW5kIHRoZSBzdWJqZWN0XG4gICAqIHdpbGwgcmVtYWluIHRoZSBjb25uZWN0aW5nIHN1YmplY3QsIG1lYW5pbmcgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHdpbGwgbm90IGdvIFwiY29sZFwiIGFnYWluLCBhbmQgc3Vic2VxdWVudCByZXBlYXRzXG4gICAqIG9yIHJlc3Vic2NyaXB0aW9ucyB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoYXQgc2FtZSBzdWJqZWN0LlxuICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHBhc3MgYSBub3RpZmllciBmYWN0b3J5IHJldHVybmluZyBhbiBgT2JzZXJ2YWJsZUlucHV0YCBpbnN0ZWFkIHdoaWNoIGdyYW50cyBtb3JlIGZpbmUtZ3JhaW5lZFxuICAgKiBjb250cm9sIG92ZXIgaG93IGFuZCB3aGVuIHRoZSByZXNldCBzaG91bGQgaGFwcGVuLiBUaGlzIGFsbG93cyBiZWhhdmlvcnMgbGlrZSBjb25kaXRpb25hbCBvciBkZWxheWVkIHJlc2V0cy5cbiAgICovXG4gIHJlc2V0T25Db21wbGV0ZT86IGJvb2xlYW4gfCAoKCkgPT4gT2JzZXJ2YWJsZUlucHV0PGFueT4pO1xuICAvKipcbiAgICogSWYgYHRydWVgLCB3aGVuIHRoZSBudW1iZXIgb2Ygc3Vic2NyaWJlcnMgdG8gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHJlYWNoZXMgemVybyBkdWUgdG8gdGhvc2Ugc3Vic2NyaWJlcnMgdW5zdWJzY3JpYmluZywgdGhlXG4gICAqIGludGVybmFsIHN0YXRlIHdpbGwgYmUgcmVzZXQgYW5kIHRoZSByZXN1bHRpbmcgb2JzZXJ2YWJsZSB3aWxsIHJldHVybiB0byBhIFwiY29sZFwiIHN0YXRlLiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5leHRcbiAgICogdGltZSB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgaXMgc3Vic2NyaWJlZCB0bywgYSBuZXcgc3ViamVjdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSBzb3VyY2Ugd2lsbCBiZSBzdWJzY3JpYmVkIHRvXG4gICAqIGFnYWluLlxuICAgKiBJZiBgZmFsc2VgLCB3aGVuIHRoZSBudW1iZXIgb2Ygc3Vic2NyaWJlcnMgdG8gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHJlYWNoZXMgemVybyBkdWUgdG8gdW5zdWJzY3JpcHRpb24sIHRoZSBzdWJqZWN0XG4gICAqIHdpbGwgcmVtYWluIGNvbm5lY3RlZCB0byB0aGUgc291cmNlLCBhbmQgbmV3IHN1YnNjcmlwdGlvbnMgdG8gdGhlIHJlc3VsdCB3aWxsIGJlIGNvbm5lY3RlZCB0aHJvdWdoIHRoYXQgc2FtZSBzdWJqZWN0LlxuICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHBhc3MgYSBub3RpZmllciBmYWN0b3J5IHJldHVybmluZyBhbiBgT2JzZXJ2YWJsZUlucHV0YCBpbnN0ZWFkIHdoaWNoIGdyYW50cyBtb3JlIGZpbmUtZ3JhaW5lZFxuICAgKiBjb250cm9sIG92ZXIgaG93IGFuZCB3aGVuIHRoZSByZXNldCBzaG91bGQgaGFwcGVuLiBUaGlzIGFsbG93cyBiZWhhdmlvcnMgbGlrZSBjb25kaXRpb25hbCBvciBkZWxheWVkIHJlc2V0cy5cbiAgICovXG4gIHJlc2V0T25SZWZDb3VudFplcm8/OiBib29sZWFuIHwgKCgpID0+IE9ic2VydmFibGVJbnB1dDxhbnk+KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoYXJlPFQ+KCk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNoYXJlPFQ+KG9wdGlvbnM6IFNoYXJlQ29uZmlnPFQ+KTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgT2JzZXJ2YWJsZSB0aGF0IG11bHRpY2FzdHMgKHNoYXJlcykgdGhlIG9yaWdpbmFsIE9ic2VydmFibGUuIEFzIGxvbmcgYXMgdGhlcmUgaXMgYXQgbGVhc3Qgb25lXG4gKiBTdWJzY3JpYmVyIHRoaXMgT2JzZXJ2YWJsZSB3aWxsIGJlIHN1YnNjcmliZWQgYW5kIGVtaXR0aW5nIGRhdGEuIFdoZW4gYWxsIHN1YnNjcmliZXJzIGhhdmUgdW5zdWJzY3JpYmVkIGl0IHdpbGxcbiAqIHVuc3Vic2NyaWJlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBCZWNhdXNlIHRoZSBPYnNlcnZhYmxlIGlzIG11bHRpY2FzdGluZyBpdCBtYWtlcyB0aGUgc3RyZWFtIGBob3RgLlxuICogVGhpcyBpcyBhbiBhbGlhcyBmb3IgYG11bHRpY2FzdCgoKSA9PiBuZXcgU3ViamVjdCgpKSwgcmVmQ291bnQoKWAuXG4gKlxuICogVGhlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzb3VyY2UgT2JzZXJ2YWJsZSBjYW4gYmUgcmVzZXQgKHVuc3Vic2NyaWJlIGFuZCByZXN1YnNjcmliZSBmb3IgbmV3IHN1YnNjcmliZXJzKSxcbiAqIGlmIHRoZSBzdWJzY3JpYmVyIGNvdW50IHRvIHRoZSBzaGFyZWQgb2JzZXJ2YWJsZSBkcm9wcyB0byAwLCBvciBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgZXJyb3JzIG9yIGNvbXBsZXRlcy4gSXQgaXNcbiAqIHBvc3NpYmxlIHRvIHVzZSBub3RpZmllciBmYWN0b3JpZXMgZm9yIHRoZSByZXNldHMgdG8gYWxsb3cgZm9yIGJlaGF2aW9ycyBsaWtlIGNvbmRpdGlvbmFsIG9yIGRlbGF5ZWQgcmVzZXRzLiBQbGVhc2VcbiAqIG5vdGUgdGhhdCByZXNldHRpbmcgb24gZXJyb3Igb3IgY29tcGxldGUgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGRvZXMgbm90IGJlaGF2ZSBsaWtlIGEgdHJhbnNwYXJlbnQgcmV0cnkgb3IgcmVzdGFydFxuICogb2YgdGhlIHNvdXJjZSBiZWNhdXNlIHRoZSBlcnJvciBvciBjb21wbGV0ZSB3aWxsIGJlIGZvcndhcmRlZCB0byBhbGwgc3Vic2NyaWJlcnMgYW5kIHRoZWlyIHN1YnNjcmlwdGlvbiB3aWxsIGJlXG4gKiBjbG9zZWQuIE9ubHkgbmV3IHN1YnNjcmliZXJzIGFmdGVyIGEgcmVzZXQgb24gZXJyb3Igb3IgY29tcGxldGUgaGFwcGVuZWQgd2lsbCBjYXVzZSBhIGZyZXNoIHN1YnNjcmlwdGlvbiB0byB0aGVcbiAqIHNvdXJjZS4gVG8gYWNoaWV2ZSB0cmFuc3BhcmVudCByZXRyaWVzIG9yIHJlc3RhcnRzIHBpcGUgdGhlIHNvdXJjZSB0aHJvdWdoIGFwcHJvcHJpYXRlIG9wZXJhdG9ycyBiZWZvcmUgc2hhcmluZy5cbiAqXG4gKiAhW10oc2hhcmUucG5nKVxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBHZW5lcmF0ZSBuZXcgbXVsdGljYXN0IE9ic2VydmFibGUgZnJvbSB0aGUgYHNvdXJjZWAgT2JzZXJ2YWJsZSB2YWx1ZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpbnRlcnZhbCwgdGFwLCBtYXAsIHRha2UsIHNoYXJlIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3Qgc291cmNlID0gaW50ZXJ2YWwoMTAwMCkucGlwZShcbiAqICAgdGFwKHggPT4gY29uc29sZS5sb2coJ1Byb2Nlc3Npbmc6ICcsIHgpKSxcbiAqICAgbWFwKHggPT4geCAqIHgpLFxuICogICB0YWtlKDYpLFxuICogICBzaGFyZSgpXG4gKiApO1xuICpcbiAqIHNvdXJjZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnc3Vic2NyaXB0aW9uIDE6ICcsIHgpKTtcbiAqIHNvdXJjZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnc3Vic2NyaXB0aW9uIDI6ICcsIHgpKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gUHJvY2Vzc2luZzogMFxuICogLy8gc3Vic2NyaXB0aW9uIDE6IDBcbiAqIC8vIHN1YnNjcmlwdGlvbiAyOiAwXG4gKiAvLyBQcm9jZXNzaW5nOiAxXG4gKiAvLyBzdWJzY3JpcHRpb24gMTogMVxuICogLy8gc3Vic2NyaXB0aW9uIDI6IDFcbiAqIC8vIFByb2Nlc3Npbmc6IDJcbiAqIC8vIHN1YnNjcmlwdGlvbiAxOiA0XG4gKiAvLyBzdWJzY3JpcHRpb24gMjogNFxuICogLy8gUHJvY2Vzc2luZzogM1xuICogLy8gc3Vic2NyaXB0aW9uIDE6IDlcbiAqIC8vIHN1YnNjcmlwdGlvbiAyOiA5XG4gKiAvLyBQcm9jZXNzaW5nOiA0XG4gKiAvLyBzdWJzY3JpcHRpb24gMTogMTZcbiAqIC8vIHN1YnNjcmlwdGlvbiAyOiAxNlxuICogLy8gUHJvY2Vzc2luZzogNVxuICogLy8gc3Vic2NyaXB0aW9uIDE6IDI1XG4gKiAvLyBzdWJzY3JpcHRpb24gMjogMjVcbiAqIGBgYFxuICpcbiAqICMjIEV4YW1wbGUgd2l0aCBub3RpZmllciBmYWN0b3J5OiBEZWxheWVkIHJlc2V0XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGludGVydmFsLCB0YWtlLCBzaGFyZSwgdGltZXIgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UgPSBpbnRlcnZhbCgxMDAwKS5waXBlKFxuICogICB0YWtlKDMpLFxuICogICBzaGFyZSh7XG4gKiAgICAgcmVzZXRPblJlZkNvdW50WmVybzogKCkgPT4gdGltZXIoMTAwMClcbiAqICAgfSlcbiAqICk7XG4gKlxuICogY29uc3Qgc3Vic2NyaXB0aW9uT25lID0gc291cmNlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKCdzdWJzY3JpcHRpb24gMTogJywgeCkpO1xuICogc2V0VGltZW91dCgoKSA9PiBzdWJzY3JpcHRpb25PbmUudW5zdWJzY3JpYmUoKSwgMTMwMCk7XG4gKlxuICogc2V0VGltZW91dCgoKSA9PiBzb3VyY2Uuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ3N1YnNjcmlwdGlvbiAyOiAnLCB4KSksIDE3MDApO1xuICpcbiAqIHNldFRpbWVvdXQoKCkgPT4gc291cmNlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKCdzdWJzY3JpcHRpb24gMzogJywgeCkpLCA1MDAwKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gc3Vic2NyaXB0aW9uIDE6ICAwXG4gKiAvLyAoc3Vic2NyaXB0aW9uIDEgdW5zdWJzY3JpYmVzIGhlcmUpXG4gKiAvLyAoc3Vic2NyaXB0aW9uIDIgc3Vic2NyaWJlcyBoZXJlIH40MDBtcyBsYXRlciwgc291cmNlIHdhcyBub3QgcmVzZXQpXG4gKiAvLyBzdWJzY3JpcHRpb24gMjogIDFcbiAqIC8vIHN1YnNjcmlwdGlvbiAyOiAgMlxuICogLy8gKHN1YnNjcmlwdGlvbiAyIHVuc3Vic2NyaWJlcyBoZXJlKVxuICogLy8gKHN1YnNjcmlwdGlvbiAzIHN1YnNjcmliZXMgaGVyZSB+MjAwMG1zIGxhdGVyLCBzb3VyY2UgZGlkIHJlc2V0IGJlZm9yZSlcbiAqIC8vIHN1YnNjcmlwdGlvbiAzOiAgMFxuICogLy8gc3Vic2NyaXB0aW9uIDM6ICAxXG4gKiAvLyBzdWJzY3JpcHRpb24gMzogIDJcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHNoYXJlUmVwbGF5fVxuICpcbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYXJlPFQ+KG9wdGlvbnM6IFNoYXJlQ29uZmlnPFQ+ID0ge30pOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4ge1xuICBjb25zdCB7IGNvbm5lY3RvciA9ICgpID0+IG5ldyBTdWJqZWN0PFQ+KCksIHJlc2V0T25FcnJvciA9IHRydWUsIHJlc2V0T25Db21wbGV0ZSA9IHRydWUsIHJlc2V0T25SZWZDb3VudFplcm8gPSB0cnVlIH0gPSBvcHRpb25zO1xuICAvLyBJdCdzIG5lY2Vzc2FyeSB0byB1c2UgYSB3cmFwcGVyIGhlcmUsIGFzIHRoZSBfb3BlcmF0b3JfIG11c3QgYmVcbiAgLy8gcmVmZXJlbnRpYWxseSB0cmFuc3BhcmVudC4gT3RoZXJ3aXNlLCBpdCBjYW5ub3QgYmUgdXNlZCBpbiBjYWxscyB0byB0aGVcbiAgLy8gc3RhdGljIGBwaXBlYCBmdW5jdGlvbiAtIHRvIGNyZWF0ZSBhIHBhcnRpYWwgcGlwZWxpbmUuXG4gIC8vXG4gIC8vIFRoZSBfb3BlcmF0b3IgZnVuY3Rpb25fIC0gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHRoZSBfb3BlcmF0b3JfIC0gd2lsbFxuICAvLyBub3QgYmUgcmVmZXJlbnRpYWxseSB0cmFuc3BhcmVudCAtIGFzIGl0IHNoYXJlcyBpdHMgc291cmNlIC0gYnV0IHRoZVxuICAvLyBfb3BlcmF0b3IgZnVuY3Rpb25fIGlzIGNhbGxlZCB3aGVuIHRoZSBjb21wbGV0ZSBwaXBlbGluZSBpcyBjb21wb3NlZCB2aWEgYVxuICAvLyBjYWxsIHRvIGEgc291cmNlIG9ic2VydmFibGUncyBgcGlwZWAgbWV0aG9kIC0gbm90IHdoZW4gdGhlIHN0YXRpYyBgcGlwZWBcbiAgLy8gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICByZXR1cm4gKHdyYXBwZXJTb3VyY2UpID0+IHtcbiAgICBsZXQgY29ubmVjdGlvbjogU2FmZVN1YnNjcmliZXI8VD4gfCB1bmRlZmluZWQ7XG4gICAgbGV0IHJlc2V0Q29ubmVjdGlvbjogU3Vic2NyaXB0aW9uIHwgdW5kZWZpbmVkO1xuICAgIGxldCBzdWJqZWN0OiBTdWJqZWN0TGlrZTxUPiB8IHVuZGVmaW5lZDtcbiAgICBsZXQgcmVmQ291bnQgPSAwO1xuICAgIGxldCBoYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBsZXQgaGFzRXJyb3JlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgY2FuY2VsUmVzZXQgPSAoKSA9PiB7XG4gICAgICByZXNldENvbm5lY3Rpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgICByZXNldENvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvLyBVc2VkIHRvIHJlc2V0IHRoZSBpbnRlcm5hbCBzdGF0ZSB0byBhIFwiY29sZFwiXG4gICAgLy8gc3RhdGUsIGFzIHRob3VnaCBpdCBoYWQgbmV2ZXIgYmVlbiBzdWJzY3JpYmVkIHRvLlxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgY2FuY2VsUmVzZXQoKTtcbiAgICAgIGNvbm5lY3Rpb24gPSBzdWJqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgaGFzQ29tcGxldGVkID0gaGFzRXJyb3JlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgcmVzZXRBbmRVbnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2FwdHVyZSB0aGUgY29ubmVjdGlvbiBiZWZvcmVcbiAgICAgIC8vIHdlIHJlc2V0IChpZiB3ZSBuZWVkIHRvIHJlc2V0KS5cbiAgICAgIGNvbnN0IGNvbm4gPSBjb25uZWN0aW9uO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGNvbm4/LnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBvcGVyYXRlPFQsIFQ+KChzb3VyY2UsIHN1YnNjcmliZXIpID0+IHtcbiAgICAgIHJlZkNvdW50Kys7XG4gICAgICBpZiAoIWhhc0Vycm9yZWQgJiYgIWhhc0NvbXBsZXRlZCkge1xuICAgICAgICBjYW5jZWxSZXNldCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIHN1YmplY3QgaWYgd2UgZG9uJ3QgaGF2ZSBvbmUgeWV0LiBHcmFiIGEgbG9jYWwgcmVmZXJlbmNlIHRvXG4gICAgICAvLyBpdCBhcyB3ZWxsLCB3aGljaCBhdm9pZHMgbm9uLW51bGwgYXNzZXJ0aW9ucyB3aGVuIHVzaW5nIGl0IGFuZCwgaWYgd2VcbiAgICAgIC8vIGNvbm5lY3QgdG8gaXQgbm93LCB0aGVuIGVycm9yL2NvbXBsZXRlIG5lZWQgYSByZWZlcmVuY2UgYWZ0ZXIgaXQgd2FzXG4gICAgICAvLyByZXNldC5cbiAgICAgIGNvbnN0IGRlc3QgPSAoc3ViamVjdCA9IHN1YmplY3QgPz8gY29ubmVjdG9yKCkpO1xuXG4gICAgICAvLyBBZGQgdGhlIGZpbmFsaXphdGlvbiBkaXJlY3RseSB0byB0aGUgc3Vic2NyaWJlciAtIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IC1cbiAgICAgIC8vIHNvIHRoYXQgdGhlIGhhbmRsaW5nIG9mIHRoZSBzdWJzY3JpYmVyJ3MgdW5zdWJzY3JpcHRpb24gd2lsbCBiZSB3aXJlZFxuICAgICAgLy8gdXAgX2JlZm9yZV8gdGhlIHN1YnNjcmlwdGlvbiB0byB0aGUgc291cmNlIG9jY3Vycy4gVGhpcyBpcyBkb25lIHNvIHRoYXRcbiAgICAgIC8vIHRoZSBhc3NpZ25tZW50IHRvIHRoZSBzb3VyY2UgY29ubmVjdGlvbidzIGBjbG9zZWRgIHByb3BlcnR5IHdpbGwgYmUgc2VlblxuICAgICAgLy8gYnkgc3luY2hyb25vdXMgZmlyZWhvc2Ugc291cmNlcy5cbiAgICAgIHN1YnNjcmliZXIuYWRkKCgpID0+IHtcbiAgICAgICAgcmVmQ291bnQtLTtcblxuICAgICAgICAvLyBJZiB3ZSdyZSByZXNldHRpbmcgb24gcmVmQ291bnQgPT09IDAsIGFuZCBpdCdzIDAsIHdlIG9ubHkgd2FudCB0byBkb1xuICAgICAgICAvLyB0aGF0IG9uIFwidW5zdWJzY3JpYmVcIiwgcmVhbGx5LiBSZXNldHRpbmcgb24gZXJyb3Igb3IgY29tcGxldGlvbiBpcyBhIGRpZmZlcmVudFxuICAgICAgICAvLyBjb25maWd1cmF0aW9uLlxuICAgICAgICBpZiAocmVmQ291bnQgPT09IDAgJiYgIWhhc0Vycm9yZWQgJiYgIWhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgIHJlc2V0Q29ubmVjdGlvbiA9IGhhbmRsZVJlc2V0KHJlc2V0QW5kVW5zdWJzY3JpYmUsIHJlc2V0T25SZWZDb3VudFplcm8pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBsaW5lIGFkZHMgdGhlIHN1YnNjcmlwdGlvbiB0byB0aGUgc3Vic2NyaWJlciBwYXNzZWQuXG4gICAgICAvLyBCYXNpY2FsbHksIGBzdWJzY3JpYmVyID09PSBkZXN0LnN1YnNjcmliZShzdWJzY3JpYmVyKWAgaXMgYHRydWVgLlxuICAgICAgZGVzdC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG5cbiAgICAgIGlmIChcbiAgICAgICAgIWNvbm5lY3Rpb24gJiZcbiAgICAgICAgLy8gQ2hlY2sgdGhpcyBzaGFyZVJlcGxheSBpcyBzdGlsbCBhY3RpdmF0ZSAtIGl0IGNhbiBiZSByZXNldCB0byAwXG4gICAgICAgIC8vIGFuZCBiZSBcInVuc3Vic2NyaWJlZFwiIF9iZWZvcmVfIGl0IGFjdHVhbGx5IHN1YnNjcmliZXMuXG4gICAgICAgIC8vIElmIHdlIHdlcmUgdG8gc3Vic2NyaWJlIHRoZW4sIGl0J2QgbGVhayBhbmQgZ2V0IHN0dWNrLlxuICAgICAgICByZWZDb3VudCA+IDBcbiAgICAgICkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHN1YnNjcmliZXIgaGVyZSAtIHJhdGhlciB0aGFuIHBhc3MgYW4gb2JzZXJ2ZXIgYW5kXG4gICAgICAgIC8vIGFzc2lnbiB0aGUgcmV0dXJuZWQgc3Vic2NyaXB0aW9uIHRvIGNvbm5lY3Rpb24gLSBiZWNhdXNlIGl0J3MgcG9zc2libGVcbiAgICAgICAgLy8gZm9yIHJlZW50cmFudCBzdWJzY3JpcHRpb25zIHRvIHRoZSBzaGFyZWQgb2JzZXJ2YWJsZSB0byBvY2N1ciBhbmQgaW5cbiAgICAgICAgLy8gdGhvc2Ugc2l0dWF0aW9ucyB3ZSB3YW50IGNvbm5lY3Rpb24gdG8gYmUgYWxyZWFkeS1hc3NpZ25lZCBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGRvbid0IGNyZWF0ZSBhbm90aGVyIGNvbm5lY3Rpb24gdG8gdGhlIHNvdXJjZS5cbiAgICAgICAgY29ubmVjdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih7XG4gICAgICAgICAgbmV4dDogKHZhbHVlKSA9PiBkZXN0Lm5leHQodmFsdWUpLFxuICAgICAgICAgIGVycm9yOiAoZXJyKSA9PiB7XG4gICAgICAgICAgICBoYXNFcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbmNlbFJlc2V0KCk7XG4gICAgICAgICAgICByZXNldENvbm5lY3Rpb24gPSBoYW5kbGVSZXNldChyZXNldCwgcmVzZXRPbkVycm9yLCBlcnIpO1xuICAgICAgICAgICAgZGVzdC5lcnJvcihlcnIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIGhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICBjYW5jZWxSZXNldCgpO1xuICAgICAgICAgICAgcmVzZXRDb25uZWN0aW9uID0gaGFuZGxlUmVzZXQocmVzZXQsIHJlc2V0T25Db21wbGV0ZSk7XG4gICAgICAgICAgICBkZXN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlubmVyRnJvbShzb3VyY2UpLnN1YnNjcmliZShjb25uZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9KSh3cmFwcGVyU291cmNlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUmVzZXQ8VCBleHRlbmRzIHVua25vd25bXSA9IG5ldmVyW10+KFxuICByZXNldDogKCkgPT4gdm9pZCxcbiAgb246IGJvb2xlYW4gfCAoKC4uLmFyZ3M6IFQpID0+IE9ic2VydmFibGVJbnB1dDxhbnk+KSxcbiAgLi4uYXJnczogVFxuKTogU3Vic2NyaXB0aW9uIHwgdW5kZWZpbmVkIHtcbiAgaWYgKG9uID09PSB0cnVlKSB7XG4gICAgcmVzZXQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgb25TdWJzY3JpYmVyID0gbmV3IFNhZmVTdWJzY3JpYmVyKHtcbiAgICBuZXh0OiAoKSA9PiB7XG4gICAgICBvblN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIGlubmVyRnJvbShvbiguLi5hcmdzKSkuc3Vic2NyaWJlKG9uU3Vic2NyaWJlcik7XG59XG4iXX0=
