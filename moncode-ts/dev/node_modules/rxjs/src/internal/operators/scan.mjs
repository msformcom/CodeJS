import { operate } from '../util/lift.mjs';
import { scanInternals } from './scanInternals.mjs';
// TODO: link to a "redux pattern" section in the guide (location TBD)
/**
 * Useful for encapsulating and managing state. Applies an accumulator (or "reducer function")
 * to each value from the source after an initial state is established -- either via
 * a `seed` value (second argument), or from the first value from the source.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation state after each update</span>
 *
 * ![](scan.png)
 *
 * This operator maintains an internal state and emits it after processing each value as follows:
 *
 * 1. First value arrives
 *   - If a `seed` value was supplied (as the second argument to `scan`), let `state = seed` and `value = firstValue`.
 *   - If NO `seed` value was supplied (no second argument), let `state = firstValue` and go to 3.
 * 2. Let `state = accumulator(state, value)`.
 *   - If an error is thrown by `accumulator`, notify the consumer of an error. The process ends.
 * 3. Emit `state`.
 * 4. Next value arrives, let `value = nextValue`, go to 2.
 *
 * ## Examples
 *
 * An average of previous numbers. This example shows how
 * not providing a `seed` can prime the stream with the
 * first value from the source.
 *
 * ```ts
 * import { of, scan, map } from 'rxjs';
 *
 * const numbers$ = of(1, 2, 3);
 *
 * numbers$
 *   .pipe(
 *     // Get the sum of the numbers coming in.
 *     scan((total, n) => total + n),
 *     // Get the average by dividing the sum by the total number
 *     // received so far (which is 1 more than the zero-based index).
 *     map((sum, index) => sum / (index + 1))
 *   )
 *   .subscribe(console.log);
 * ```
 *
 * The Fibonacci sequence. This example shows how you can use
 * a seed to prime accumulation process. Also... you know... Fibonacci.
 * So important to like, computers and stuff that its whiteboarded
 * in job interviews. Now you can show them the Rx version! (Please don't, haha)
 *
 * ```ts
 * import { interval, scan, map, startWith } from 'rxjs';
 *
 * const firstTwoFibs = [0, 1];
 * // An endless stream of Fibonacci numbers.
 * const fibonacci$ = interval(1000).pipe(
 *   // Scan to get the fibonacci numbers (after 0, 1)
 *   scan(([a, b]) => [b, a + b], firstTwoFibs),
 *   // Get the second number in the tuple, it's the one you calculated
 *   map(([, n]) => n),
 *   // Start with our first two digits :)
 *   startWith(...firstTwoFibs)
 * );
 *
 * fibonacci$.subscribe(console.log);
 * ```
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 * @see {@link switchScan}
 *
 * @param accumulator A "reducer function". This will be called for each value after an initial state is
 * acquired.
 * @param seed The initial state. If this is not provided, the first value from the source will
 * be used as the initial state, and emitted without going through the accumulator. All subsequent values
 * will be processed by the accumulator function. If this is provided, all values will go through
 * the accumulator function.
 * @return A function that returns an Observable of the accumulated values.
 */
export function scan(accumulator, seed) {
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc2Nhbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQU1oRCxzRUFBc0U7QUFFdEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0RUc7QUFDSCxNQUFNLFVBQVUsSUFBSSxDQUFVLFdBQTJELEVBQUUsSUFBUTtJQUNqRyxnRUFBZ0U7SUFDaEUscURBQXFEO0lBQ3JELHNFQUFzRTtJQUN0RSxvRUFBb0U7SUFDcEUsK0VBQStFO0lBQy9FLE9BQU8sT0FBTyxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsSUFBUyxFQUFFLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDckYsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3NjYW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBzY2FuSW50ZXJuYWxzIH0gZnJvbSAnLi9zY2FuSW50ZXJuYWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNjYW48ViwgQSA9IFY+KGFjY3VtdWxhdG9yOiAoYWNjOiBBIHwgViwgdmFsdWU6IFYsIGluZGV4OiBudW1iZXIpID0+IEEpOiBPcGVyYXRvckZ1bmN0aW9uPFYsIFYgfCBBPjtcbmV4cG9ydCBmdW5jdGlvbiBzY2FuPFYsIEE+KGFjY3VtdWxhdG9yOiAoYWNjOiBBLCB2YWx1ZTogViwgaW5kZXg6IG51bWJlcikgPT4gQSwgc2VlZDogQSk6IE9wZXJhdG9yRnVuY3Rpb248ViwgQT47XG5leHBvcnQgZnVuY3Rpb24gc2NhbjxWLCBBLCBTPihhY2N1bXVsYXRvcjogKGFjYzogQSB8IFMsIHZhbHVlOiBWLCBpbmRleDogbnVtYmVyKSA9PiBBLCBzZWVkOiBTKTogT3BlcmF0b3JGdW5jdGlvbjxWLCBBPjtcblxuLy8gVE9ETzogbGluayB0byBhIFwicmVkdXggcGF0dGVyblwiIHNlY3Rpb24gaW4gdGhlIGd1aWRlIChsb2NhdGlvbiBUQkQpXG5cbi8qKlxuICogVXNlZnVsIGZvciBlbmNhcHN1bGF0aW5nIGFuZCBtYW5hZ2luZyBzdGF0ZS4gQXBwbGllcyBhbiBhY2N1bXVsYXRvciAob3IgXCJyZWR1Y2VyIGZ1bmN0aW9uXCIpXG4gKiB0byBlYWNoIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBhZnRlciBhbiBpbml0aWFsIHN0YXRlIGlzIGVzdGFibGlzaGVkIC0tIGVpdGhlciB2aWFcbiAqIGEgYHNlZWRgIHZhbHVlIChzZWNvbmQgYXJndW1lbnQpLCBvciBmcm9tIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgcmVkdWNlfSwgYnV0IGVtaXRzIHRoZSBjdXJyZW50XG4gKiBhY2N1bXVsYXRpb24gc3RhdGUgYWZ0ZXIgZWFjaCB1cGRhdGU8L3NwYW4+XG4gKlxuICogIVtdKHNjYW4ucG5nKVxuICpcbiAqIFRoaXMgb3BlcmF0b3IgbWFpbnRhaW5zIGFuIGludGVybmFsIHN0YXRlIGFuZCBlbWl0cyBpdCBhZnRlciBwcm9jZXNzaW5nIGVhY2ggdmFsdWUgYXMgZm9sbG93czpcbiAqXG4gKiAxLiBGaXJzdCB2YWx1ZSBhcnJpdmVzXG4gKiAgIC0gSWYgYSBgc2VlZGAgdmFsdWUgd2FzIHN1cHBsaWVkIChhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBzY2FuYCksIGxldCBgc3RhdGUgPSBzZWVkYCBhbmQgYHZhbHVlID0gZmlyc3RWYWx1ZWAuXG4gKiAgIC0gSWYgTk8gYHNlZWRgIHZhbHVlIHdhcyBzdXBwbGllZCAobm8gc2Vjb25kIGFyZ3VtZW50KSwgbGV0IGBzdGF0ZSA9IGZpcnN0VmFsdWVgIGFuZCBnbyB0byAzLlxuICogMi4gTGV0IGBzdGF0ZSA9IGFjY3VtdWxhdG9yKHN0YXRlLCB2YWx1ZSlgLlxuICogICAtIElmIGFuIGVycm9yIGlzIHRocm93biBieSBgYWNjdW11bGF0b3JgLCBub3RpZnkgdGhlIGNvbnN1bWVyIG9mIGFuIGVycm9yLiBUaGUgcHJvY2VzcyBlbmRzLlxuICogMy4gRW1pdCBgc3RhdGVgLlxuICogNC4gTmV4dCB2YWx1ZSBhcnJpdmVzLCBsZXQgYHZhbHVlID0gbmV4dFZhbHVlYCwgZ28gdG8gMi5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIEFuIGF2ZXJhZ2Ugb2YgcHJldmlvdXMgbnVtYmVycy4gVGhpcyBleGFtcGxlIHNob3dzIGhvd1xuICogbm90IHByb3ZpZGluZyBhIGBzZWVkYCBjYW4gcHJpbWUgdGhlIHN0cmVhbSB3aXRoIHRoZVxuICogZmlyc3QgdmFsdWUgZnJvbSB0aGUgc291cmNlLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBvZiwgc2NhbiwgbWFwIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgbnVtYmVycyQgPSBvZigxLCAyLCAzKTtcbiAqXG4gKiBudW1iZXJzJFxuICogICAucGlwZShcbiAqICAgICAvLyBHZXQgdGhlIHN1bSBvZiB0aGUgbnVtYmVycyBjb21pbmcgaW4uXG4gKiAgICAgc2NhbigodG90YWwsIG4pID0+IHRvdGFsICsgbiksXG4gKiAgICAgLy8gR2V0IHRoZSBhdmVyYWdlIGJ5IGRpdmlkaW5nIHRoZSBzdW0gYnkgdGhlIHRvdGFsIG51bWJlclxuICogICAgIC8vIHJlY2VpdmVkIHNvIGZhciAod2hpY2ggaXMgMSBtb3JlIHRoYW4gdGhlIHplcm8tYmFzZWQgaW5kZXgpLlxuICogICAgIG1hcCgoc3VtLCBpbmRleCkgPT4gc3VtIC8gKGluZGV4ICsgMSkpXG4gKiAgIClcbiAqICAgLnN1YnNjcmliZShjb25zb2xlLmxvZyk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgRmlib25hY2NpIHNlcXVlbmNlLiBUaGlzIGV4YW1wbGUgc2hvd3MgaG93IHlvdSBjYW4gdXNlXG4gKiBhIHNlZWQgdG8gcHJpbWUgYWNjdW11bGF0aW9uIHByb2Nlc3MuIEFsc28uLi4geW91IGtub3cuLi4gRmlib25hY2NpLlxuICogU28gaW1wb3J0YW50IHRvIGxpa2UsIGNvbXB1dGVycyBhbmQgc3R1ZmYgdGhhdCBpdHMgd2hpdGVib2FyZGVkXG4gKiBpbiBqb2IgaW50ZXJ2aWV3cy4gTm93IHlvdSBjYW4gc2hvdyB0aGVtIHRoZSBSeCB2ZXJzaW9uISAoUGxlYXNlIGRvbid0LCBoYWhhKVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpbnRlcnZhbCwgc2NhbiwgbWFwLCBzdGFydFdpdGggfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBmaXJzdFR3b0ZpYnMgPSBbMCwgMV07XG4gKiAvLyBBbiBlbmRsZXNzIHN0cmVhbSBvZiBGaWJvbmFjY2kgbnVtYmVycy5cbiAqIGNvbnN0IGZpYm9uYWNjaSQgPSBpbnRlcnZhbCgxMDAwKS5waXBlKFxuICogICAvLyBTY2FuIHRvIGdldCB0aGUgZmlib25hY2NpIG51bWJlcnMgKGFmdGVyIDAsIDEpXG4gKiAgIHNjYW4oKFthLCBiXSkgPT4gW2IsIGEgKyBiXSwgZmlyc3RUd29GaWJzKSxcbiAqICAgLy8gR2V0IHRoZSBzZWNvbmQgbnVtYmVyIGluIHRoZSB0dXBsZSwgaXQncyB0aGUgb25lIHlvdSBjYWxjdWxhdGVkXG4gKiAgIG1hcCgoWywgbl0pID0+IG4pLFxuICogICAvLyBTdGFydCB3aXRoIG91ciBmaXJzdCB0d28gZGlnaXRzIDopXG4gKiAgIHN0YXJ0V2l0aCguLi5maXJzdFR3b0ZpYnMpXG4gKiApO1xuICpcbiAqIGZpYm9uYWNjaSQuc3Vic2NyaWJlKGNvbnNvbGUubG9nKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGV4cGFuZH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHJlZHVjZX1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaFNjYW59XG4gKlxuICogQHBhcmFtIGFjY3VtdWxhdG9yIEEgXCJyZWR1Y2VyIGZ1bmN0aW9uXCIuIFRoaXMgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggdmFsdWUgYWZ0ZXIgYW4gaW5pdGlhbCBzdGF0ZSBpc1xuICogYWNxdWlyZWQuXG4gKiBAcGFyYW0gc2VlZCBUaGUgaW5pdGlhbCBzdGF0ZS4gSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQsIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2Ugd2lsbFxuICogYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCBzdGF0ZSwgYW5kIGVtaXR0ZWQgd2l0aG91dCBnb2luZyB0aHJvdWdoIHRoZSBhY2N1bXVsYXRvci4gQWxsIHN1YnNlcXVlbnQgdmFsdWVzXG4gKiB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGUgYWNjdW11bGF0b3IgZnVuY3Rpb24uIElmIHRoaXMgaXMgcHJvdmlkZWQsIGFsbCB2YWx1ZXMgd2lsbCBnbyB0aHJvdWdoXG4gKiB0aGUgYWNjdW11bGF0b3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgb2YgdGhlIGFjY3VtdWxhdGVkIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW48ViwgQSwgUz4oYWNjdW11bGF0b3I6IChhY2M6IFYgfCBBIHwgUywgdmFsdWU6IFYsIGluZGV4OiBudW1iZXIpID0+IEEsIHNlZWQ/OiBTKTogT3BlcmF0b3JGdW5jdGlvbjxWLCBWIHwgQT4ge1xuICAvLyBwcm92aWRpbmcgYSBzZWVkIG9mIGB1bmRlZmluZWRgICpzaG91bGQqIGJlIHZhbGlkIGFuZCB0cmlnZ2VyXG4gIC8vIGhhc1NlZWQhIHNvIGRvbid0IHVzZSBgc2VlZCAhPT0gdW5kZWZpbmVkYCBjaGVja3MhXG4gIC8vIEZvciB0aGlzIHJlYXNvbiwgd2UgaGF2ZSB0byBjaGVjayBpdCBoZXJlIGF0IHRoZSBvcmlnaW5hbCBjYWxsIHNpdGVcbiAgLy8gb3RoZXJ3aXNlIGluc2lkZSBPcGVyYXRvci9TdWJzY3JpYmVyIHdlIHdvbid0IGtub3cgaWYgYHVuZGVmaW5lZGBcbiAgLy8gbWVhbnMgdGhleSBkaWRuJ3QgcHJvdmlkZSBhbnl0aGluZyBvciBpZiB0aGV5IGxpdGVyYWxseSBwcm92aWRlZCBgdW5kZWZpbmVkYFxuICByZXR1cm4gb3BlcmF0ZShzY2FuSW50ZXJuYWxzKGFjY3VtdWxhdG9yLCBzZWVkIGFzIFMsIGFyZ3VtZW50cy5sZW5ndGggPj0gMiwgdHJ1ZSkpO1xufVxuIl19
