import { switchMap } from './switchMap.mjs';
import { identity } from '../util/identity.mjs';
/**
 * Converts a higher-order Observable into a first-order Observable
 * producing values only from the most recent observable sequence
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * ![](switchAll.png)
 *
 * `switchAll` subscribes to a source that is an observable of observables, also known as a
 * "higher-order observable" (or `Observable<Observable<T>>`). It subscribes to the most recently
 * provided "inner observable" emitted by the source, unsubscribing from any previously subscribed
 * to inner observable, such that only the most recent inner observable may be subscribed to at
 * any point in time. The resulting observable returned by `switchAll` will only complete if the
 * source observable completes, *and* any currently subscribed to inner observable also has completed,
 * if there are any.
 *
 * ## Examples
 *
 * Spawn a new interval observable for each click event, but for every new
 * click, cancel the previous interval and subscribe to the new one
 *
 * ```ts
 * import { fromEvent, tap, map, interval, switchAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click').pipe(tap(() => console.log('click')));
 * const source = clicks.pipe(map(() => interval(1000)));
 *
 * source
 *   .pipe(switchAll())
 *   .subscribe(x => console.log(x));
 *
 * // Output
 * // click
 * // 0
 * // 1
 * // 2
 * // 3
 * // ...
 * // click
 * // 0
 * // 1
 * // 2
 * // ...
 * // click
 * // ...
 * ```
 *
 * @see {@link combineLatestAll}
 * @see {@link concatAll}
 * @see {@link exhaustAll}
 * @see {@link switchMap}
 * @see {@link switchMapTo}
 * @see {@link mergeAll}
 *
 * @return A function that returns an Observable that converts a higher-order
 * Observable into a first-order Observable producing values only from the most
 * recent Observable sequence.
 */
export function switchAll() {
    return switchMap(identity);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoQWxsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5REc7QUFDSCxNQUFNLFVBQVUsU0FBUztJQUN2QixPQUFPLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM3QixDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoQWxsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3BlcmF0b3JGdW5jdGlvbiwgT2JzZXJ2YWJsZUlucHV0LCBPYnNlcnZlZFZhbHVlT2YgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAgfSBmcm9tICcuL3N3aXRjaE1hcCc7XG5pbXBvcnQgeyBpZGVudGl0eSB9IGZyb20gJy4uL3V0aWwvaWRlbnRpdHknO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGVcbiAqIHByb2R1Y2luZyB2YWx1ZXMgb25seSBmcm9tIHRoZSBtb3N0IHJlY2VudCBvYnNlcnZhYmxlIHNlcXVlbmNlXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMuPC9zcGFuPlxuICpcbiAqICFbXShzd2l0Y2hBbGwucG5nKVxuICpcbiAqIGBzd2l0Y2hBbGxgIHN1YnNjcmliZXMgdG8gYSBzb3VyY2UgdGhhdCBpcyBhbiBvYnNlcnZhYmxlIG9mIG9ic2VydmFibGVzLCBhbHNvIGtub3duIGFzIGFcbiAqIFwiaGlnaGVyLW9yZGVyIG9ic2VydmFibGVcIiAob3IgYE9ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj5gKS4gSXQgc3Vic2NyaWJlcyB0byB0aGUgbW9zdCByZWNlbnRseVxuICogcHJvdmlkZWQgXCJpbm5lciBvYnNlcnZhYmxlXCIgZW1pdHRlZCBieSB0aGUgc291cmNlLCB1bnN1YnNjcmliaW5nIGZyb20gYW55IHByZXZpb3VzbHkgc3Vic2NyaWJlZFxuICogdG8gaW5uZXIgb2JzZXJ2YWJsZSwgc3VjaCB0aGF0IG9ubHkgdGhlIG1vc3QgcmVjZW50IGlubmVyIG9ic2VydmFibGUgbWF5IGJlIHN1YnNjcmliZWQgdG8gYXRcbiAqIGFueSBwb2ludCBpbiB0aW1lLiBUaGUgcmVzdWx0aW5nIG9ic2VydmFibGUgcmV0dXJuZWQgYnkgYHN3aXRjaEFsbGAgd2lsbCBvbmx5IGNvbXBsZXRlIGlmIHRoZVxuICogc291cmNlIG9ic2VydmFibGUgY29tcGxldGVzLCAqYW5kKiBhbnkgY3VycmVudGx5IHN1YnNjcmliZWQgdG8gaW5uZXIgb2JzZXJ2YWJsZSBhbHNvIGhhcyBjb21wbGV0ZWQsXG4gKiBpZiB0aGVyZSBhcmUgYW55LlxuICpcbiAqICMjIEV4YW1wbGVzXG4gKlxuICogU3Bhd24gYSBuZXcgaW50ZXJ2YWwgb2JzZXJ2YWJsZSBmb3IgZWFjaCBjbGljayBldmVudCwgYnV0IGZvciBldmVyeSBuZXdcbiAqIGNsaWNrLCBjYW5jZWwgdGhlIHByZXZpb3VzIGludGVydmFsIGFuZCBzdWJzY3JpYmUgdG8gdGhlIG5ldyBvbmVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50LCB0YXAsIG1hcCwgaW50ZXJ2YWwsIHN3aXRjaEFsbCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IGNsaWNrcyA9IGZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJykucGlwZSh0YXAoKCkgPT4gY29uc29sZS5sb2coJ2NsaWNrJykpKTtcbiAqIGNvbnN0IHNvdXJjZSA9IGNsaWNrcy5waXBlKG1hcCgoKSA9PiBpbnRlcnZhbCgxMDAwKSkpO1xuICpcbiAqIHNvdXJjZVxuICogICAucGlwZShzd2l0Y2hBbGwoKSlcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBPdXRwdXRcbiAqIC8vIGNsaWNrXG4gKiAvLyAwXG4gKiAvLyAxXG4gKiAvLyAyXG4gKiAvLyAzXG4gKiAvLyAuLi5cbiAqIC8vIGNsaWNrXG4gKiAvLyAwXG4gKiAvLyAxXG4gKiAvLyAyXG4gKiAvLyAuLi5cbiAqIC8vIGNsaWNrXG4gKiAvLyAuLi5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVMYXRlc3RBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0QWxsfVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwfVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBjb252ZXJ0cyBhIGhpZ2hlci1vcmRlclxuICogT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBwcm9kdWNpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdFxuICogcmVjZW50IE9ic2VydmFibGUgc2VxdWVuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzd2l0Y2hBbGw8TyBleHRlbmRzIE9ic2VydmFibGVJbnB1dDxhbnk+PigpOiBPcGVyYXRvckZ1bmN0aW9uPE8sIE9ic2VydmVkVmFsdWVPZjxPPj4ge1xuICByZXR1cm4gc3dpdGNoTWFwKGlkZW50aXR5KTtcbn1cbiJdfQ==
