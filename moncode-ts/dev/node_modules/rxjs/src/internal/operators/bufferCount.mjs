import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { arrRemove } from '../util/arrRemove.mjs';
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * ![](bufferCount.png)
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * ## Examples
 *
 * Emit the last two click events as an array
 *
 * ```ts
 * import { fromEvent, bufferCount } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const buffered = clicks.pipe(bufferCount(2));
 * buffered.subscribe(x => console.log(x));
 * ```
 *
 * On every click, emit the last two click events as an array
 *
 * ```ts
 * import { fromEvent, bufferCount } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const buffered = clicks.pipe(bufferCount(2, 1));
 * buffered.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link pairwise}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return A function that returns an Observable of arrays of buffered values.
 */
export function bufferCount(bufferSize, startBufferEvery = null) {
    // If no `startBufferEvery` value was supplied, then we're
    // opening and closing on the bufferSize itself.
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
    return operate((source, subscriber) => {
        let buffers = [];
        let count = 0;
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            let toEmit = null;
            // Check to see if we need to start a buffer.
            // This will start one at the first value, and then
            // a new one every N after that.
            if (count++ % startBufferEvery === 0) {
                buffers.push([]);
            }
            // Push our value into our active buffers.
            for (const buffer of buffers) {
                buffer.push(value);
                // Check to see if we're over the bufferSize
                // if we are, record it so we can emit it later.
                // If we emitted it now and removed it, it would
                // mutate the `buffers` array while we're looping
                // over it.
                if (bufferSize <= buffer.length) {
                    toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                    toEmit.push(buffer);
                }
            }
            if (toEmit) {
                // We have found some buffers that are over the
                // `bufferSize`. Emit them, and remove them from our
                // buffers list.
                for (const buffer of toEmit) {
                    arrRemove(buffers, buffer);
                    subscriber.next(buffer);
                }
            }
        }, () => {
            // When the source completes, emit all of our
            // active buffers.
            for (const buffer of buffers) {
                subscriber.next(buffer);
            }
            subscriber.complete();
        }, 
        // Pass all errors through to consumer.
        undefined, () => {
            // Clean up our memory when we finalize
            buffers = null;
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyQ291bnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFOUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0RHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBSSxVQUFrQixFQUFFLG1CQUFrQyxJQUFJO0lBQ3ZGLDBEQUEwRDtJQUMxRCxnREFBZ0Q7SUFDaEQsZ0JBQWdCLEdBQUcsZ0JBQWdCLGFBQWhCLGdCQUFnQixjQUFoQixnQkFBZ0IsR0FBSSxVQUFVLENBQUM7SUFFbEQsT0FBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDcEMsSUFBSSxPQUFPLEdBQVUsRUFBRSxDQUFDO1FBQ3hCLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztRQUVkLE1BQU0sQ0FBQyxTQUFTLENBQ2Qsd0JBQXdCLENBQ3RCLFVBQVUsRUFDVixDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ1IsSUFBSSxNQUFNLEdBQWlCLElBQUksQ0FBQztZQUVoQyw2Q0FBNkM7WUFDN0MsbURBQW1EO1lBQ25ELGdDQUFnQztZQUNoQyxJQUFJLEtBQUssRUFBRSxHQUFHLGdCQUFpQixLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUN0QyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ25CLENBQUM7WUFFRCwwQ0FBMEM7WUFDMUMsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUUsQ0FBQztnQkFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDbkIsNENBQTRDO2dCQUM1QyxnREFBZ0Q7Z0JBQ2hELGdEQUFnRDtnQkFDaEQsaURBQWlEO2dCQUNqRCxXQUFXO2dCQUNYLElBQUksVUFBVSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztvQkFDaEMsTUFBTSxHQUFHLE1BQU0sYUFBTixNQUFNLGNBQU4sTUFBTSxHQUFJLEVBQUUsQ0FBQztvQkFDdEIsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDdEIsQ0FBQztZQUNILENBQUM7WUFFRCxJQUFJLE1BQU0sRUFBRSxDQUFDO2dCQUNYLCtDQUErQztnQkFDL0Msb0RBQW9EO2dCQUNwRCxnQkFBZ0I7Z0JBQ2hCLEtBQUssTUFBTSxNQUFNLElBQUksTUFBTSxFQUFFLENBQUM7b0JBQzVCLFNBQVMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7b0JBQzNCLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzFCLENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQyxFQUNELEdBQUcsRUFBRTtZQUNILDZDQUE2QztZQUM3QyxrQkFBa0I7WUFDbEIsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUUsQ0FBQztnQkFDN0IsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMxQixDQUFDO1lBQ0QsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3hCLENBQUM7UUFDRCx1Q0FBdUM7UUFDdkMsU0FBUyxFQUNULEdBQUcsRUFBRTtZQUNILHVDQUF1QztZQUN2QyxPQUFPLEdBQUcsSUFBSyxDQUFDO1FBQ2xCLENBQUMsQ0FDRixDQUNGLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJDb3VudC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wZXJhdG9yRnVuY3Rpb24gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IGFyclJlbW92ZSB9IGZyb20gJy4uL3V0aWwvYXJyUmVtb3ZlJztcblxuLyoqXG4gKiBCdWZmZXJzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgdW50aWwgdGhlIHNpemUgaGl0cyB0aGUgbWF4aW11bVxuICogYGJ1ZmZlclNpemVgIGdpdmVuLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheSwgYW5kIGVtaXRzXG4gKiB0aGF0IGFycmF5IG9ubHkgd2hlbiBpdHMgc2l6ZSByZWFjaGVzIGBidWZmZXJTaXplYC48L3NwYW4+XG4gKlxuICogIVtdKGJ1ZmZlckNvdW50LnBuZylcbiAqXG4gKiBCdWZmZXJzIGEgbnVtYmVyIG9mIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBgYnVmZmVyU2l6ZWAgdGhlblxuICogZW1pdHMgdGhlIGJ1ZmZlciBhbmQgY2xlYXJzIGl0LCBhbmQgc3RhcnRzIGEgbmV3IGJ1ZmZlciBlYWNoXG4gKiBgc3RhcnRCdWZmZXJFdmVyeWAgdmFsdWVzLiBJZiBgc3RhcnRCdWZmZXJFdmVyeWAgaXMgbm90IHByb3ZpZGVkIG9yIGlzXG4gKiBgbnVsbGAsIHRoZW4gbmV3IGJ1ZmZlcnMgYXJlIHN0YXJ0ZWQgaW1tZWRpYXRlbHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2VcbiAqIGFuZCB3aGVuIGVhY2ggYnVmZmVyIGNsb3NlcyBhbmQgaXMgZW1pdHRlZC5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIEVtaXQgdGhlIGxhc3QgdHdvIGNsaWNrIGV2ZW50cyBhcyBhbiBhcnJheVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIGJ1ZmZlckNvdW50IH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IGJ1ZmZlcmVkID0gY2xpY2tzLnBpcGUoYnVmZmVyQ291bnQoMikpO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogYGBgXG4gKlxuICogT24gZXZlcnkgY2xpY2ssIGVtaXQgdGhlIGxhc3QgdHdvIGNsaWNrIGV2ZW50cyBhcyBhbiBhcnJheVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIGJ1ZmZlckNvdW50IH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IGJ1ZmZlcmVkID0gY2xpY2tzLnBpcGUoYnVmZmVyQ291bnQoMiwgMSkpO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayBwYWlyd2lzZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJTaXplIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIGJ1ZmZlciBlbWl0dGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydEJ1ZmZlckV2ZXJ5XSBJbnRlcnZhbCBhdCB3aGljaCB0byBzdGFydCBhIG5ldyBidWZmZXIuXG4gKiBGb3IgZXhhbXBsZSBpZiBgc3RhcnRCdWZmZXJFdmVyeWAgaXMgYDJgLCB0aGVuIGEgbmV3IGJ1ZmZlciB3aWxsIGJlIHN0YXJ0ZWRcbiAqIG9uIGV2ZXJ5IG90aGVyIHZhbHVlIGZyb20gdGhlIHNvdXJjZS4gQSBuZXcgYnVmZmVyIGlzIHN0YXJ0ZWQgYXQgdGhlXG4gKiBiZWdpbm5pbmcgb2YgdGhlIHNvdXJjZSBieSBkZWZhdWx0LlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIG9mIGFycmF5cyBvZiBidWZmZXJlZCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJDb3VudDxUPihidWZmZXJTaXplOiBudW1iZXIsIHN0YXJ0QnVmZmVyRXZlcnk6IG51bWJlciB8IG51bGwgPSBudWxsKTogT3BlcmF0b3JGdW5jdGlvbjxULCBUW10+IHtcbiAgLy8gSWYgbm8gYHN0YXJ0QnVmZmVyRXZlcnlgIHZhbHVlIHdhcyBzdXBwbGllZCwgdGhlbiB3ZSdyZVxuICAvLyBvcGVuaW5nIGFuZCBjbG9zaW5nIG9uIHRoZSBidWZmZXJTaXplIGl0c2VsZi5cbiAgc3RhcnRCdWZmZXJFdmVyeSA9IHN0YXJ0QnVmZmVyRXZlcnkgPz8gYnVmZmVyU2l6ZTtcblxuICByZXR1cm4gb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgbGV0IGJ1ZmZlcnM6IFRbXVtdID0gW107XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoXG4gICAgICAgIHN1YnNjcmliZXIsXG4gICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxldCB0b0VtaXQ6IFRbXVtdIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byBzdGFydCBhIGJ1ZmZlci5cbiAgICAgICAgICAvLyBUaGlzIHdpbGwgc3RhcnQgb25lIGF0IHRoZSBmaXJzdCB2YWx1ZSwgYW5kIHRoZW5cbiAgICAgICAgICAvLyBhIG5ldyBvbmUgZXZlcnkgTiBhZnRlciB0aGF0LlxuICAgICAgICAgIGlmIChjb3VudCsrICUgc3RhcnRCdWZmZXJFdmVyeSEgPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHVzaCBvdXIgdmFsdWUgaW50byBvdXIgYWN0aXZlIGJ1ZmZlcnMuXG4gICAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICAgICAgYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlJ3JlIG92ZXIgdGhlIGJ1ZmZlclNpemVcbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSwgcmVjb3JkIGl0IHNvIHdlIGNhbiBlbWl0IGl0IGxhdGVyLlxuICAgICAgICAgICAgLy8gSWYgd2UgZW1pdHRlZCBpdCBub3cgYW5kIHJlbW92ZWQgaXQsIGl0IHdvdWxkXG4gICAgICAgICAgICAvLyBtdXRhdGUgdGhlIGBidWZmZXJzYCBhcnJheSB3aGlsZSB3ZSdyZSBsb29waW5nXG4gICAgICAgICAgICAvLyBvdmVyIGl0LlxuICAgICAgICAgICAgaWYgKGJ1ZmZlclNpemUgPD0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0b0VtaXQgPSB0b0VtaXQgPz8gW107XG4gICAgICAgICAgICAgIHRvRW1pdC5wdXNoKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRvRW1pdCkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCBzb21lIGJ1ZmZlcnMgdGhhdCBhcmUgb3ZlciB0aGVcbiAgICAgICAgICAgIC8vIGBidWZmZXJTaXplYC4gRW1pdCB0aGVtLCBhbmQgcmVtb3ZlIHRoZW0gZnJvbSBvdXJcbiAgICAgICAgICAgIC8vIGJ1ZmZlcnMgbGlzdC5cbiAgICAgICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHRvRW1pdCkge1xuICAgICAgICAgICAgICBhcnJSZW1vdmUoYnVmZmVycywgYnVmZmVyKTtcbiAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gV2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcywgZW1pdCBhbGwgb2Ygb3VyXG4gICAgICAgICAgLy8gYWN0aXZlIGJ1ZmZlcnMuXG4gICAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGFzcyBhbGwgZXJyb3JzIHRocm91Z2ggdG8gY29uc3VtZXIuXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIENsZWFuIHVwIG91ciBtZW1vcnkgd2hlbiB3ZSBmaW5hbGl6ZVxuICAgICAgICAgIGJ1ZmZlcnMgPSBudWxsITtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH0pO1xufVxuIl19
