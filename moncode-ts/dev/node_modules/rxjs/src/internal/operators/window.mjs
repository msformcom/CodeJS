import { Subject } from '../Subject.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { noop } from '../util/noop.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
/**
 * Branch out the source Observable values as a nested Observable whenever
 * `windowBoundaries` emits.
 *
 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
 * instead of an array.</span>
 *
 * ![](window.png)
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping
 * windows. It emits the current window and opens a new one whenever the
 * `windowBoundaries` emits an item. `windowBoundaries` can be any type that
 * `ObservableInput` accepts. It internally gets converted to an Observable.
 * Because each window is an Observable, the output is a higher-order Observable.
 *
 * ## Example
 *
 * In every window of 1 second each, emit at most 2 click events
 *
 * ```ts
 * import { fromEvent, interval, window, map, take, mergeAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const sec = interval(1000);
 * const result = clicks.pipe(
 *   window(sec),
 *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window
 *   mergeAll()                     // flatten the Observable-of-Observables
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link buffer}
 *
 * @param windowBoundaries An `ObservableInput` that completes the
 * previous window and starts a new window.
 * @return A function that returns an Observable of windows, which are
 * Observables emitting values of the source Observable.
 */
export function window(windowBoundaries) {
    return operate((source, subscriber) => {
        let windowSubject = new Subject();
        subscriber.next(windowSubject.asObservable());
        const errorHandler = (err) => {
            windowSubject.error(err);
            subscriber.error(err);
        };
        // Subscribe to our source
        source.subscribe(createOperatorSubscriber(subscriber, (value) => windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value), () => {
            windowSubject.complete();
            subscriber.complete();
        }, errorHandler));
        // Subscribe to the window boundaries.
        innerFrom(windowBoundaries).subscribe(createOperatorSubscriber(subscriber, () => {
            windowSubject.complete();
            subscriber.next((windowSubject = new Subject()));
        }, noop, errorHandler));
        return () => {
            // Unsubscribing the subject ensures that anyone who has captured
            // a reference to this window that tries to use it after it can
            // no longer get values from the source will get an ObjectUnsubscribedError.
            windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
            windowSubject = null;
        };
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDckMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUVwRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJDRztBQUNILE1BQU0sVUFBVSxNQUFNLENBQUksZ0JBQXNDO0lBQzlELE9BQU8sT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxFQUFFO1FBQ3BDLElBQUksYUFBYSxHQUFlLElBQUksT0FBTyxFQUFLLENBQUM7UUFFakQsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztRQUU5QyxNQUFNLFlBQVksR0FBRyxDQUFDLEdBQVEsRUFBRSxFQUFFO1lBQ2hDLGFBQWEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDekIsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4QixDQUFDLENBQUM7UUFFRiwwQkFBMEI7UUFDMUIsTUFBTSxDQUFDLFNBQVMsQ0FDZCx3QkFBd0IsQ0FDdEIsVUFBVSxFQUNWLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxhQUFhLGFBQWIsYUFBYSx1QkFBYixhQUFhLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUNyQyxHQUFHLEVBQUU7WUFDSCxhQUFhLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDekIsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3hCLENBQUMsRUFDRCxZQUFZLENBQ2IsQ0FDRixDQUFDO1FBRUYsc0NBQXNDO1FBQ3RDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLFNBQVMsQ0FDbkMsd0JBQXdCLENBQ3RCLFVBQVUsRUFDVixHQUFHLEVBQUU7WUFDSCxhQUFhLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDekIsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLGFBQWEsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNuRCxDQUFDLEVBQ0QsSUFBSSxFQUNKLFlBQVksQ0FDYixDQUNGLENBQUM7UUFFRixPQUFPLEdBQUcsRUFBRTtZQUNWLGlFQUFpRTtZQUNqRSwrREFBK0Q7WUFDL0QsNEVBQTRFO1lBQzVFLGFBQWEsYUFBYixhQUFhLHVCQUFiLGFBQWEsQ0FBRSxXQUFXLEVBQUUsQ0FBQztZQUM3QixhQUFhLEdBQUcsSUFBSyxDQUFDO1FBQ3hCLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvdy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWwvbm9vcCc7XG5pbXBvcnQgeyBpbm5lckZyb20gfSBmcm9tICcuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSc7XG5cbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgd2hlbmV2ZXJcbiAqIGB3aW5kb3dCb3VuZGFyaWVzYCBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBidWZmZXJ9LCBidXQgZW1pdHMgYSBuZXN0ZWQgT2JzZXJ2YWJsZVxuICogaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogIVtdKHdpbmRvdy5wbmcpXG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyBjb25uZWN0ZWQsIG5vbi1vdmVybGFwcGluZ1xuICogd2luZG93cy4gSXQgZW1pdHMgdGhlIGN1cnJlbnQgd2luZG93IGFuZCBvcGVucyBhIG5ldyBvbmUgd2hlbmV2ZXIgdGhlXG4gKiBgd2luZG93Qm91bmRhcmllc2AgZW1pdHMgYW4gaXRlbS4gYHdpbmRvd0JvdW5kYXJpZXNgIGNhbiBiZSBhbnkgdHlwZSB0aGF0XG4gKiBgT2JzZXJ2YWJsZUlucHV0YCBhY2NlcHRzLiBJdCBpbnRlcm5hbGx5IGdldHMgY29udmVydGVkIHRvIGFuIE9ic2VydmFibGUuXG4gKiBCZWNhdXNlIGVhY2ggd2luZG93IGlzIGFuIE9ic2VydmFibGUsIHRoZSBvdXRwdXQgaXMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogSW4gZXZlcnkgd2luZG93IG9mIDEgc2Vjb25kIGVhY2gsIGVtaXQgYXQgbW9zdCAyIGNsaWNrIGV2ZW50c1xuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIGludGVydmFsLCB3aW5kb3csIG1hcCwgdGFrZSwgbWVyZ2VBbGwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBjbGlja3MgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogY29uc3Qgc2VjID0gaW50ZXJ2YWwoMTAwMCk7XG4gKiBjb25zdCByZXN1bHQgPSBjbGlja3MucGlwZShcbiAqICAgd2luZG93KHNlYyksXG4gKiAgIG1hcCh3aW4gPT4gd2luLnBpcGUodGFrZSgyKSkpLCAvLyB0YWtlIGF0IG1vc3QgMiBlbWlzc2lvbnMgZnJvbSBlYWNoIHdpbmRvd1xuICogICBtZXJnZUFsbCgpICAgICAgICAgICAgICAgICAgICAgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayB3aW5kb3dDb3VudH1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICpcbiAqIEBwYXJhbSB3aW5kb3dCb3VuZGFyaWVzIEFuIGBPYnNlcnZhYmxlSW5wdXRgIHRoYXQgY29tcGxldGVzIHRoZVxuICogcHJldmlvdXMgd2luZG93IGFuZCBzdGFydHMgYSBuZXcgd2luZG93LlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGFyZVxuICogT2JzZXJ2YWJsZXMgZW1pdHRpbmcgdmFsdWVzIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpbmRvdzxUPih3aW5kb3dCb3VuZGFyaWVzOiBPYnNlcnZhYmxlSW5wdXQ8YW55Pik6IE9wZXJhdG9yRnVuY3Rpb248VCwgT2JzZXJ2YWJsZTxUPj4ge1xuICByZXR1cm4gb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgbGV0IHdpbmRvd1N1YmplY3Q6IFN1YmplY3Q8VD4gPSBuZXcgU3ViamVjdDxUPigpO1xuXG4gICAgc3Vic2NyaWJlci5uZXh0KHdpbmRvd1N1YmplY3QuYXNPYnNlcnZhYmxlKCkpO1xuXG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGVycjogYW55KSA9PiB7XG4gICAgICB3aW5kb3dTdWJqZWN0LmVycm9yKGVycik7XG4gICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgfTtcblxuICAgIC8vIFN1YnNjcmliZSB0byBvdXIgc291cmNlXG4gICAgc291cmNlLnN1YnNjcmliZShcbiAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgKHZhbHVlKSA9PiB3aW5kb3dTdWJqZWN0Py5uZXh0KHZhbHVlKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHdpbmRvd1N1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9ySGFuZGxlclxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHdpbmRvdyBib3VuZGFyaWVzLlxuICAgIGlubmVyRnJvbSh3aW5kb3dCb3VuZGFyaWVzKS5zdWJzY3JpYmUoXG4gICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoXG4gICAgICAgIHN1YnNjcmliZXIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB3aW5kb3dTdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgc3Vic2NyaWJlci5uZXh0KCh3aW5kb3dTdWJqZWN0ID0gbmV3IFN1YmplY3QoKSkpO1xuICAgICAgICB9LFxuICAgICAgICBub29wLFxuICAgICAgICBlcnJvckhhbmRsZXJcbiAgICAgIClcbiAgICApO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIFVuc3Vic2NyaWJpbmcgdGhlIHN1YmplY3QgZW5zdXJlcyB0aGF0IGFueW9uZSB3aG8gaGFzIGNhcHR1cmVkXG4gICAgICAvLyBhIHJlZmVyZW5jZSB0byB0aGlzIHdpbmRvdyB0aGF0IHRyaWVzIHRvIHVzZSBpdCBhZnRlciBpdCBjYW5cbiAgICAgIC8vIG5vIGxvbmdlciBnZXQgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSB3aWxsIGdldCBhbiBPYmplY3RVbnN1YnNjcmliZWRFcnJvci5cbiAgICAgIHdpbmRvd1N1YmplY3Q/LnVuc3Vic2NyaWJlKCk7XG4gICAgICB3aW5kb3dTdWJqZWN0ID0gbnVsbCE7XG4gICAgfTtcbiAgfSk7XG59XG4iXX0=
