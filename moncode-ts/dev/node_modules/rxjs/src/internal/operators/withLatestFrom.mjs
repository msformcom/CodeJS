import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
import { identity } from '../util/identity.mjs';
import { noop } from '../util/noop.mjs';
import { popResultSelector } from '../util/args.mjs';
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * ![](withLatestFrom.png)
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * ## Example
 *
 * On every click event, emit an array with the latest timer event plus the click event
 *
 * ```ts
 * import { fromEvent, interval, withLatestFrom } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const timer = interval(1000);
 * const result = clicks.pipe(withLatestFrom(timer));
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return A function that returns an Observable of projected values from the
 * most recent values from each input Observable, or an array of the most
 * recent values from each input Observable.
 */
export function withLatestFrom(...inputs) {
    const project = popResultSelector(inputs);
    return operate((source, subscriber) => {
        const len = inputs.length;
        const otherValues = new Array(len);
        // An array of whether or not the other sources have emitted. Matched with them by index.
        // TODO: At somepoint, we should investigate the performance implications here, and look
        // into using a `Set()` and checking the `size` to see if we're ready.
        let hasValue = inputs.map(() => false);
        // Flipped true when we have at least one value from all other sources and
        // we are ready to start emitting values.
        let ready = false;
        // Other sources. Note that here we are not checking `subscriber.closed`,
        // this causes all inputs to be subscribed to, even if nothing can be emitted
        // from them. This is an important distinction because subscription constitutes
        // a side-effect.
        for (let i = 0; i < len; i++) {
            innerFrom(inputs[i]).subscribe(createOperatorSubscriber(subscriber, (value) => {
                otherValues[i] = value;
                if (!ready && !hasValue[i]) {
                    // If we're not ready yet, flag to show this observable has emitted.
                    hasValue[i] = true;
                    // Intentionally terse code.
                    // If all of our other observables have emitted, set `ready` to `true`,
                    // so we know we can start emitting values, then clean up the `hasValue` array,
                    // because we don't need it anymore.
                    (ready = hasValue.every(identity)) && (hasValue = null);
                }
            }, 
            // Completing one of the other sources has
            // no bearing on the completion of our result.
            noop));
        }
        // Source subscription
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            if (ready) {
                // We have at least one value from the other sources. Go ahead and emit.
                const values = [value, ...otherValues];
                subscriber.next(project ? project(...values) : values);
            }
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvd2l0aExhdGVzdEZyb20udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDcEMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBUWpEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EwQ0c7QUFDSCxNQUFNLFVBQVUsY0FBYyxDQUFPLEdBQUcsTUFBYTtJQUNuRCxNQUFNLE9BQU8sR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQXdDLENBQUM7SUFFakYsT0FBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDcEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUMxQixNQUFNLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNuQyx5RkFBeUY7UUFDekYsd0ZBQXdGO1FBQ3hGLHNFQUFzRTtRQUN0RSxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3ZDLDBFQUEwRTtRQUMxRSx5Q0FBeUM7UUFDekMsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBRWxCLHlFQUF5RTtRQUN6RSw2RUFBNkU7UUFDN0UsK0VBQStFO1FBQy9FLGlCQUFpQjtRQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDN0IsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FDNUIsd0JBQXdCLENBQ3RCLFVBQVUsRUFDVixDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUNSLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztvQkFDM0Isb0VBQW9FO29CQUNwRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO29CQUNuQiw0QkFBNEI7b0JBQzVCLHVFQUF1RTtvQkFDdkUsK0VBQStFO29CQUMvRSxvQ0FBb0M7b0JBQ3BDLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFLLENBQUMsQ0FBQztnQkFDM0QsQ0FBQztZQUNILENBQUM7WUFDRCwwQ0FBMEM7WUFDMUMsOENBQThDO1lBQzlDLElBQUksQ0FDTCxDQUNGLENBQUM7UUFDSixDQUFDO1FBRUQsc0JBQXNCO1FBQ3RCLE1BQU0sQ0FBQyxTQUFTLENBQ2Qsd0JBQXdCLENBQUMsVUFBVSxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDN0MsSUFBSSxLQUFLLEVBQUUsQ0FBQztnQkFDVix3RUFBd0U7Z0JBQ3hFLE1BQU0sTUFBTSxHQUFHLENBQUMsS0FBSyxFQUFFLEdBQUcsV0FBVyxDQUFDLENBQUM7Z0JBQ3ZDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDekQsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy93aXRoTGF0ZXN0RnJvbS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGVJbnB1dFR1cGxlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBpbm5lckZyb20gfSBmcm9tICcuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSc7XG5pbXBvcnQgeyBpZGVudGl0eSB9IGZyb20gJy4uL3V0aWwvaWRlbnRpdHknO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWwvbm9vcCc7XG5pbXBvcnQgeyBwb3BSZXN1bHRTZWxlY3RvciB9IGZyb20gJy4uL3V0aWwvYXJncyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbTxULCBPIGV4dGVuZHMgdW5rbm93bltdPiguLi5pbnB1dHM6IFsuLi5PYnNlcnZhYmxlSW5wdXRUdXBsZTxPPl0pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFtULCAuLi5PXT47XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbTxULCBPIGV4dGVuZHMgdW5rbm93bltdLCBSPihcbiAgLi4uaW5wdXRzOiBbLi4uT2JzZXJ2YWJsZUlucHV0VHVwbGU8Tz4sICguLi52YWx1ZTogW1QsIC4uLk9dKSA9PiBSXVxuKTogT3BlcmF0b3JGdW5jdGlvbjxULCBSPjtcblxuLyoqXG4gKiBDb21iaW5lcyB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBvdGhlciBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZVxuICogd2hvc2UgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIGxhdGVzdCB2YWx1ZXMgb2YgZWFjaCwgb25seSB3aGVuIHRoZVxuICogc291cmNlIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XaGVuZXZlciB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgaXRcbiAqIGNvbXB1dGVzIGEgZm9ybXVsYSB1c2luZyB0aGF0IHZhbHVlIHBsdXMgdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBvdGhlciBpbnB1dFxuICogT2JzZXJ2YWJsZXMsIHRoZW4gZW1pdHMgdGhlIG91dHB1dCBvZiB0aGF0IGZvcm11bGEuPC9zcGFuPlxuICpcbiAqICFbXSh3aXRoTGF0ZXN0RnJvbS5wbmcpXG4gKlxuICogYHdpdGhMYXRlc3RGcm9tYCBjb21iaW5lcyBlYWNoIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlICh0aGVcbiAqIGluc3RhbmNlKSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gdGhlIG90aGVyIGlucHV0IE9ic2VydmFibGVzIG9ubHkgd2hlblxuICogdGhlIHNvdXJjZSBlbWl0cyBhIHZhbHVlLCBvcHRpb25hbGx5IHVzaW5nIGEgYHByb2plY3RgIGZ1bmN0aW9uIHRvIGRldGVybWluZVxuICogdGhlIHZhbHVlIHRvIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBBbGwgaW5wdXQgT2JzZXJ2YWJsZXMgbXVzdFxuICogZW1pdCBhdCBsZWFzdCBvbmUgdmFsdWUgYmVmb3JlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgYSB2YWx1ZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogT24gZXZlcnkgY2xpY2sgZXZlbnQsIGVtaXQgYW4gYXJyYXkgd2l0aCB0aGUgbGF0ZXN0IHRpbWVyIGV2ZW50IHBsdXMgdGhlIGNsaWNrIGV2ZW50XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21FdmVudCwgaW50ZXJ2YWwsIHdpdGhMYXRlc3RGcm9tIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IHRpbWVyID0gaW50ZXJ2YWwoMTAwMCk7XG4gKiBjb25zdCByZXN1bHQgPSBjbGlja3MucGlwZSh3aXRoTGF0ZXN0RnJvbSh0aW1lcikpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVMYXRlc3R9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IG90aGVyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29tYmluZSB3aXRoIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb2plY3RdIFByb2plY3Rpb24gZnVuY3Rpb24gZm9yIGNvbWJpbmluZyB2YWx1ZXNcbiAqIHRvZ2V0aGVyLiBSZWNlaXZlcyBhbGwgdmFsdWVzIGluIG9yZGVyIG9mIHRoZSBPYnNlcnZhYmxlcyBwYXNzZWQsIHdoZXJlIHRoZVxuICogZmlyc3QgcGFyYW1ldGVyIGlzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuIChlLmcuXG4gKiBgYS5waXBlKHdpdGhMYXRlc3RGcm9tKGIsIGMpLCBtYXAoKFthMSwgYjEsIGMxXSkgPT4gYTEgKyBiMSArIGMxKSlgKS4gSWYgdGhpcyBpcyBub3RcbiAqIHBhc3NlZCwgYXJyYXlzIHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgb2YgcHJvamVjdGVkIHZhbHVlcyBmcm9tIHRoZVxuICogbW9zdCByZWNlbnQgdmFsdWVzIGZyb20gZWFjaCBpbnB1dCBPYnNlcnZhYmxlLCBvciBhbiBhcnJheSBvZiB0aGUgbW9zdFxuICogcmVjZW50IHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhMYXRlc3RGcm9tPFQsIFI+KC4uLmlucHV0czogYW55W10pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFIgfCBhbnlbXT4ge1xuICBjb25zdCBwcm9qZWN0ID0gcG9wUmVzdWx0U2VsZWN0b3IoaW5wdXRzKSBhcyAoKC4uLmFyZ3M6IGFueVtdKSA9PiBSKSB8IHVuZGVmaW5lZDtcblxuICByZXR1cm4gb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgY29uc3QgbGVuID0gaW5wdXRzLmxlbmd0aDtcbiAgICBjb25zdCBvdGhlclZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgIC8vIEFuIGFycmF5IG9mIHdoZXRoZXIgb3Igbm90IHRoZSBvdGhlciBzb3VyY2VzIGhhdmUgZW1pdHRlZC4gTWF0Y2hlZCB3aXRoIHRoZW0gYnkgaW5kZXguXG4gICAgLy8gVE9ETzogQXQgc29tZXBvaW50LCB3ZSBzaG91bGQgaW52ZXN0aWdhdGUgdGhlIHBlcmZvcm1hbmNlIGltcGxpY2F0aW9ucyBoZXJlLCBhbmQgbG9va1xuICAgIC8vIGludG8gdXNpbmcgYSBgU2V0KClgIGFuZCBjaGVja2luZyB0aGUgYHNpemVgIHRvIHNlZSBpZiB3ZSdyZSByZWFkeS5cbiAgICBsZXQgaGFzVmFsdWUgPSBpbnB1dHMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAvLyBGbGlwcGVkIHRydWUgd2hlbiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSB2YWx1ZSBmcm9tIGFsbCBvdGhlciBzb3VyY2VzIGFuZFxuICAgIC8vIHdlIGFyZSByZWFkeSB0byBzdGFydCBlbWl0dGluZyB2YWx1ZXMuXG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG5cbiAgICAvLyBPdGhlciBzb3VyY2VzLiBOb3RlIHRoYXQgaGVyZSB3ZSBhcmUgbm90IGNoZWNraW5nIGBzdWJzY3JpYmVyLmNsb3NlZGAsXG4gICAgLy8gdGhpcyBjYXVzZXMgYWxsIGlucHV0cyB0byBiZSBzdWJzY3JpYmVkIHRvLCBldmVuIGlmIG5vdGhpbmcgY2FuIGJlIGVtaXR0ZWRcbiAgICAvLyBmcm9tIHRoZW0uIFRoaXMgaXMgYW4gaW1wb3J0YW50IGRpc3RpbmN0aW9uIGJlY2F1c2Ugc3Vic2NyaXB0aW9uIGNvbnN0aXR1dGVzXG4gICAgLy8gYSBzaWRlLWVmZmVjdC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpbm5lckZyb20oaW5wdXRzW2ldKS5zdWJzY3JpYmUoXG4gICAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgb3RoZXJWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICghcmVhZHkgJiYgIWhhc1ZhbHVlW2ldKSB7XG4gICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCByZWFkeSB5ZXQsIGZsYWcgdG8gc2hvdyB0aGlzIG9ic2VydmFibGUgaGFzIGVtaXR0ZWQuXG4gICAgICAgICAgICAgIGhhc1ZhbHVlW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB0ZXJzZSBjb2RlLlxuICAgICAgICAgICAgICAvLyBJZiBhbGwgb2Ygb3VyIG90aGVyIG9ic2VydmFibGVzIGhhdmUgZW1pdHRlZCwgc2V0IGByZWFkeWAgdG8gYHRydWVgLFxuICAgICAgICAgICAgICAvLyBzbyB3ZSBrbm93IHdlIGNhbiBzdGFydCBlbWl0dGluZyB2YWx1ZXMsIHRoZW4gY2xlYW4gdXAgdGhlIGBoYXNWYWx1ZWAgYXJyYXksXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICAocmVhZHkgPSBoYXNWYWx1ZS5ldmVyeShpZGVudGl0eSkpICYmIChoYXNWYWx1ZSA9IG51bGwhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIENvbXBsZXRpbmcgb25lIG9mIHRoZSBvdGhlciBzb3VyY2VzIGhhc1xuICAgICAgICAgIC8vIG5vIGJlYXJpbmcgb24gdGhlIGNvbXBsZXRpb24gb2Ygb3VyIHJlc3VsdC5cbiAgICAgICAgICBub29wXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gU291cmNlIHN1YnNjcmlwdGlvblxuICAgIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChyZWFkeSkge1xuICAgICAgICAgIC8vIFdlIGhhdmUgYXQgbGVhc3Qgb25lIHZhbHVlIGZyb20gdGhlIG90aGVyIHNvdXJjZXMuIEdvIGFoZWFkIGFuZCBlbWl0LlxuICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFt2YWx1ZSwgLi4ub3RoZXJWYWx1ZXNdO1xuICAgICAgICAgIHN1YnNjcmliZXIubmV4dChwcm9qZWN0ID8gcHJvamVjdCguLi52YWx1ZXMpIDogdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9KTtcbn1cbiJdfQ==
