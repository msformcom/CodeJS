import { EMPTY } from '../observable/empty.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * ![](take.png)
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * ## Example
 *
 * Take the first 5 seconds of an infinite 1-second interval Observable
 *
 * ```ts
 * import { interval, take } from 'rxjs';
 *
 * const intervalCount = interval(1000);
 * const takeFive = intervalCount.pipe(take(5));
 * takeFive.subscribe(x => console.log(x));
 *
 * // Logs:
 * // 0
 * // 1
 * // 2
 * // 3
 * // 4
 * ```
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param count The maximum number of `next` values to emit.
 * @return A function that returns an Observable that emits only the first
 * `count` values emitted by the source Observable, or all of the values from
 * the source if the source emits fewer than `count` values.
 */
export function take(count) {
    return count <= 0
        ? // If we are taking no values, that's empty.
            () => EMPTY
        : operate((source, subscriber) => {
            let seen = 0;
            source.subscribe(createOperatorSubscriber(subscriber, (value) => {
                // Increment the number of values we have seen,
                // then check it against the allowed count to see
                // if we are still letting values through.
                if (++seen <= count) {
                    subscriber.next(value);
                    // If we have met or passed our allowed count,
                    // we need to complete. We have to do <= here,
                    // because re-entrant code will increment `seen` twice.
                    if (count <= seen) {
                        subscriber.complete();
                    }
                }
            }));
        });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDNUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUVoRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5Q0c7QUFDSCxNQUFNLFVBQVUsSUFBSSxDQUFJLEtBQWE7SUFDbkMsT0FBTyxLQUFLLElBQUksQ0FBQztRQUNmLENBQUMsQ0FBQyw0Q0FBNEM7WUFDNUMsR0FBRyxFQUFFLENBQUMsS0FBSztRQUNiLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7WUFDN0IsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1lBQ2IsTUFBTSxDQUFDLFNBQVMsQ0FDZCx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDN0MsK0NBQStDO2dCQUMvQyxpREFBaUQ7Z0JBQ2pELDBDQUEwQztnQkFDMUMsSUFBSSxFQUFFLElBQUksSUFBSSxLQUFLLEVBQUUsQ0FBQztvQkFDcEIsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDdkIsOENBQThDO29CQUM5Qyw4Q0FBOEM7b0JBQzlDLHVEQUF1RDtvQkFDdkQsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFLENBQUM7d0JBQ2xCLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDeEIsQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ1QsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBFTVBUWSB9IGZyb20gJy4uL29ic2VydmFibGUvZW1wdHknO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5cbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YCB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRha2VzIHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UsIHRoZW5cbiAqIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogIVtdKHRha2UucG5nKVxuICpcbiAqIGB0YWtlYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcyB0aGVuXG4gKiBhbGwgb2YgaXRzIHZhbHVlcyBhcmUgZW1pdHRlZC4gQWZ0ZXIgdGhhdCwgaXQgY29tcGxldGVzLCByZWdhcmRsZXNzIGlmIHRoZVxuICogc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogVGFrZSB0aGUgZmlyc3QgNSBzZWNvbmRzIG9mIGFuIGluZmluaXRlIDEtc2Vjb25kIGludGVydmFsIE9ic2VydmFibGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaW50ZXJ2YWwsIHRha2UgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBpbnRlcnZhbENvdW50ID0gaW50ZXJ2YWwoMTAwMCk7XG4gKiBjb25zdCB0YWtlRml2ZSA9IGludGVydmFsQ291bnQucGlwZSh0YWtlKDUpKTtcbiAqIHRha2VGaXZlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMFxuICogLy8gMVxuICogLy8gMlxuICogLy8gM1xuICogLy8gNFxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZUxhc3R9XG4gKiBAc2VlIHtAbGluayB0YWtlVW50aWx9XG4gKiBAc2VlIHtAbGluayB0YWtlV2hpbGV9XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSBjb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYG5leHRgIHZhbHVlcyB0byBlbWl0LlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgZmlyc3RcbiAqIGBjb3VudGAgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBvciBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tXG4gKiB0aGUgc291cmNlIGlmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRha2U8VD4oY291bnQ6IG51bWJlcik6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPiB7XG4gIHJldHVybiBjb3VudCA8PSAwXG4gICAgPyAvLyBJZiB3ZSBhcmUgdGFraW5nIG5vIHZhbHVlcywgdGhhdCdzIGVtcHR5LlxuICAgICAgKCkgPT4gRU1QVFlcbiAgICA6IG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICBsZXQgc2VlbiA9IDA7XG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBudW1iZXIgb2YgdmFsdWVzIHdlIGhhdmUgc2VlbixcbiAgICAgICAgICAgIC8vIHRoZW4gY2hlY2sgaXQgYWdhaW5zdCB0aGUgYWxsb3dlZCBjb3VudCB0byBzZWVcbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBzdGlsbCBsZXR0aW5nIHZhbHVlcyB0aHJvdWdoLlxuICAgICAgICAgICAgaWYgKCsrc2VlbiA8PSBjb3VudCkge1xuICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1ldCBvciBwYXNzZWQgb3VyIGFsbG93ZWQgY291bnQsXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY29tcGxldGUuIFdlIGhhdmUgdG8gZG8gPD0gaGVyZSxcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSByZS1lbnRyYW50IGNvZGUgd2lsbCBpbmNyZW1lbnQgYHNlZW5gIHR3aWNlLlxuICAgICAgICAgICAgICBpZiAoY291bnQgPD0gc2Vlbikge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcbn1cbiJdfQ==
