import { EmptyError } from '../util/EmptyError.mjs';
import { filter } from './filter.mjs';
import { takeLast } from './takeLast.mjs';
import { throwIfEmpty } from './throwIfEmpty.mjs';
import { defaultIfEmpty } from './defaultIfEmpty.mjs';
import { identity } from '../util/identity.mjs';
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * ![](last.png)
 *
 * It will throw an error if the source completes without notification or one that matches the predicate. It
 * returns the last value or if a predicate is provided last value that matches the predicate. It returns the
 * given default value if no notification is emitted or matches the predicate.
 *
 * ## Examples
 *
 * Last alphabet from the sequence
 *
 * ```ts
 * import { from, last } from 'rxjs';
 *
 * const source = from(['x', 'y', 'z']);
 * const result = source.pipe(last());
 *
 * result.subscribe(value => console.log(`Last alphabet: ${ value }`));
 *
 * // Outputs
 * // Last alphabet: z
 * ```
 *
 * Default value when the value in the predicate is not matched
 *
 * ```ts
 * import { from, last } from 'rxjs';
 *
 * const source = from(['x', 'y', 'z']);
 * const result = source.pipe(last(char => char === 'a', 'not found'));
 *
 * result.subscribe(value => console.log(`'a' is ${ value }.`));
 *
 * // Outputs
 * // 'a' is not found.
 * ```
 *
 * @see {@link skip}
 * @see {@link skipUntil}
 * @see {@link skipLast}
 * @see {@link skipWhile}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} [predicate] - The condition any source emitted item has to satisfy.
 * @param {any} [defaultValue] - An optional default value to provide if last
 * predicate isn't met or no values were emitted.
 * @return A function that returns an Observable that emits only the last item
 * satisfying the given condition from the source, or a NoSuchElementException
 * if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 */
export function last(predicate, defaultValue) {
    const hasDefaultValue = arguments.length >= 2;
    return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvbGFzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFaEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUNsQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBYzVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdERztBQUNILE1BQU0sVUFBVSxJQUFJLENBQ2xCLFNBQWdGLEVBQ2hGLFlBQWdCO0lBRWhCLE1BQU0sZUFBZSxHQUFHLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDO0lBQzlDLE9BQU8sQ0FBQyxNQUFxQixFQUFFLEVBQUUsQ0FDL0IsTUFBTSxDQUFDLElBQUksQ0FDVCxTQUFTLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFDaEUsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUNYLGVBQWUsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLFlBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxVQUFVLEVBQUUsQ0FBQyxDQUN2RixDQUFDO0FBQ04sQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL2xhc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBFbXB0eUVycm9yIH0gZnJvbSAnLi4vdXRpbC9FbXB0eUVycm9yJztcbmltcG9ydCB7IE9wZXJhdG9yRnVuY3Rpb24sIFRydXRoeVR5cGVzT2YgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcic7XG5pbXBvcnQgeyB0YWtlTGFzdCB9IGZyb20gJy4vdGFrZUxhc3QnO1xuaW1wb3J0IHsgdGhyb3dJZkVtcHR5IH0gZnJvbSAnLi90aHJvd0lmRW1wdHknO1xuaW1wb3J0IHsgZGVmYXVsdElmRW1wdHkgfSBmcm9tICcuL2RlZmF1bHRJZkVtcHR5JztcbmltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSAnLi4vdXRpbC9pZGVudGl0eSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQ+KHByZWRpY2F0ZTogQm9vbGVhbkNvbnN0cnVjdG9yKTogT3BlcmF0b3JGdW5jdGlvbjxULCBUcnV0aHlUeXBlc09mPFQ+PjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQsIEQ+KHByZWRpY2F0ZTogQm9vbGVhbkNvbnN0cnVjdG9yLCBkZWZhdWx0VmFsdWU6IEQpOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFRydXRoeVR5cGVzT2Y8VD4gfCBEPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQsIEQgPSBUPihwcmVkaWNhdGU/OiBudWxsLCBkZWZhdWx0VmFsdWU/OiBEKTogT3BlcmF0b3JGdW5jdGlvbjxULCBUIHwgRD47XG5leHBvcnQgZnVuY3Rpb24gbGFzdDxULCBTIGV4dGVuZHMgVD4oXG4gIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHZhbHVlIGlzIFMsXG4gIGRlZmF1bHRWYWx1ZT86IFNcbik6IE9wZXJhdG9yRnVuY3Rpb248VCwgUz47XG5leHBvcnQgZnVuY3Rpb24gbGFzdDxULCBEID0gVD4oXG4gIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IGJvb2xlYW4sXG4gIGRlZmF1bHRWYWx1ZT86IERcbik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVCB8IEQ+O1xuXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGxhc3QgaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEl0IG9wdGlvbmFsbHkgdGFrZXMgYSBwcmVkaWNhdGUgZnVuY3Rpb24gYXMgYSBwYXJhbWV0ZXIsIGluIHdoaWNoIGNhc2UsIHJhdGhlciB0aGFuIGVtaXR0aW5nXG4gKiB0aGUgbGFzdCBpdGVtIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGUgcmVzdWx0aW5nIE9ic2VydmFibGUgd2lsbCBlbWl0IHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGUuXG4gKlxuICogIVtdKGxhc3QucG5nKVxuICpcbiAqIEl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNvdXJjZSBjb21wbGV0ZXMgd2l0aG91dCBub3RpZmljYXRpb24gb3Igb25lIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLiBJdFxuICogcmV0dXJucyB0aGUgbGFzdCB2YWx1ZSBvciBpZiBhIHByZWRpY2F0ZSBpcyBwcm92aWRlZCBsYXN0IHZhbHVlIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLiBJdCByZXR1cm5zIHRoZVxuICogZ2l2ZW4gZGVmYXVsdCB2YWx1ZSBpZiBubyBub3RpZmljYXRpb24gaXMgZW1pdHRlZCBvciBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuXG4gKlxuICogIyMgRXhhbXBsZXNcbiAqXG4gKiBMYXN0IGFscGhhYmV0IGZyb20gdGhlIHNlcXVlbmNlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb20sIGxhc3QgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UgPSBmcm9tKFsneCcsICd5JywgJ3onXSk7XG4gKiBjb25zdCByZXN1bHQgPSBzb3VyY2UucGlwZShsYXN0KCkpO1xuICpcbiAqIHJlc3VsdC5zdWJzY3JpYmUodmFsdWUgPT4gY29uc29sZS5sb2coYExhc3QgYWxwaGFiZXQ6ICR7IHZhbHVlIH1gKSk7XG4gKlxuICogLy8gT3V0cHV0c1xuICogLy8gTGFzdCBhbHBoYWJldDogelxuICogYGBgXG4gKlxuICogRGVmYXVsdCB2YWx1ZSB3aGVuIHRoZSB2YWx1ZSBpbiB0aGUgcHJlZGljYXRlIGlzIG5vdCBtYXRjaGVkXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb20sIGxhc3QgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UgPSBmcm9tKFsneCcsICd5JywgJ3onXSk7XG4gKiBjb25zdCByZXN1bHQgPSBzb3VyY2UucGlwZShsYXN0KGNoYXIgPT4gY2hhciA9PT0gJ2EnLCAnbm90IGZvdW5kJykpO1xuICpcbiAqIHJlc3VsdC5zdWJzY3JpYmUodmFsdWUgPT4gY29uc29sZS5sb2coYCdhJyBpcyAkeyB2YWx1ZSB9LmApKTtcbiAqXG4gKiAvLyBPdXRwdXRzXG4gKiAvLyAnYScgaXMgbm90IGZvdW5kLlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqIEBzZWUge0BsaW5rIHNraXBVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHNraXBMYXN0fVxuICogQHNlZSB7QGxpbmsgc2tpcFdoaWxlfVxuICpcbiAqIEB0aHJvd3Mge0VtcHR5RXJyb3J9IERlbGl2ZXJzIGFuIEVtcHR5RXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYFxuICogY2FsbGJhY2sgaWYgdGhlIE9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBhbnkgYG5leHRgIG5vdGlmaWNhdGlvbiB3YXMgc2VudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcmVkaWNhdGVdIC0gVGhlIGNvbmRpdGlvbiBhbnkgc291cmNlIGVtaXR0ZWQgaXRlbSBoYXMgdG8gc2F0aXNmeS5cbiAqIEBwYXJhbSB7YW55fSBbZGVmYXVsdFZhbHVlXSAtIEFuIG9wdGlvbmFsIGRlZmF1bHQgdmFsdWUgdG8gcHJvdmlkZSBpZiBsYXN0XG4gKiBwcmVkaWNhdGUgaXNuJ3QgbWV0IG9yIG5vIHZhbHVlcyB3ZXJlIGVtaXR0ZWQuXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBsYXN0IGl0ZW1cbiAqIHNhdGlzZnlpbmcgdGhlIGdpdmVuIGNvbmRpdGlvbiBmcm9tIHRoZSBzb3VyY2UsIG9yIGEgTm9TdWNoRWxlbWVudEV4Y2VwdGlvblxuICogaWYgbm8gc3VjaCBpdGVtcyBhcmUgZW1pdHRlZC5cbiAqIEB0aHJvd3MgLSBUaHJvd3MgaWYgbm8gaXRlbXMgdGhhdCBtYXRjaCB0aGUgcHJlZGljYXRlIGFyZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCwgRD4oXG4gIHByZWRpY2F0ZT86ICgodmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gYm9vbGVhbikgfCBudWxsLFxuICBkZWZhdWx0VmFsdWU/OiBEXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBEPiB7XG4gIGNvbnN0IGhhc0RlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMjtcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+XG4gICAgc291cmNlLnBpcGUoXG4gICAgICBwcmVkaWNhdGUgPyBmaWx0ZXIoKHYsIGkpID0+IHByZWRpY2F0ZSh2LCBpLCBzb3VyY2UpKSA6IGlkZW50aXR5LFxuICAgICAgdGFrZUxhc3QoMSksXG4gICAgICBoYXNEZWZhdWx0VmFsdWUgPyBkZWZhdWx0SWZFbXB0eShkZWZhdWx0VmFsdWUhKSA6IHRocm93SWZFbXB0eSgoKSA9PiBuZXcgRW1wdHlFcnJvcigpKVxuICAgICk7XG59XG4iXX0=
