import { Subject } from '../Subject.mjs';
import { asyncScheduler } from '../scheduler/async.mjs';
import { Subscription } from '../Subscription.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { arrRemove } from '../util/arrRemove.mjs';
import { popScheduler } from '../util/args.mjs';
import { executeSchedule } from '../util/executeSchedule.mjs';
/**
 * Branch out the source Observable values as a nested Observable periodically
 * in time.
 *
 * <span class="informal">It's like {@link bufferTime}, but emits a nested
 * Observable instead of an array.</span>
 *
 * ![](windowTime.png)
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable starts a new window periodically, as
 * determined by the `windowCreationInterval` argument. It emits each window
 * after a fixed timespan, specified by the `windowTimeSpan` argument. When the
 * source Observable completes or encounters an error, the output Observable
 * emits the current window and propagates the notification from the source
 * Observable. If `windowCreationInterval` is not provided, the output
 * Observable starts a new window when the previous window of duration
 * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window
 * will emit at most fixed number of values. Window will complete immediately
 * after emitting last value and next one still will open as specified by
 * `windowTimeSpan` and `windowCreationInterval` arguments.
 *
 * ## Examples
 *
 * In every window of 1 second each, emit at most 2 click events
 *
 * ```ts
 * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(
 *   windowTime(1000),
 *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window
 *   mergeAll()                     // flatten the Observable-of-Observables
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window
 *
 * ```ts
 * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(
 *   windowTime(1000, 5000),
 *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window
 *   mergeAll()                     // flatten the Observable-of-Observables
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * Same as example above but with `maxWindowCount` instead of `take`
 *
 * ```ts
 * import { fromEvent, windowTime, mergeAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(
 *   windowTime(1000, 5000, 2), // take at most 2 emissions from each window
 *   mergeAll()                 // flatten the Observable-of-Observables
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferTime}
 *
 * @param windowTimeSpan The amount of time, in milliseconds, to fill each window.
 * @param windowCreationInterval The interval at which to start new
 * windows.
 * @param maxWindowSize Max number of
 * values each window can emit before completion.
 * @param scheduler The scheduler on which to schedule the
 * intervals that determine window boundaries.
 * @return A function that returns an Observable of windows, which in turn are
 * Observables.
 */
export function windowTime(windowTimeSpan, ...otherArgs) {
    var _a, _b;
    const scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
    const windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
    const maxWindowSize = otherArgs[1] || Infinity;
    return operate((source, subscriber) => {
        // The active windows, their related subscriptions, and removal functions.
        let windowRecords = [];
        // If true, it means that every time we close a window, we want to start a new window.
        // This is only really used for when *just* the time span is passed.
        let restartOnClose = false;
        const closeWindow = (record) => {
            const { window, subs } = record;
            window.complete();
            subs.unsubscribe();
            arrRemove(windowRecords, record);
            restartOnClose && startWindow();
        };
        /**
         * Called every time we start a new window. This also does
         * the work of scheduling the job to close the window.
         */
        const startWindow = () => {
            if (windowRecords) {
                const subs = new Subscription();
                subscriber.add(subs);
                const window = new Subject();
                const record = {
                    window,
                    subs,
                    seen: 0,
                };
                windowRecords.push(record);
                subscriber.next(window.asObservable());
                executeSchedule(subs, scheduler, () => closeWindow(record), windowTimeSpan);
            }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            // The user passed both a windowTimeSpan (required), and a creation interval
            // That means we need to start new window on the interval, and those windows need
            // to wait the required time span before completing.
            executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
        }
        else {
            restartOnClose = true;
        }
        startWindow();
        /**
         * We need to loop over a copy of the window records several times in this operator.
         * This is to save bytes over the wire more than anything.
         * The reason we copy the array is that reentrant code could mutate the array while
         * we are iterating over it.
         */
        const loop = (cb) => windowRecords.slice().forEach(cb);
        /**
         * Used to notify all of the windows and the subscriber in the same way
         * in the error and complete handlers.
         */
        const terminate = (cb) => {
            loop(({ window }) => cb(window));
            cb(subscriber);
            subscriber.unsubscribe();
        };
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            // Notify all windows of the value.
            loop((record) => {
                record.window.next(value);
                // If the window is over the max size, we need to close it.
                maxWindowSize <= ++record.seen && closeWindow(record);
            });
        }, 
        // Complete the windows and the downstream subscriber and clean up.
        () => terminate((consumer) => consumer.complete()), 
        // Notify the windows and the downstream subscriber of the error and clean up.
        (err) => terminate((consumer) => consumer.error(err))));
        // Additional finalization. This will be called when the
        // destination tears down. Other finalizations are registered implicitly
        // above via subscription.
        return () => {
            // Ensure that the buffer is released.
            windowRecords = null;
        };
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93VGltZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3JDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVwRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFL0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDOUMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUM1QyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFlMUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBZ0ZHO0FBQ0gsTUFBTSxVQUFVLFVBQVUsQ0FBSSxjQUFzQixFQUFFLEdBQUcsU0FBZ0I7O0lBQ3ZFLE1BQU0sU0FBUyxHQUFHLE1BQUEsWUFBWSxDQUFDLFNBQVMsQ0FBQyxtQ0FBSSxjQUFjLENBQUM7SUFDNUQsTUFBTSxzQkFBc0IsR0FBRyxNQUFDLFNBQVMsQ0FBQyxDQUFDLENBQVksbUNBQUksSUFBSSxDQUFDO0lBQ2hFLE1BQU0sYUFBYSxHQUFJLFNBQVMsQ0FBQyxDQUFDLENBQVksSUFBSSxRQUFRLENBQUM7SUFFM0QsT0FBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDcEMsMEVBQTBFO1FBQzFFLElBQUksYUFBYSxHQUE2QixFQUFFLENBQUM7UUFDakQsc0ZBQXNGO1FBQ3RGLG9FQUFvRTtRQUNwRSxJQUFJLGNB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QUMsQ0FDdEQsQ0FDRixDQUFDO1FBRUYsd0RBQXdEO1FBQ3hELHdFQUF3RTtRQUN4RSwwQkFBMEI7UUFDMUIsT0FBTyxHQUFHLEVBQUU7WUFDVixzQ0FBc0M7WUFDdEMsYUFBYSxHQUFHLElBQUssQ0FBQztRQUN4QixDQUFDLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dUaW1lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgYXN5bmNTY2hlZHVsZXIgfSBmcm9tICcuLi9zY2hlZHVsZXIvYXN5bmMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE9ic2VydmVyLCBPcGVyYXRvckZ1bmN0aW9uLCBTY2hlZHVsZXJMaWtlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBhcnJSZW1vdmUgfSBmcm9tICcuLi91dGlsL2FyclJlbW92ZSc7XG5pbXBvcnQgeyBwb3BTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2FyZ3MnO1xuaW1wb3J0IHsgZXhlY3V0ZVNjaGVkdWxlIH0gZnJvbSAnLi4vdXRpbC9leGVjdXRlU2NoZWR1bGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gd2luZG93VGltZTxUPih3aW5kb3dUaW1lU3BhbjogbnVtYmVyLCBzY2hlZHVsZXI/OiBTY2hlZHVsZXJMaWtlKTogT3BlcmF0b3JGdW5jdGlvbjxULCBPYnNlcnZhYmxlPFQ+PjtcbmV4cG9ydCBmdW5jdGlvbiB3aW5kb3dUaW1lPFQ+KFxuICB3aW5kb3dUaW1lU3BhbjogbnVtYmVyLFxuICB3aW5kb3dDcmVhdGlvbkludGVydmFsOiBudW1iZXIsXG4gIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2Vcbik6IE9wZXJhdG9yRnVuY3Rpb248VCwgT2JzZXJ2YWJsZTxUPj47XG5leHBvcnQgZnVuY3Rpb24gd2luZG93VGltZTxUPihcbiAgd2luZG93VGltZVNwYW46IG51bWJlcixcbiAgd2luZG93Q3JlYXRpb25JbnRlcnZhbDogbnVtYmVyIHwgbnVsbCB8IHZvaWQsXG4gIG1heFdpbmRvd1NpemU6IG51bWJlcixcbiAgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZVxuKTogT3BlcmF0b3JGdW5jdGlvbjxULCBPYnNlcnZhYmxlPFQ+PjtcblxuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSBwZXJpb2RpY2FsbHlcbiAqIGluIHRpbWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyVGltZX0sIGJ1dCBlbWl0cyBhIG5lc3RlZFxuICogT2JzZXJ2YWJsZSBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiAhW10od2luZG93VGltZS5wbmcpXG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBzdGFydHMgYSBuZXcgd2luZG93IHBlcmlvZGljYWxseSwgYXNcbiAqIGRldGVybWluZWQgYnkgdGhlIGB3aW5kb3dDcmVhdGlvbkludGVydmFsYCBhcmd1bWVudC4gSXQgZW1pdHMgZWFjaCB3aW5kb3dcbiAqIGFmdGVyIGEgZml4ZWQgdGltZXNwYW4sIHNwZWNpZmllZCBieSB0aGUgYHdpbmRvd1RpbWVTcGFuYCBhcmd1bWVudC4gV2hlbiB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBvciBlbmNvdW50ZXJzIGFuIGVycm9yLCB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIGVtaXRzIHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgcHJvcGFnYXRlcyB0aGUgbm90aWZpY2F0aW9uIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gSWYgYHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWxgIGlzIG5vdCBwcm92aWRlZCwgdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBzdGFydHMgYSBuZXcgd2luZG93IHdoZW4gdGhlIHByZXZpb3VzIHdpbmRvdyBvZiBkdXJhdGlvblxuICogYHdpbmRvd1RpbWVTcGFuYCBjb21wbGV0ZXMuIElmIGBtYXhXaW5kb3dDb3VudGAgaXMgcHJvdmlkZWQsIGVhY2ggd2luZG93XG4gKiB3aWxsIGVtaXQgYXQgbW9zdCBmaXhlZCBudW1iZXIgb2YgdmFsdWVzLiBXaW5kb3cgd2lsbCBjb21wbGV0ZSBpbW1lZGlhdGVseVxuICogYWZ0ZXIgZW1pdHRpbmcgbGFzdCB2YWx1ZSBhbmQgbmV4dCBvbmUgc3RpbGwgd2lsbCBvcGVuIGFzIHNwZWNpZmllZCBieVxuICogYHdpbmRvd1RpbWVTcGFuYCBhbmQgYHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWxgIGFyZ3VtZW50cy5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIEluIGV2ZXJ5IHdpbmRvdyBvZiAxIHNlY29uZCBlYWNoLCBlbWl0IGF0IG1vc3QgMiBjbGljayBldmVudHNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50LCB3aW5kb3dUaW1lLCBtYXAsIHRha2UsIG1lcmdlQWxsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGNsaWNrcy5waXBlKFxuICogICB3aW5kb3dUaW1lKDEwMDApLFxuICogICBtYXAod2luID0+IHdpbi5waXBlKHRha2UoMikpKSwgLy8gdGFrZSBhdCBtb3N0IDIgZW1pc3Npb25zIGZyb20gZWFjaCB3aW5kb3dcbiAqICAgbWVyZ2VBbGwoKSAgICAgICAgICAgICAgICAgICAgIC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqICk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogYGBgXG4gKlxuICogRXZlcnkgNSBzZWNvbmRzIHN0YXJ0IGEgd2luZG93IDEgc2Vjb25kIGxvbmcsIGFuZCBlbWl0IGF0IG1vc3QgMiBjbGljayBldmVudHMgcGVyIHdpbmRvd1xuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIHdpbmRvd1RpbWUsIG1hcCwgdGFrZSwgbWVyZ2VBbGwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBjbGlja3MgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogY29uc3QgcmVzdWx0ID0gY2xpY2tzLnBpcGUoXG4gKiAgIHdpbmRvd1RpbWUoMTAwMCwgNTAwMCksXG4gKiAgIG1hcCh3aW4gPT4gd2luLnBpcGUodGFrZSgyKSkpLCAvLyB0YWtlIGF0IG1vc3QgMiBlbWlzc2lvbnMgZnJvbSBlYWNoIHdpbmRvd1xuICogICBtZXJnZUFsbCgpICAgICAgICAgICAgICAgICAgICAgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiBgYGBcbiAqXG4gKiBTYW1lIGFzIGV4YW1wbGUgYWJvdmUgYnV0IHdpdGggYG1heFdpbmRvd0NvdW50YCBpbnN0ZWFkIG9mIGB0YWtlYFxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIHdpbmRvd1RpbWUsIG1lcmdlQWxsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGNsaWNrcy5waXBlKFxuICogICB3aW5kb3dUaW1lKDEwMDAsIDUwMDAsIDIpLCAvLyB0YWtlIGF0IG1vc3QgMiBlbWlzc2lvbnMgZnJvbSBlYWNoIHdpbmRvd1xuICogICBtZXJnZUFsbCgpICAgICAgICAgICAgICAgICAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgd2luZG93V2hlbn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRpbWV9XG4gKlxuICogQHBhcmFtIHdpbmRvd1RpbWVTcGFuIFRoZSBhbW91bnQgb2YgdGltZSwgaW4gbWlsbGlzZWNvbmRzLCB0byBmaWxsIGVhY2ggd2luZG93LlxuICogQHBhcmFtIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgVGhlIGludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IG5ld1xuICogd2luZG93cy5cbiAqIEBwYXJhbSBtYXhXaW5kb3dTaXplIE1heCBudW1iZXIgb2ZcbiAqIHZhbHVlcyBlYWNoIHdpbmRvdyBjYW4gZW1pdCBiZWZvcmUgY29tcGxldGlvbi5cbiAqIEBwYXJhbSBzY2hlZHVsZXIgVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAqIGludGVydmFscyB0aGF0IGRldGVybWluZSB3aW5kb3cgYm91bmRhcmllcy5cbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSBvZiB3aW5kb3dzLCB3aGljaCBpbiB0dXJuIGFyZVxuICogT2JzZXJ2YWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aW5kb3dUaW1lPFQ+KHdpbmRvd1RpbWVTcGFuOiBudW1iZXIsIC4uLm90aGVyQXJnczogYW55W10pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIE9ic2VydmFibGU8VD4+IHtcbiAgY29uc3Qgc2NoZWR1bGVyID0gcG9wU2NoZWR1bGVyKG90aGVyQXJncykgPz8gYXN5bmNTY2hlZHVsZXI7XG4gIGNvbnN0IHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgPSAob3RoZXJBcmdzWzBdIGFzIG51bWJlcikgPz8gbnVsbDtcbiAgY29uc3QgbWF4V2luZG93U2l6ZSA9IChvdGhlckFyZ3NbMV0gYXMgbnVtYmVyKSB8fCBJbmZpbml0eTtcblxuICByZXR1cm4gb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgLy8gVGhlIGFjdGl2ZSB3aW5kb3dzLCB0aGVpciByZWxhdGVkIHN1YnNjcmlwdGlvbnMsIGFuZCByZW1vdmFsIGZ1bmN0aW9ucy5cbiAgICBsZXQgd2luZG93UmVjb3JkczogV2luZG93UmVjb3JkPFQ+W10gfCBudWxsID0gW107XG4gICAgLy8gSWYgdHJ1ZSwgaXQgbWVhbnMgdGhhdCBldmVyeSB0aW1lIHdlIGNsb3NlIGEgd2luZG93LCB3ZSB3YW50IHRvIHN0YXJ0IGEgbmV3IHdpbmRvdy5cbiAgICAvLyBUaGlzIGlzIG9ubHkgcmVhbGx5IHVzZWQgZm9yIHdoZW4gKmp1c3QqIHRoZSB0aW1lIHNwYW4gaXMgcGFzc2VkLlxuICAgIGxldCByZXN0YXJ0T25DbG9zZSA9IGZhbHNlO1xuXG4gICAgY29uc3QgY2xvc2VXaW5kb3cgPSAocmVjb3JkOiB7IHdpbmRvdzogU3ViamVjdDxUPjsgc3ViczogU3Vic2NyaXB0aW9uIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgd2luZG93LCBzdWJzIH0gPSByZWNvcmQ7XG4gICAgICB3aW5kb3cuY29tcGxldGUoKTtcbiAgICAgIHN1YnMudW5zdWJzY3JpYmUoKTtcbiAgICAgIGFyclJlbW92ZSh3aW5kb3dSZWNvcmRzLCByZWNvcmQpO1xuICAgICAgcmVzdGFydE9uQ2xvc2UgJiYgc3RhcnRXaW5kb3coKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGV2ZXJ5IHRpbWUgd2Ugc3RhcnQgYSBuZXcgd2luZG93LiBUaGlzIGFsc28gZG9lc1xuICAgICAqIHRoZSB3b3JrIG9mIHNjaGVkdWxpbmcgdGhlIGpvYiB0byBjbG9zZSB0aGUgd2luZG93LlxuICAgICAqL1xuICAgIGNvbnN0IHN0YXJ0V2luZG93ID0gKCkgPT4ge1xuICAgICAgaWYgKHdpbmRvd1JlY29yZHMpIHtcbiAgICAgICAgY29uc3Qgc3VicyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgc3Vic2NyaWJlci5hZGQoc3Vicyk7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IG5ldyBTdWJqZWN0PFQ+KCk7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHtcbiAgICAgICAgICB3aW5kb3csXG4gICAgICAgICAgc3VicyxcbiAgICAgICAgICBzZWVuOiAwLFxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3dSZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHdpbmRvdy5hc09ic2VydmFibGUoKSk7XG4gICAgICAgIGV4ZWN1dGVTY2hlZHVsZShzdWJzLCBzY2hlZHVsZXIsICgpID0+IGNsb3NlV2luZG93KHJlY29yZCksIHdpbmRvd1RpbWVTcGFuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgIT09IG51bGwgJiYgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA+PSAwKSB7XG4gICAgICAvLyBUaGUgdXNlciBwYXNzZWQgYm90aCBhIHdpbmRvd1RpbWVTcGFuIChyZXF1aXJlZCksIGFuZCBhIGNyZWF0aW9uIGludGVydmFsXG4gICAgICAvLyBUaGF0IG1lYW5zIHdlIG5lZWQgdG8gc3RhcnQgbmV3IHdpbmRvdyBvbiB0aGUgaW50ZXJ2YWwsIGFuZCB0aG9zZSB3aW5kb3dzIG5lZWRcbiAgICAgIC8vIHRvIHdhaXQgdGhlIHJlcXVpcmVkIHRpbWUgc3BhbiBiZWZvcmUgY29tcGxldGluZy5cbiAgICAgIGV4ZWN1dGVTY2hlZHVsZShzdWJzY3JpYmVyLCBzY2hlZHVsZXIsIHN0YXJ0V2luZG93LCB3aW5kb3dDcmVhdGlvbkludGVydmFsLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdGFydE9uQ2xvc2UgPSB0cnVlO1xuICAgIH1cblxuICAgIHN0YXJ0V2luZG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIGxvb3Agb3ZlciBhIGNvcHkgb2YgdGhlIHdpbmRvdyByZWNvcmRzIHNldmVyYWwgdGltZXMgaW4gdGhpcyBvcGVyYXRvci5cbiAgICAgKiBUaGlzIGlzIHRvIHNhdmUgYnl0ZXMgb3ZlciB0aGUgd2lyZSBtb3JlIHRoYW4gYW55dGhpbmcuXG4gICAgICogVGhlIHJlYXNvbiB3ZSBjb3B5IHRoZSBhcnJheSBpcyB0aGF0IHJlZW50cmFudCBjb2RlIGNvdWxkIG11dGF0ZSB0aGUgYXJyYXkgd2hpbGVcbiAgICAgKiB3ZSBhcmUgaXRlcmF0aW5nIG92ZXIgaXQuXG4gICAgICovXG4gICAgY29uc3QgbG9vcCA9IChjYjogKHJlY29yZDogV2luZG93UmVjb3JkPFQ+KSA9PiB2b2lkKSA9PiB3aW5kb3dSZWNvcmRzIS5zbGljZSgpLmZvckVhY2goY2IpO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBub3RpZnkgYWxsIG9mIHRoZSB3aW5kb3dzIGFuZCB0aGUgc3Vic2NyaWJlciBpbiB0aGUgc2FtZSB3YXlcbiAgICAgKiBpbiB0aGUgZXJyb3IgYW5kIGNvbXBsZXRlIGhhbmRsZXJzLlxuICAgICAqL1xuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjYjogKGNvbnN1bWVyOiBPYnNlcnZlcjxhbnk+KSA9PiB2b2lkKSA9PiB7XG4gICAgICBsb29wKCh7IHdpbmRvdyB9KSA9PiBjYih3aW5kb3cpKTtcbiAgICAgIGNiKHN1YnNjcmliZXIpO1xuICAgICAgc3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG5cbiAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAodmFsdWU6IFQpID0+IHtcbiAgICAgICAgICAvLyBOb3RpZnkgYWxsIHdpbmRvd3Mgb2YgdGhlIHZhbHVlLlxuICAgICAgICAgIGxvb3AoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgcmVjb3JkLndpbmRvdy5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3aW5kb3cgaXMgb3ZlciB0aGUgbWF4IHNpemUsIHdlIG5lZWQgdG8gY2xvc2UgaXQuXG4gICAgICAgICAgICBtYXhXaW5kb3dTaXplIDw9ICsrcmVjb3JkLnNlZW4gJiYgY2xvc2VXaW5kb3cocmVjb3JkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ29tcGxldGUgdGhlIHdpbmRvd3MgYW5kIHRoZSBkb3duc3RyZWFtIHN1YnNjcmliZXIgYW5kIGNsZWFuIHVwLlxuICAgICAgICAoKSA9PiB0ZXJtaW5hdGUoKGNvbnN1bWVyKSA9PiBjb25zdW1lci5jb21wbGV0ZSgpKSxcbiAgICAgICAgLy8gTm90aWZ5IHRoZSB3aW5kb3dzIGFuZCB0aGUgZG93bnN0cmVhbSBzdWJzY3JpYmVyIG9mIHRoZSBlcnJvciBhbmQgY2xlYW4gdXAuXG4gICAgICAgIChlcnIpID0+IHRlcm1pbmF0ZSgoY29uc3VtZXIpID0+IGNvbnN1bWVyLmVycm9yKGVycikpXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIEFkZGl0aW9uYWwgZmluYWxpemF0aW9uLiBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlXG4gICAgLy8gZGVzdGluYXRpb24gdGVhcnMgZG93bi4gT3RoZXIgZmluYWxpemF0aW9ucyBhcmUgcmVnaXN0ZXJlZCBpbXBsaWNpdGx5XG4gICAgLy8gYWJvdmUgdmlhIHN1YnNjcmlwdGlvbi5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGJ1ZmZlciBpcyByZWxlYXNlZC5cbiAgICAgIHdpbmRvd1JlY29yZHMgPSBudWxsITtcbiAgICB9O1xuICB9KTtcbn1cblxuaW50ZXJmYWNlIFdpbmRvd1JlY29yZDxUPiB7XG4gIHNlZW46IG51bWJlcjtcbiAgd2luZG93OiBTdWJqZWN0PFQ+O1xuICBzdWJzOiBTdWJzY3JpcHRpb247XG59XG4iXX0=
