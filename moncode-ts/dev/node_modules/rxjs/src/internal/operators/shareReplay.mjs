import { ReplaySubject } from '../ReplaySubject.mjs';
import { share } from './share.mjs';
/**
 * Share source and replay specified number of emissions on subscription.
 *
 * This operator is a specialization of `replay` that connects to a source observable
 * and multicasts through a `ReplaySubject` constructed with the specified arguments.
 * A successfully completed source will stay cached in the `shareReplay`ed observable forever,
 * but an errored source can be retried.
 *
 * ## Why use `shareReplay`?
 *
 * You generally want to use `shareReplay` when you have side-effects or taxing computations
 * that you do not wish to be executed amongst multiple subscribers.
 * It may also be valuable in situations where you know you will have late subscribers to
 * a stream that need access to previously emitted values.
 * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.
 *
 * ## Reference counting
 *
 * By default `shareReplay` will use `refCount` of false, meaning that it will _not_ unsubscribe the
 * source when the reference counter drops to zero, i.e. the inner `ReplaySubject` will _not_ be unsubscribed
 * (and potentially run for ever).
 * This is the default as it is expected that `shareReplay` is often used to keep around expensive to setup
 * observables which we want to keep running instead of having to do the expensive setup again.
 *
 * As of RXJS version 6.4.0 a new overload signature was added to allow for manual control over what
 * happens when the operators internal reference counter drops to zero.
 * If `refCount` is true, the source will be unsubscribed from once the reference count drops to zero, i.e.
 * the inner `ReplaySubject` will be unsubscribed. All new subscribers will receive value emissions from a
 * new `ReplaySubject` which in turn will cause a new subscription to the source observable.
 *
 * ## Examples
 *
 * Example with a third subscriber coming late to the party
 *
 * ```ts
 * import { interval, take, shareReplay } from 'rxjs';
 *
 * const shared$ = interval(2000).pipe(
 *   take(6),
 *   shareReplay(3)
 * );
 *
 * shared$.subscribe(x => console.log('sub A: ', x));
 * shared$.subscribe(y => console.log('sub B: ', y));
 *
 * setTimeout(() => {
 *   shared$.subscribe(y => console.log('sub C: ', y));
 * }, 11000);
 *
 * // Logs:
 * // (after ~2000 ms)
 * // sub A: 0
 * // sub B: 0
 * // (after ~4000 ms)
 * // sub A: 1
 * // sub B: 1
 * // (after ~6000 ms)
 * // sub A: 2
 * // sub B: 2
 * // (after ~8000 ms)
 * // sub A: 3
 * // sub B: 3
 * // (after ~10000 ms)
 * // sub A: 4
 * // sub B: 4
 * // (after ~11000 ms, sub C gets the last 3 values)
 * // sub C: 2
 * // sub C: 3
 * // sub C: 4
 * // (after ~12000 ms)
 * // sub A: 5
 * // sub B: 5
 * // sub C: 5
 * ```
 *
 * Example for `refCount` usage
 *
 * ```ts
 * import { Observable, tap, interval, shareReplay, take } from 'rxjs';
 *
 * const log = <T>(name: string, source: Observable<T>) => source.pipe(
 *   tap({
 *     subscribe: () => console.log(`${ name }: subscribed`),
 *     next: value => console.log(`${ name }: ${ value }`),
 *     complete: () => console.log(`${ name }: completed`),
 *     finalize: () => console.log(`${ name }: unsubscribed`)
 *   })
 * );
 *
 * const obs$ = log('source', interval(1000));
 *
 * const shared$ = log('shared', obs$.pipe(
 *   shareReplay({ bufferSize: 1, refCount: true }),
 *   take(2)
 * ));
 *
 * shared$.subscribe(x => console.log('sub A: ', x));
 * shared$.subscribe(y => console.log('sub B: ', y));
 *
 * // PRINTS:
 * // shared: subscribed <-- reference count = 1
 * // source: subscribed
 * // shared: subscribed <-- reference count = 2
 * // source: 0
 * // shared: 0
 * // sub A: 0
 * // shared: 0
 * // sub B: 0
 * // source: 1
 * // shared: 1
 * // sub A: 1
 * // shared: completed <-- take(2) completes the subscription for sub A
 * // shared: unsubscribed <-- reference count = 1
 * // shared: 1
 * // sub B: 1
 * // shared: completed <-- take(2) completes the subscription for sub B
 * // shared: unsubscribed <-- reference count = 0
 * // source: unsubscribed <-- replaySubject unsubscribes from source observable because the reference count dropped to 0 and refCount is true
 *
 * // In case of refCount being false, the unsubscribe is never called on the source and the source would keep on emitting, even if no subscribers
 * // are listening.
 * // source: 2
 * // source: 3
 * // source: 4
 * // ...
 * ```
 *
 * @see {@link publish}
 * @see {@link share}
 * @see {@link publishReplay}
 *
 * @param configOrBufferSize Maximum element count of the replay buffer or {@link ShareReplayConfig configuration}
 * object.
 * @param windowTime Maximum time length of the replay buffer in milliseconds.
 * @param scheduler Scheduler where connected observers within the selector function
 * will be invoked on.
 * @return A function that returns an Observable sequence that contains the
 * elements of a sequence produced by multicasting the source sequence within a
 * selector function.
 */
export function shareReplay(configOrBufferSize, windowTime, scheduler) {
    let bufferSize;
    let refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        ({ bufferSize = Infinity, windowTime = Infinity, refCount = false, scheduler } = configOrBufferSize);
    }
    else {
        bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);
    }
    return share({
        connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount,
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc2hhcmVSZXBsYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRWpELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFZaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EySUc7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUN6QixrQkFBK0MsRUFDL0MsVUFBbUIsRUFDbkIsU0FBeUI7SUFFekIsSUFBSSxVQUFrQixDQUFDO0lBQ3ZCLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztJQUNyQixJQUFJLGtCQUFrQixJQUFJLE9BQU8sa0JBQWtCLEtBQUssUUFBUSxFQUFFLENBQUM7UUFDakUsQ0FBQyxFQUFFLFVBQVUsR0FBRyxRQUFRLEVBQUUsVUFBVSxHQUFHLFFBQVEsRUFBRSxRQUFRLEdBQUcsS0FBSyxFQUFFLFNBQVMsRUFBRSxHQUFHLGtCQUFrQixDQUFDLENBQUM7SUFDdkcsQ0FBQztTQUFNLENBQUM7UUFDTixVQUFVLEdBQUcsQ0FBQyxrQkFBa0IsYUFBbEIsa0JBQWtCLGNBQWxCLGtCQUFrQixHQUFJLFFBQVEsQ0FBVyxDQUFDO0lBQzFELENBQUM7SUFDRCxPQUFPLEtBQUssQ0FBSTtRQUNkLFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQztRQUNyRSxZQUFZLEVBQUUsSUFBSTtRQUNsQixlQUFlLEVBQUUsS0FBSztRQUN0QixtQkFBbUIsRUFBRSxRQUFRO0tBQzlCLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy9zaGFyZVJlcGxheS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlcGxheVN1YmplY3QgfSBmcm9tICcuLi9SZXBsYXlTdWJqZWN0JztcbmltcG9ydCB7IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiwgU2NoZWR1bGVyTGlrZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHNoYXJlIH0gZnJvbSAnLi9zaGFyZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhcmVSZXBsYXlDb25maWcge1xuICBidWZmZXJTaXplPzogbnVtYmVyO1xuICB3aW5kb3dUaW1lPzogbnVtYmVyO1xuICByZWZDb3VudDogYm9vbGVhbjtcbiAgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoYXJlUmVwbGF5PFQ+KGNvbmZpZzogU2hhcmVSZXBsYXlDb25maWcpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD47XG5leHBvcnQgZnVuY3Rpb24gc2hhcmVSZXBsYXk8VD4oYnVmZmVyU2l6ZT86IG51bWJlciwgd2luZG93VGltZT86IG51bWJlciwgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZSk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPjtcblxuLyoqXG4gKiBTaGFyZSBzb3VyY2UgYW5kIHJlcGxheSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVtaXNzaW9ucyBvbiBzdWJzY3JpcHRpb24uXG4gKlxuICogVGhpcyBvcGVyYXRvciBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIGByZXBsYXlgIHRoYXQgY29ubmVjdHMgdG8gYSBzb3VyY2Ugb2JzZXJ2YWJsZVxuICogYW5kIG11bHRpY2FzdHMgdGhyb3VnaCBhIGBSZXBsYXlTdWJqZWN0YCBjb25zdHJ1Y3RlZCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICogQSBzdWNjZXNzZnVsbHkgY29tcGxldGVkIHNvdXJjZSB3aWxsIHN0YXkgY2FjaGVkIGluIHRoZSBgc2hhcmVSZXBsYXlgZWQgb2JzZXJ2YWJsZSBmb3JldmVyLFxuICogYnV0IGFuIGVycm9yZWQgc291cmNlIGNhbiBiZSByZXRyaWVkLlxuICpcbiAqICMjIFdoeSB1c2UgYHNoYXJlUmVwbGF5YD9cbiAqXG4gKiBZb3UgZ2VuZXJhbGx5IHdhbnQgdG8gdXNlIGBzaGFyZVJlcGxheWAgd2hlbiB5b3UgaGF2ZSBzaWRlLWVmZmVjdHMgb3IgdGF4aW5nIGNvbXB1dGF0aW9uc1xuICogdGhhdCB5b3UgZG8gbm90IHdpc2ggdG8gYmUgZXhlY3V0ZWQgYW1vbmdzdCBtdWx0aXBsZSBzdWJzY3JpYmVycy5cbiAqIEl0IG1heSBhbHNvIGJlIHZhbHVhYmxlIGluIHNpdHVhdGlvbnMgd2hlcmUgeW91IGtub3cgeW91IHdpbGwgaGF2ZSBsYXRlIHN1YnNjcmliZXJzIHRvXG4gKiBhIHN0cmVhbSB0aGF0IG5lZWQgYWNjZXNzIHRvIHByZXZpb3VzbHkgZW1pdHRlZCB2YWx1ZXMuXG4gKiBUaGlzIGFiaWxpdHkgdG8gcmVwbGF5IHZhbHVlcyBvbiBzdWJzY3JpcHRpb24gaXMgd2hhdCBkaWZmZXJlbnRpYXRlcyB7QGxpbmsgc2hhcmV9IGFuZCBgc2hhcmVSZXBsYXlgLlxuICpcbiAqICMjIFJlZmVyZW5jZSBjb3VudGluZ1xuICpcbiAqIEJ5IGRlZmF1bHQgYHNoYXJlUmVwbGF5YCB3aWxsIHVzZSBgcmVmQ291bnRgIG9mIGZhbHNlLCBtZWFuaW5nIHRoYXQgaXQgd2lsbCBfbm90XyB1bnN1YnNjcmliZSB0aGVcbiAqIHNvdXJjZSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnRlciBkcm9wcyB0byB6ZXJvLCBpLmUuIHRoZSBpbm5lciBgUmVwbGF5U3ViamVjdGAgd2lsbCBfbm90XyBiZSB1bnN1YnNjcmliZWRcbiAqIChhbmQgcG90ZW50aWFsbHkgcnVuIGZvciBldmVyKS5cbiAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgYXMgaXQgaXMgZXhwZWN0ZWQgdGhhdCBgc2hhcmVSZXBsYXlgIGlzIG9mdGVuIHVzZWQgdG8ga2VlcCBhcm91bmQgZXhwZW5zaXZlIHRvIHNldHVwXG4gKiBvYnNlcnZhYmxlcyB3aGljaCB3ZSB3YW50IHRvIGtlZXAgcnVubmluZyBpbnN0ZWFkIG9mIGhhdmluZyB0byBkbyB0aGUgZXhwZW5zaXZlIHNldHVwIGFnYWluLlxuICpcbiAqIEFzIG9mIFJYSlMgdmVyc2lvbiA2LjQuMCBhIG5ldyBvdmVybG9hZCBzaWduYXR1cmUgd2FzIGFkZGVkIHRvIGFsbG93IGZvciBtYW51YWwgY29udHJvbCBvdmVyIHdoYXRcbiAqIGhhcHBlbnMgd2hlbiB0aGUgb3BlcmF0b3JzIGludGVybmFsIHJlZmVyZW5jZSBjb3VudGVyIGRyb3BzIHRvIHplcm8uXG4gKiBJZiBgcmVmQ291bnRgIGlzIHRydWUsIHRoZSBzb3VyY2Ugd2lsbCBiZSB1bnN1YnNjcmliZWQgZnJvbSBvbmNlIHRoZSByZWZlcmVuY2UgY291bnQgZHJvcHMgdG8gemVybywgaS5lLlxuICogdGhlIGlubmVyIGBSZXBsYXlTdWJqZWN0YCB3aWxsIGJlIHVuc3Vic2NyaWJlZC4gQWxsIG5ldyBzdWJzY3JpYmVycyB3aWxsIHJlY2VpdmUgdmFsdWUgZW1pc3Npb25zIGZyb20gYVxuICogbmV3IGBSZXBsYXlTdWJqZWN0YCB3aGljaCBpbiB0dXJuIHdpbGwgY2F1c2UgYSBuZXcgc3Vic2NyaXB0aW9uIHRvIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZS5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIEV4YW1wbGUgd2l0aCBhIHRoaXJkIHN1YnNjcmliZXIgY29taW5nIGxhdGUgdG8gdGhlIHBhcnR5XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGludGVydmFsLCB0YWtlLCBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IHNoYXJlZCQgPSBpbnRlcnZhbCgyMDAwKS5waXBlKFxuICogICB0YWtlKDYpLFxuICogICBzaGFyZVJlcGxheSgzKVxuICogKTtcbiAqXG4gKiBzaGFyZWQkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKCdzdWIgQTogJywgeCkpO1xuICogc2hhcmVkJC5zdWJzY3JpYmUoeSA9PiBjb25zb2xlLmxvZygnc3ViIEI6ICcsIHkpKTtcbiAqXG4gKiBzZXRUaW1lb3V0KCgpID0+IHtcbiAqICAgc2hhcmVkJC5zdWJzY3JpYmUoeSA9PiBjb25zb2xlLmxvZygnc3ViIEM6ICcsIHkpKTtcbiAqIH0sIDExMDAwKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gKGFmdGVyIH4yMDAwIG1zKVxuICogLy8gc3ViIEE6IDBcbiAqIC8vIHN1YiBCOiAwXG4gKiAvLyAoYWZ0ZXIgfjQwMDAgbXMpXG4gKiAvLyBzdWIgQTogMVxuICogLy8gc3ViIEI6IDFcbiAqIC8vIChhZnRlciB+NjAwMCBtcylcbiAqIC8vIHN1YiBBOiAyXG4gKiAvLyBzdWIgQjogMlxuICogLy8gKGFmdGVyIH44MDAwIG1zKVxuICogLy8gc3ViIEE6IDNcbiAqIC8vIHN1YiBCOiAzXG4gKiAvLyAoYWZ0ZXIgfjEwMDAwIG1zKVxuICogLy8gc3ViIEE6IDRcbiAqIC8vIHN1YiBCOiA0XG4gKiAvLyAoYWZ0ZXIgfjExMDAwIG1zLCBzdWIgQyBnZXRzIHRoZSBsYXN0IDMgdmFsdWVzKVxuICogLy8gc3ViIEM6IDJcbiAqIC8vIHN1YiBDOiAzXG4gKiAvLyBzdWIgQzogNFxuICogLy8gKGFmdGVyIH4xMjAwMCBtcylcbiAqIC8vIHN1YiBBOiA1XG4gKiAvLyBzdWIgQjogNVxuICogLy8gc3ViIEM6IDVcbiAqIGBgYFxuICpcbiAqIEV4YW1wbGUgZm9yIGByZWZDb3VudGAgdXNhZ2VcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgT2JzZXJ2YWJsZSwgdGFwLCBpbnRlcnZhbCwgc2hhcmVSZXBsYXksIHRha2UgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBsb2cgPSA8VD4obmFtZTogc3RyaW5nLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHNvdXJjZS5waXBlKFxuICogICB0YXAoe1xuICogICAgIHN1YnNjcmliZTogKCkgPT4gY29uc29sZS5sb2coYCR7IG5hbWUgfTogc3Vic2NyaWJlZGApLFxuICogICAgIG5leHQ6IHZhbHVlID0+IGNvbnNvbGUubG9nKGAkeyBuYW1lIH06ICR7IHZhbHVlIH1gKSxcbiAqICAgICBjb21wbGV0ZTogKCkgPT4gY29uc29sZS5sb2coYCR7IG5hbWUgfTogY29tcGxldGVkYCksXG4gKiAgICAgZmluYWxpemU6ICgpID0+IGNvbnNvbGUubG9nKGAkeyBuYW1lIH06IHVuc3Vic2NyaWJlZGApXG4gKiAgIH0pXG4gKiApO1xuICpcbiAqIGNvbnN0IG9icyQgPSBsb2coJ3NvdXJjZScsIGludGVydmFsKDEwMDApKTtcbiAqXG4gKiBjb25zdCBzaGFyZWQkID0gbG9nKCdzaGFyZWQnLCBvYnMkLnBpcGUoXG4gKiAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSksXG4gKiAgIHRha2UoMilcbiAqICkpO1xuICpcbiAqIHNoYXJlZCQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ3N1YiBBOiAnLCB4KSk7XG4gKiBzaGFyZWQkLnN1YnNjcmliZSh5ID0+IGNvbnNvbGUubG9nKCdzdWIgQjogJywgeSkpO1xuICpcbiAqIC8vIFBSSU5UUzpcbiAqIC8vIHNoYXJlZDogc3Vic2NyaWJlZCA8LS0gcmVmZXJlbmNlIGNvdW50ID0gMVxuICogLy8gc291cmNlOiBzdWJzY3JpYmVkXG4gKiAvLyBzaGFyZWQ6IHN1YnNjcmliZWQgPC0tIHJlZmVyZW5jZSBjb3VudCA9IDJcbiAqIC8vIHNvdXJjZTogMFxuICogLy8gc2hhcmVkOiAwXG4gKiAvLyBzdWIgQTogMFxuICogLy8gc2hhcmVkOiAwXG4gKiAvLyBzdWIgQjogMFxuICogLy8gc291cmNlOiAxXG4gKiAvLyBzaGFyZWQ6IDFcbiAqIC8vIHN1YiBBOiAxXG4gKiAvLyBzaGFyZWQ6IGNvbXBsZXRlZCA8LS0gdGFrZSgyKSBjb21wbGV0ZXMgdGhlIHN1YnNjcmlwdGlvbiBmb3Igc3ViIEFcbiAqIC8vIHNoYXJlZDogdW5zdWJzY3JpYmVkIDwtLSByZWZlcmVuY2UgY291bnQgPSAxXG4gKiAvLyBzaGFyZWQ6IDFcbiAqIC8vIHN1YiBCOiAxXG4gKiAvLyBzaGFyZWQ6IGNvbXBsZXRlZCA8LS0gdGFrZSgyKSBjb21wbGV0ZXMgdGhlIHN1YnNjcmlwdGlvbiBmb3Igc3ViIEJcbiAqIC8vIHNoYXJlZDogdW5zdWJzY3JpYmVkIDwtLSByZWZlcmVuY2UgY291bnQgPSAwXG4gKiAvLyBzb3VyY2U6IHVuc3Vic2NyaWJlZCA8LS0gcmVwbGF5U3ViamVjdCB1bnN1YnNjcmliZXMgZnJvbSBzb3VyY2Ugb2JzZXJ2YWJsZSBiZWNhdXNlIHRoZSByZWZlcmVuY2UgY291bnQgZHJvcHBlZCB0byAwIGFuZCByZWZDb3VudCBpcyB0cnVlXG4gKlxuICogLy8gSW4gY2FzZSBvZiByZWZDb3VudCBiZWluZyBmYWxzZSwgdGhlIHVuc3Vic2NyaWJlIGlzIG5ldmVyIGNhbGxlZCBvbiB0aGUgc291cmNlIGFuZCB0aGUgc291cmNlIHdvdWxkIGtlZXAgb24gZW1pdHRpbmcsIGV2ZW4gaWYgbm8gc3Vic2NyaWJlcnNcbiAqIC8vIGFyZSBsaXN0ZW5pbmcuXG4gKiAvLyBzb3VyY2U6IDJcbiAqIC8vIHNvdXJjZTogM1xuICogLy8gc291cmNlOiA0XG4gKiAvLyAuLi5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHB1Ymxpc2h9XG4gKiBAc2VlIHtAbGluayBzaGFyZX1cbiAqIEBzZWUge0BsaW5rIHB1Ymxpc2hSZXBsYXl9XG4gKlxuICogQHBhcmFtIGNvbmZpZ09yQnVmZmVyU2l6ZSBNYXhpbXVtIGVsZW1lbnQgY291bnQgb2YgdGhlIHJlcGxheSBidWZmZXIgb3Ige0BsaW5rIFNoYXJlUmVwbGF5Q29uZmlnIGNvbmZpZ3VyYXRpb259XG4gKiBvYmplY3QuXG4gKiBAcGFyYW0gd2luZG93VGltZSBNYXhpbXVtIHRpbWUgbGVuZ3RoIG9mIHRoZSByZXBsYXkgYnVmZmVyIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSBzY2hlZHVsZXIgU2NoZWR1bGVyIHdoZXJlIGNvbm5lY3RlZCBvYnNlcnZlcnMgd2l0aGluIHRoZSBzZWxlY3RvciBmdW5jdGlvblxuICogd2lsbCBiZSBpbnZva2VkIG9uLlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlXG4gKiBlbGVtZW50cyBvZiBhIHNlcXVlbmNlIHByb2R1Y2VkIGJ5IG11bHRpY2FzdGluZyB0aGUgc291cmNlIHNlcXVlbmNlIHdpdGhpbiBhXG4gKiBzZWxlY3RvciBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYXJlUmVwbGF5PFQ+KFxuICBjb25maWdPckJ1ZmZlclNpemU/OiBTaGFyZVJlcGxheUNvbmZpZyB8IG51bWJlcixcbiAgd2luZG93VGltZT86IG51bWJlcixcbiAgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZVxuKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgbGV0IGJ1ZmZlclNpemU6IG51bWJlcjtcbiAgbGV0IHJlZkNvdW50ID0gZmFsc2U7XG4gIGlmIChjb25maWdPckJ1ZmZlclNpemUgJiYgdHlwZW9mIGNvbmZpZ09yQnVmZmVyU2l6ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAoeyBidWZmZXJTaXplID0gSW5maW5pdHksIHdpbmRvd1RpbWUgPSBJbmZpbml0eSwgcmVmQ291bnQgPSBmYWxzZSwgc2NoZWR1bGVyIH0gPSBjb25maWdPckJ1ZmZlclNpemUpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlclNpemUgPSAoY29uZmlnT3JCdWZmZXJTaXplID8/IEluZmluaXR5KSBhcyBudW1iZXI7XG4gIH1cbiAgcmV0dXJuIHNoYXJlPFQ+KHtcbiAgICBjb25uZWN0b3I6ICgpID0+IG5ldyBSZXBsYXlTdWJqZWN0KGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNjaGVkdWxlciksXG4gICAgcmVzZXRPbkVycm9yOiB0cnVlLFxuICAgIHJlc2V0T25Db21wbGV0ZTogZmFsc2UsXG4gICAgcmVzZXRPblJlZkNvdW50WmVybzogcmVmQ291bnQsXG4gIH0pO1xufVxuIl19
