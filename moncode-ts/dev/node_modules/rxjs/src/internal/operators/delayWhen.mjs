import { concat } from '../observable/concat.mjs';
import { take } from './take.mjs';
import { ignoreElements } from './ignoreElements.mjs';
import { mapTo } from './mapTo.mjs';
import { mergeMap } from './mergeMap.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
/**
 * Delays the emission of items from the source Observable by a given time span
 * determined by the emissions of another Observable.
 *
 * <span class="informal">It's like {@link delay}, but the time span of the
 * delay duration is determined by a second Observable.</span>
 *
 * ![](delayWhen.png)
 *
 * `delayWhen` operator shifts each emitted value from the source Observable by
 * a time span determined by another Observable. When the source emits a value,
 * the `delayDurationSelector` function is called with the value emitted from
 * the source Observable as the first argument to the `delayDurationSelector`.
 * The `delayDurationSelector` function should return an {@link ObservableInput},
 * that is internally converted to an Observable that is called the "duration"
 * Observable.
 *
 * The source value is emitted on the output Observable only when the "duration"
 * Observable emits ({@link guide/glossary-and-semantics#next next}s) any value.
 * Upon that, the "duration" Observable gets unsubscribed.
 *
 * Before RxJS V7, the {@link guide/glossary-and-semantics#complete completion}
 * of the "duration" Observable would have been triggering the emission of the
 * source value to the output Observable, but with RxJS V7, this is not the case
 * anymore.
 *
 * Only next notifications (from the "duration" Observable) trigger values from
 * the source Observable to be passed to the output Observable. If the "duration"
 * Observable only emits the complete notification (without next), the value
 * emitted by the source Observable will never get to the output Observable - it
 * will be swallowed. If the "duration" Observable errors, the error will be
 * propagated to the output Observable.
 *
 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
 * is an Observable. When `subscriptionDelay` emits its first value or
 * completes, the source Observable is subscribed to and starts behaving like
 * described in the previous paragraph. If `subscriptionDelay` is not provided,
 * `delayWhen` will subscribe to the source Observable as soon as the output
 * Observable is subscribed.
 *
 * ## Example
 *
 * Delay each click by a random amount of time, between 0 and 5 seconds
 *
 * ```ts
 * import { fromEvent, delayWhen, interval } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const delayedClicks = clicks.pipe(
 *   delayWhen(() => interval(Math.random() * 5000))
 * );
 * delayedClicks.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link delay}
 * @see {@link throttle}
 * @see {@link throttleTime}
 * @see {@link debounce}
 * @see {@link debounceTime}
 * @see {@link sample}
 * @see {@link sampleTime}
 * @see {@link audit}
 * @see {@link auditTime}
 *
 * @param delayDurationSelector A function that returns an `ObservableInput` for
 * each `value` emitted by the source Observable, which is then used to delay the
 * emission of that `value` on the output Observable until the `ObservableInput`
 * returned from this function emits a next value. When called, beside `value`,
 * this function receives a zero-based `index` of the emission order.
 * @param subscriptionDelay An Observable that triggers the subscription to the
 * source Observable once it emits any value.
 * @return A function that returns an Observable that delays the emissions of
 * the source Observable by an amount of time specified by the Observable
 * returned by `delayDurationSelector`.
 */
export function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        // DEPRECATED PATH
        return (source) => concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    }
    return mergeMap((value, index) => innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)));
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVsYXlXaGVuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzlCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ2hDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDdEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBU3BEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTBFRztBQUNILE1BQU0sVUFBVSxTQUFTLENBQ3ZCLHFCQUF3RSxFQUN4RSxpQkFBbUM7SUFFbkMsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO1FBQ3RCLGtCQUFrQjtRQUNsQixPQUFPLENBQUMsTUFBcUIsRUFBRSxFQUFFLENBQy9CLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLGNBQWMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0csQ0FBQztJQUVELE9BQU8sUUFBUSxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLHFCQUFxQixDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoSCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVsYXlXaGVuLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tICcuLi9vYnNlcnZhYmxlL2NvbmNhdCc7XG5pbXBvcnQgeyB0YWtlIH0gZnJvbSAnLi90YWtlJztcbmltcG9ydCB7IGlnbm9yZUVsZW1lbnRzIH0gZnJvbSAnLi9pZ25vcmVFbGVtZW50cyc7XG5pbXBvcnQgeyBtYXBUbyB9IGZyb20gJy4vbWFwVG8nO1xuaW1wb3J0IHsgbWVyZ2VNYXAgfSBmcm9tICcuL21lcmdlTWFwJztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcblxuLyoqIEBkZXByZWNhdGVkIFRoZSBgc3Vic2NyaXB0aW9uRGVsYXlgIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gdjguICovXG5leHBvcnQgZnVuY3Rpb24gZGVsYXlXaGVuPFQ+KFxuICBkZWxheUR1cmF0aW9uU2VsZWN0b3I6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZUlucHV0PGFueT4sXG4gIHN1YnNjcmlwdGlvbkRlbGF5OiBPYnNlcnZhYmxlPGFueT5cbik6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPjtcbmV4cG9ydCBmdW5jdGlvbiBkZWxheVdoZW48VD4oZGVsYXlEdXJhdGlvblNlbGVjdG9yOiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE9ic2VydmFibGVJbnB1dDxhbnk+KTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+O1xuXG4vKipcbiAqIERlbGF5cyB0aGUgZW1pc3Npb24gb2YgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYSBnaXZlbiB0aW1lIHNwYW5cbiAqIGRldGVybWluZWQgYnkgdGhlIGVtaXNzaW9ucyBvZiBhbm90aGVyIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVsYXl9LCBidXQgdGhlIHRpbWUgc3BhbiBvZiB0aGVcbiAqIGRlbGF5IGR1cmF0aW9uIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogIVtdKGRlbGF5V2hlbi5wbmcpXG4gKlxuICogYGRlbGF5V2hlbmAgb3BlcmF0b3Igc2hpZnRzIGVhY2ggZW1pdHRlZCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieVxuICogYSB0aW1lIHNwYW4gZGV0ZXJtaW5lZCBieSBhbm90aGVyIE9ic2VydmFibGUuIFdoZW4gdGhlIHNvdXJjZSBlbWl0cyBhIHZhbHVlLFxuICogdGhlIGBkZWxheUR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBlbWl0dGVkIGZyb21cbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGBkZWxheUR1cmF0aW9uU2VsZWN0b3JgLlxuICogVGhlIGBkZWxheUR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYW4ge0BsaW5rIE9ic2VydmFibGVJbnB1dH0sXG4gKiB0aGF0IGlzIGludGVybmFsbHkgY29udmVydGVkIHRvIGFuIE9ic2VydmFibGUgdGhhdCBpcyBjYWxsZWQgdGhlIFwiZHVyYXRpb25cIlxuICogT2JzZXJ2YWJsZS5cbiAqXG4gKiBUaGUgc291cmNlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgd2hlbiB0aGUgXCJkdXJhdGlvblwiXG4gKiBPYnNlcnZhYmxlIGVtaXRzICh7QGxpbmsgZ3VpZGUvZ2xvc3NhcnktYW5kLXNlbWFudGljcyNuZXh0IG5leHR9cykgYW55IHZhbHVlLlxuICogVXBvbiB0aGF0LCB0aGUgXCJkdXJhdGlvblwiIE9ic2VydmFibGUgZ2V0cyB1bnN1YnNjcmliZWQuXG4gKlxuICogQmVmb3JlIFJ4SlMgVjcsIHRoZSB7QGxpbmsgZ3VpZGUvZ2xvc3NhcnktYW5kLXNlbWFudGljcyNjb21wbGV0ZSBjb21wbGV0aW9ufVxuICogb2YgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlIHdvdWxkIGhhdmUgYmVlbiB0cmlnZ2VyaW5nIHRoZSBlbWlzc2lvbiBvZiB0aGVcbiAqIHNvdXJjZSB2YWx1ZSB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUsIGJ1dCB3aXRoIFJ4SlMgVjcsIHRoaXMgaXMgbm90IHRoZSBjYXNlXG4gKiBhbnltb3JlLlxuICpcbiAqIE9ubHkgbmV4dCBub3RpZmljYXRpb25zIChmcm9tIHRoZSBcImR1cmF0aW9uXCIgT2JzZXJ2YWJsZSkgdHJpZ2dlciB2YWx1ZXMgZnJvbVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRvIGJlIHBhc3NlZCB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUuIElmIHRoZSBcImR1cmF0aW9uXCJcbiAqIE9ic2VydmFibGUgb25seSBlbWl0cyB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uICh3aXRob3V0IG5leHQpLCB0aGUgdmFsdWVcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpbGwgbmV2ZXIgZ2V0IHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSAtIGl0XG4gKiB3aWxsIGJlIHN3YWxsb3dlZC4gSWYgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlIGVycm9ycywgdGhlIGVycm9yIHdpbGwgYmVcbiAqIHByb3BhZ2F0ZWQgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIE9wdGlvbmFsbHksIGBkZWxheVdoZW5gIHRha2VzIGEgc2Vjb25kIGFyZ3VtZW50LCBgc3Vic2NyaXB0aW9uRGVsYXlgLCB3aGljaFxuICogaXMgYW4gT2JzZXJ2YWJsZS4gV2hlbiBgc3Vic2NyaXB0aW9uRGVsYXlgIGVtaXRzIGl0cyBmaXJzdCB2YWx1ZSBvclxuICogY29tcGxldGVzLCB0aGUgc291cmNlIE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZCB0byBhbmQgc3RhcnRzIGJlaGF2aW5nIGxpa2VcbiAqIGRlc2NyaWJlZCBpbiB0aGUgcHJldmlvdXMgcGFyYWdyYXBoLiBJZiBgc3Vic2NyaXB0aW9uRGVsYXlgIGlzIG5vdCBwcm92aWRlZCxcbiAqIGBkZWxheVdoZW5gIHdpbGwgc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhcyBzb29uIGFzIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZC5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogRGVsYXkgZWFjaCBjbGljayBieSBhIHJhbmRvbSBhbW91bnQgb2YgdGltZSwgYmV0d2VlbiAwIGFuZCA1IHNlY29uZHNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50LCBkZWxheVdoZW4sIGludGVydmFsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IGRlbGF5ZWRDbGlja3MgPSBjbGlja3MucGlwZShcbiAqICAgZGVsYXlXaGVuKCgpID0+IGludGVydmFsKE1hdGgucmFuZG9tKCkgKiA1MDAwKSlcbiAqICk7XG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayBhdWRpdH1cbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqXG4gKiBAcGFyYW0gZGVsYXlEdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGBPYnNlcnZhYmxlSW5wdXRgIGZvclxuICogZWFjaCBgdmFsdWVgIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGljaCBpcyB0aGVuIHVzZWQgdG8gZGVsYXkgdGhlXG4gKiBlbWlzc2lvbiBvZiB0aGF0IGB2YWx1ZWAgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIHVudGlsIHRoZSBgT2JzZXJ2YWJsZUlucHV0YFxuICogcmV0dXJuZWQgZnJvbSB0aGlzIGZ1bmN0aW9uIGVtaXRzIGEgbmV4dCB2YWx1ZS4gV2hlbiBjYWxsZWQsIGJlc2lkZSBgdmFsdWVgLFxuICogdGhpcyBmdW5jdGlvbiByZWNlaXZlcyBhIHplcm8tYmFzZWQgYGluZGV4YCBvZiB0aGUgZW1pc3Npb24gb3JkZXIuXG4gKiBAcGFyYW0gc3Vic2NyaXB0aW9uRGVsYXkgQW4gT2JzZXJ2YWJsZSB0aGF0IHRyaWdnZXJzIHRoZSBzdWJzY3JpcHRpb24gdG8gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZSBvbmNlIGl0IGVtaXRzIGFueSB2YWx1ZS5cbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYW4gYW1vdW50IG9mIHRpbWUgc3BlY2lmaWVkIGJ5IHRoZSBPYnNlcnZhYmxlXG4gKiByZXR1cm5lZCBieSBgZGVsYXlEdXJhdGlvblNlbGVjdG9yYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5V2hlbjxUPihcbiAgZGVsYXlEdXJhdGlvblNlbGVjdG9yOiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE9ic2VydmFibGVJbnB1dDxhbnk+LFxuICBzdWJzY3JpcHRpb25EZWxheT86IE9ic2VydmFibGU8YW55PlxuKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgaWYgKHN1YnNjcmlwdGlvbkRlbGF5KSB7XG4gICAgLy8gREVQUkVDQVRFRCBQQVRIXG4gICAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+XG4gICAgICBjb25jYXQoc3Vic2NyaXB0aW9uRGVsYXkucGlwZSh0YWtlKDEpLCBpZ25vcmVFbGVtZW50cygpKSwgc291cmNlLnBpcGUoZGVsYXlXaGVuKGRlbGF5RHVyYXRpb25TZWxlY3RvcikpKTtcbiAgfVxuXG4gIHJldHVybiBtZXJnZU1hcCgodmFsdWUsIGluZGV4KSA9PiBpbm5lckZyb20oZGVsYXlEdXJhdGlvblNlbGVjdG9yKHZhbHVlLCBpbmRleCkpLnBpcGUodGFrZSgxKSwgbWFwVG8odmFsdWUpKSk7XG59XG4iXX0=
