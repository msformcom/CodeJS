import { innerFrom } from '../observable/innerFrom.mjs';
import { executeSchedule } from '../util/executeSchedule.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * A process embodying the general "merge" strategy. This is used in
 * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.
 * @param source The original source observable
 * @param subscriber The consumer subscriber
 * @param project The projection function to get our inner sources
 * @param concurrent The number of concurrent inner subscriptions
 * @param onBeforeNext Additional logic to apply before nexting to our consumer
 * @param expand If `true` this will perform an "expand" strategy, which differs only
 * in that it recurses, and the inner subscription must be schedule-able.
 * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,
 * this is to support the expand strategy, mostly, and should be deprecated
 */
export function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    // Buffered values, in the event of going over our concurrency limit
    const buffer = [];
    // The number of active inner subscriptions.
    let active = 0;
    // An index to pass to our accumulator function
    let index = 0;
    // Whether or not the outer source has completed.
    let isComplete = false;
    /**
     * Checks to see if we can complete our result or not.
     */
    const checkComplete = () => {
        // If the outer has completed, and nothing is left in the buffer,
        // and we don't have any active inner subscriptions, then we can
        // Emit the state and complete.
        if (isComplete && !buffer.length && !active) {
            subscriber.complete();
        }
    };
    // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.
    const outerNext = (value) => (active < concurrent ? doInnerSub(value) : buffer.push(value));
    const doInnerSub = (value) => {
        // If we're expanding, we need to emit the outer values and the inner values
        // as the inners will "become outers" in a way as they are recursively fed
        // back to the projection mechanism.
        expand && subscriber.next(value);
        // Increment the number of active subscriptions so we can track it
        // against our concurrency limit later.
        active++;
        // A flag used to show that the inner observable completed.
        // This is checked during finalization to see if we should
        // move to the next item in the buffer, if there is on.
        let innerComplete = false;
        // Start our inner subscription.
        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {
            // `mergeScan` has additional handling here. For example
            // taking the inner value and updating state.
            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
            if (expand) {
                // If we're expanding, then just recurse back to our outer
                // handler. It will emit the value first thing.
                outerNext(innerValue);
            }
            else {
                // Otherwise, emit the inner value.
                subscriber.next(innerValue);
            }
        }, () => {
            // Flag that we have completed, so we know to check the buffer
            // during finalization.
            innerComplete = true;
        }, 
        // Errors are passed to the destination.
        undefined, () => {
            // During finalization, if the inner completed (it wasn't errored or
            // cancelled), then we want to try the next item in the buffer if
            // there is one.
            if (innerComplete) {
                // We have to wrap this in a try/catch because it happens during
                // finalization, possibly asynchronously, and we want to pass
                // any errors that happen (like in a projection function) to
                // the outer Subscriber.
                try {
                    // INNER SOURCE COMPLETE
                    // Decrement the active count to ensure that the next time
                    // we try to call `doInnerSub`, the number is accurate.
                    active--;
                    // If we have more values in the buffer, try to process those
                    // Note that this call will increment `active` ahead of the
                    // next conditional, if there were any more inner subscriptions
                    // to start.
                    while (buffer.length && active < concurrent) {
                        const bufferedValue = buffer.shift();
                        // Particularly for `expand`, we need to check to see if a scheduler was provided
                        // for when we want to start our inner subscription. Otherwise, we just start
                        // are next inner subscription.
                        if (innerSubScheduler) {
                            executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
                        }
                        else {
                            doInnerSub(bufferedValue);
                        }
                    }
                    // Check to see if we can complete, and complete if so.
                    checkComplete();
                }
                catch (err) {
                    subscriber.error(err);
                }
            }
        }));
    };
    // Subscribe to our source observable.
    source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {
        // Outer completed, make a note of it, and check to see if we can complete everything.
        isComplete = true;
        checkComplete();
    }));
    // Additional finalization (for when the destination is torn down).
    // Other finalization is added implicitly via subscription above.
    return () => {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VJbnRlcm5hbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBR3BELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUVoRTs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxNQUFNLFVBQVUsY0FBYyxDQUM1QixNQUFxQixFQUNyQixVQUF5QixFQUN6QixPQUF3RCxFQUN4RCxVQUFrQixFQUNsQixZQUFzQyxFQUN0QyxNQUFnQixFQUNoQixpQkFBaUMsRUFDakMsbUJBQWdDO0lBRWhDLG9FQUFvRTtJQUNwRSxNQUFNLE1BQU0sR0FBUSxFQUFFLENBQUM7SUFDdkIsNENBQTRDO0lBQzVDLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNmLCtDQUErQztJQUMvQyxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxpREFBaUQ7SUFDakQsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO0lBRXZCOztPQUVHO0lBQ0gsTUFBTSxhQUFhLEdBQUcsR0FBRyxFQUFFO1FBQ3pCLGlFQUFpRTtRQUNqRSxnRUFBZ0U7UUFDaEUsK0JBQStCO1FBQy9CLElBQUksVUFBVSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQzVDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN4QixDQUFDO0lBQ0gsQ0FBQyxDQUFDO0lBRUYsc0dBQXNHO0lBQ3RHLE1BQU0sU0FBUyxHQUFHLENBQUMsS0FBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBRS9GLE1BQU0sVUFBVSxHQUFHLENBQUMsS0FBUSxFQUFFLEVBQUU7UUFDOUIsNEVBQTRFO1FBQzVFLDBFQUEwRTtRQUMxRSxvQ0FBb0M7UUFDcEMsTUFBTSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBWSxDQUFDLENBQUM7UUFFeEMsa0VBQWtFO1FBQ2xFLHVDQUF1QztRQUN2QyxNQUFNLEVBQUUsQ0FBQztRQUVULDJEQUEyRDtRQUMzRCwwREFBMEQ7UUFDMUQsdURBQXVEO1FBQ3ZELElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQztRQUUxQixnQ0FBZ0M7UUFDaEMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FDMUMsd0JBQXdCLENBQ3RCLFVBQVUsRUFDVixDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQ2Isd0RBQXdEO1lBQ3hELDZDQUE2QztZQUM3QyxZQUFZLGFBQVosWUFBWSx1QkFBWixZQUFZLENBQUcsVUFBVSxDQUFDLENBQUM7WUFFM0IsSUFBSSxNQUFNLEVBQUUsQ0FBQztnQkFDWCwwREFBMEQ7Z0JBQzFELCtDQUErQztnQkFDL0MsU0FBUyxDQUFDLFVBQWlCLENBQUMsQ0FBQztZQUMvQixDQUFDO2lCQUFNLENBQUM7Z0JBQ04sbUNBQW1DO2dCQUNuQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzlCLENBQUM7UUFDSCxDQUFDLEVBQ0QsR0FBRyxFQUFFO1lBQ0gsOERBQThEO1lBQzlELHVCQUF1QjtZQUN2QixhQUFhLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLENBQUM7UUFDRCx3Q0FBd0M7UUFDeEMsU0FBUyxFQUNULEdBQUcsRUFBRTtZQUNILG9FQUFvRTtZQUNwRSxpRUFBaUU7WUFDakUsZ0JBQWdCO1lBQ2hCLElBQUksYUFBYSxFQUFFLENBQUM7Z0JBQ2xCLGdFQUFnRTtnQkFDaEUsNkRBQTZEO2dCQUM3RCw0REFBNEQ7Z0JBQzVELHdCQUF3QjtnQkFDeEIsSUFBSSxDQUFDO29CQUNILHdCQUF3QjtvQkFDeEIsMERBQTBEO29CQUMxRCx1REFBdUQ7b0JBQ3ZELE1BQU0sRUFBRSxDQUFDO29CQUNULDZEQUE2RDtvQkFDN0QsMkRBQTJEO29CQUMzRCwrREFBK0Q7b0JBQy9ELFlBQVk7b0JBQ1osT0FBTyxNQUFNLENBQUMsTUFBTSxJQUFJLE1BQU0sR0FBRyxVQUFVLEVBQUUsQ0FBQzt3QkFDNUMsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRyxDQUFDO3dCQUN0QyxpRkFBaUY7d0JBQ2pGLDZFQUE2RTt3QkFDN0UsK0JBQStCO3dCQUMvQixJQUFJLGlCQUFpQixFQUFFLENBQUM7NEJBQ3RCLGVBQWUsQ0FBQyxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7d0JBQ2xGLENBQUM7NkJBQU0sQ0FBQzs0QkFDTixVQUFVLENBQUMsYUFBYSxDQUFDLENBQUM7d0JBQzVCLENBQUM7b0JBQ0gsQ0FBQztvQkFDRCx1REFBdUQ7b0JBQ3ZELGFBQWEsRUFBRSxDQUFDO2dCQUNsQixDQUFDO2dCQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7b0JBQ2IsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDeEIsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDLENBQ0YsQ0FDRixDQUFDO0lBQ0osQ0FBQyxDQUFDO0lBRUYsc0NBQXNDO0lBQ3RDLE1BQU0sQ0FBQyxTQUFTLENBQ2Qsd0JBQXdCLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUU7UUFDbkQsc0ZBQXNGO1FBQ3RGLFVBQVUsR0FBRyxJQUFJLENBQUM7UUFDbEIsYUFBYSxFQUFFLENBQUM7SUFDbEIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUVGLG1FQUFtRTtJQUNuRSxpRUFBaUU7SUFDakUsT0FBTyxHQUFHLEVBQUU7UUFDVixtQkFBbUIsYUFBbkIsbUJBQW1CLHVCQUFuQixtQkFBbUIsRUFBSSxDQUFDO0lBQzFCLENBQUMsQ0FBQztBQUNKLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZUludGVybmFscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGVJbnB1dCwgU2NoZWR1bGVyTGlrZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGV4ZWN1dGVTY2hlZHVsZSB9IGZyb20gJy4uL3V0aWwvZXhlY3V0ZVNjaGVkdWxlJztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcblxuLyoqXG4gKiBBIHByb2Nlc3MgZW1ib2R5aW5nIHRoZSBnZW5lcmFsIFwibWVyZ2VcIiBzdHJhdGVneS4gVGhpcyBpcyB1c2VkIGluXG4gKiBgbWVyZ2VNYXBgIGFuZCBgbWVyZ2VTY2FuYCBiZWNhdXNlIHRoZSBsb2dpYyBpcyBvdGhlcndpc2UgbmVhcmx5IGlkZW50aWNhbC5cbiAqIEBwYXJhbSBzb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSBvYnNlcnZhYmxlXG4gKiBAcGFyYW0gc3Vic2NyaWJlciBUaGUgY29uc3VtZXIgc3Vic2NyaWJlclxuICogQHBhcmFtIHByb2plY3QgVGhlIHByb2plY3Rpb24gZnVuY3Rpb24gdG8gZ2V0IG91ciBpbm5lciBzb3VyY2VzXG4gKiBAcGFyYW0gY29uY3VycmVudCBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgaW5uZXIgc3Vic2NyaXB0aW9uc1xuICogQHBhcmFtIG9uQmVmb3JlTmV4dCBBZGRpdGlvbmFsIGxvZ2ljIHRvIGFwcGx5IGJlZm9yZSBuZXh0aW5nIHRvIG91ciBjb25zdW1lclxuICogQHBhcmFtIGV4cGFuZCBJZiBgdHJ1ZWAgdGhpcyB3aWxsIHBlcmZvcm0gYW4gXCJleHBhbmRcIiBzdHJhdGVneSwgd2hpY2ggZGlmZmVycyBvbmx5XG4gKiBpbiB0aGF0IGl0IHJlY3Vyc2VzLCBhbmQgdGhlIGlubmVyIHN1YnNjcmlwdGlvbiBtdXN0IGJlIHNjaGVkdWxlLWFibGUuXG4gKiBAcGFyYW0gaW5uZXJTdWJTY2hlZHVsZXIgQSBzY2hlZHVsZXIgdG8gdXNlIHRvIHNjaGVkdWxlIGlubmVyIHN1YnNjcmlwdGlvbnMsXG4gKiB0aGlzIGlzIHRvIHN1cHBvcnQgdGhlIGV4cGFuZCBzdHJhdGVneSwgbW9zdGx5LCBhbmQgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSW50ZXJuYWxzPFQsIFI+KFxuICBzb3VyY2U6IE9ic2VydmFibGU8VD4sXG4gIHN1YnNjcmliZXI6IFN1YnNjcmliZXI8Uj4sXG4gIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZUlucHV0PFI+LFxuICBjb25jdXJyZW50OiBudW1iZXIsXG4gIG9uQmVmb3JlTmV4dD86IChpbm5lclZhbHVlOiBSKSA9PiB2b2lkLFxuICBleHBhbmQ/OiBib29sZWFuLFxuICBpbm5lclN1YlNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2UsXG4gIGFkZGl0aW9uYWxGaW5hbGl6ZXI/OiAoKSA9PiB2b2lkXG4pIHtcbiAgLy8gQnVmZmVyZWQgdmFsdWVzLCBpbiB0aGUgZXZlbnQgb2YgZ29pbmcgb3ZlciBvdXIgY29uY3VycmVuY3kgbGltaXRcbiAgY29uc3QgYnVmZmVyOiBUW10gPSBbXTtcbiAgLy8gVGhlIG51bWJlciBvZiBhY3RpdmUgaW5uZXIgc3Vic2NyaXB0aW9ucy5cbiAgbGV0IGFjdGl2ZSA9IDA7XG4gIC8vIEFuIGluZGV4IHRvIHBhc3MgdG8gb3VyIGFjY3VtdWxhdG9yIGZ1bmN0aW9uXG4gIGxldCBpbmRleCA9IDA7XG4gIC8vIFdoZXRoZXIgb3Igbm90IHRoZSBvdXRlciBzb3VyY2UgaGFzIGNvbXBsZXRlZC5cbiAgbGV0IGlzQ29tcGxldGUgPSBmYWxzZTtcblxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiB3ZSBjYW4gY29tcGxldGUgb3VyIHJlc3VsdCBvciBub3QuXG4gICAqL1xuICBjb25zdCBjaGVja0NvbXBsZXRlID0gKCkgPT4ge1xuICAgIC8vIElmIHRoZSBvdXRlciBoYXMgY29tcGxldGVkLCBhbmQgbm90aGluZyBpcyBsZWZ0IGluIHRoZSBidWZmZXIsXG4gICAgLy8gYW5kIHdlIGRvbid0IGhhdmUgYW55IGFjdGl2ZSBpbm5lciBzdWJzY3JpcHRpb25zLCB0aGVuIHdlIGNhblxuICAgIC8vIEVtaXQgdGhlIHN0YXRlIGFuZCBjb21wbGV0ZS5cbiAgICBpZiAoaXNDb21wbGV0ZSAmJiAhYnVmZmVyLmxlbmd0aCAmJiAhYWN0aXZlKSB7XG4gICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIElmIHdlJ3JlIHVuZGVyIG91ciBjb25jdXJyZW5jeSBsaW1pdCwganVzdCBzdGFydCB0aGUgaW5uZXIgc3Vic2NyaXB0aW9uLCBvdGhlcndpc2UgYnVmZmVyIGFuZCB3YWl0LlxuICBjb25zdCBvdXRlck5leHQgPSAodmFsdWU6IFQpID0+IChhY3RpdmUgPCBjb25jdXJyZW50ID8gZG9Jbm5lclN1Yih2YWx1ZSkgOiBidWZmZXIucHVzaCh2YWx1ZSkpO1xuXG4gIGNvbnN0IGRvSW5uZXJTdWIgPSAodmFsdWU6IFQpID0+IHtcbiAgICAvLyBJZiB3ZSdyZSBleHBhbmRpbmcsIHdlIG5lZWQgdG8gZW1pdCB0aGUgb3V0ZXIgdmFsdWVzIGFuZCB0aGUgaW5uZXIgdmFsdWVzXG4gICAgLy8gYXMgdGhlIGlubmVycyB3aWxsIFwiYmVjb21lIG91dGVyc1wiIGluIGEgd2F5IGFzIHRoZXkgYXJlIHJlY3Vyc2l2ZWx5IGZlZFxuICAgIC8vIGJhY2sgdG8gdGhlIHByb2plY3Rpb24gbWVjaGFuaXNtLlxuICAgIGV4cGFuZCAmJiBzdWJzY3JpYmVyLm5leHQodmFsdWUgYXMgYW55KTtcblxuICAgIC8vIEluY3JlbWVudCB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBzdWJzY3JpcHRpb25zIHNvIHdlIGNhbiB0cmFjayBpdFxuICAgIC8vIGFnYWluc3Qgb3VyIGNvbmN1cnJlbmN5IGxpbWl0IGxhdGVyLlxuICAgIGFjdGl2ZSsrO1xuXG4gICAgLy8gQSBmbGFnIHVzZWQgdG8gc2hvdyB0aGF0IHRoZSBpbm5lciBvYnNlcnZhYmxlIGNvbXBsZXRlZC5cbiAgICAvLyBUaGlzIGlzIGNoZWNrZWQgZHVyaW5nIGZpbmFsaXphdGlvbiB0byBzZWUgaWYgd2Ugc2hvdWxkXG4gICAgLy8gbW92ZSB0byB0aGUgbmV4dCBpdGVtIGluIHRoZSBidWZmZXIsIGlmIHRoZXJlIGlzIG9uLlxuICAgIGxldCBpbm5lckNvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAvLyBTdGFydCBvdXIgaW5uZXIgc3Vic2NyaXB0aW9uLlxuICAgIGlubmVyRnJvbShwcm9qZWN0KHZhbHVlLCBpbmRleCsrKSkuc3Vic2NyaWJlKFxuICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAoaW5uZXJWYWx1ZSkgPT4ge1xuICAgICAgICAgIC8vIGBtZXJnZVNjYW5gIGhhcyBhZGRpdGlvbmFsIGhhbmRsaW5nIGhlcmUuIEZvciBleGFtcGxlXG4gICAgICAgICAgLy8gdGFraW5nIHRoZSBpbm5lciB2YWx1ZSBhbmQgdXBkYXRpbmcgc3RhdGUuXG4gICAgICAgICAgb25CZWZvcmVOZXh0Py4oaW5uZXJWYWx1ZSk7XG5cbiAgICAgICAgICBpZiAoZXhwYW5kKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBleHBhbmRpbmcsIHRoZW4ganVzdCByZWN1cnNlIGJhY2sgdG8gb3VyIG91dGVyXG4gICAgICAgICAgICAvLyBoYW5kbGVyLiBJdCB3aWxsIGVtaXQgdGhlIHZhbHVlIGZpcnN0IHRoaW5nLlxuICAgICAgICAgICAgb3V0ZXJOZXh0KGlubmVyVmFsdWUgYXMgYW55KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBlbWl0IHRoZSBpbm5lciB2YWx1ZS5cbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBGbGFnIHRoYXQgd2UgaGF2ZSBjb21wbGV0ZWQsIHNvIHdlIGtub3cgdG8gY2hlY2sgdGhlIGJ1ZmZlclxuICAgICAgICAgIC8vIGR1cmluZyBmaW5hbGl6YXRpb24uXG4gICAgICAgICAgaW5uZXJDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVycm9ycyBhcmUgcGFzc2VkIHRvIHRoZSBkZXN0aW5hdGlvbi5cbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gRHVyaW5nIGZpbmFsaXphdGlvbiwgaWYgdGhlIGlubmVyIGNvbXBsZXRlZCAoaXQgd2Fzbid0IGVycm9yZWQgb3JcbiAgICAgICAgICAvLyBjYW5jZWxsZWQpLCB0aGVuIHdlIHdhbnQgdG8gdHJ5IHRoZSBuZXh0IGl0ZW0gaW4gdGhlIGJ1ZmZlciBpZlxuICAgICAgICAgIC8vIHRoZXJlIGlzIG9uZS5cbiAgICAgICAgICBpZiAoaW5uZXJDb21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoaXMgaW4gYSB0cnkvY2F0Y2ggYmVjYXVzZSBpdCBoYXBwZW5zIGR1cmluZ1xuICAgICAgICAgICAgLy8gZmluYWxpemF0aW9uLCBwb3NzaWJseSBhc3luY2hyb25vdXNseSwgYW5kIHdlIHdhbnQgdG8gcGFzc1xuICAgICAgICAgICAgLy8gYW55IGVycm9ycyB0aGF0IGhhcHBlbiAobGlrZSBpbiBhIHByb2plY3Rpb24gZnVuY3Rpb24pIHRvXG4gICAgICAgICAgICAvLyB0aGUgb3V0ZXIgU3Vic2NyaWJlci5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIElOTkVSIFNPVVJDRSBDT01QTEVURVxuICAgICAgICAgICAgICAvLyBEZWNyZW1lbnQgdGhlIGFjdGl2ZSBjb3VudCB0byBlbnN1cmUgdGhhdCB0aGUgbmV4dCB0aW1lXG4gICAgICAgICAgICAgIC8vIHdlIHRyeSB0byBjYWxsIGBkb0lubmVyU3ViYCwgdGhlIG51bWJlciBpcyBhY2N1cmF0ZS5cbiAgICAgICAgICAgICAgYWN0aXZlLS07XG4gICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB2YWx1ZXMgaW4gdGhlIGJ1ZmZlciwgdHJ5IHRvIHByb2Nlc3MgdGhvc2VcbiAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgY2FsbCB3aWxsIGluY3JlbWVudCBgYWN0aXZlYCBhaGVhZCBvZiB0aGVcbiAgICAgICAgICAgICAgLy8gbmV4dCBjb25kaXRpb25hbCwgaWYgdGhlcmUgd2VyZSBhbnkgbW9yZSBpbm5lciBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICAgIC8vIHRvIHN0YXJ0LlxuICAgICAgICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCAmJiBhY3RpdmUgPCBjb25jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyZWRWYWx1ZSA9IGJ1ZmZlci5zaGlmdCgpITtcbiAgICAgICAgICAgICAgICAvLyBQYXJ0aWN1bGFybHkgZm9yIGBleHBhbmRgLCB3ZSBuZWVkIHRvIGNoZWNrIHRvIHNlZSBpZiBhIHNjaGVkdWxlciB3YXMgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAvLyBmb3Igd2hlbiB3ZSB3YW50IHRvIHN0YXJ0IG91ciBpbm5lciBzdWJzY3JpcHRpb24uIE90aGVyd2lzZSwgd2UganVzdCBzdGFydFxuICAgICAgICAgICAgICAgIC8vIGFyZSBuZXh0IGlubmVyIHN1YnNjcmlwdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJTdWJTY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICAgIGV4ZWN1dGVTY2hlZHVsZShzdWJzY3JpYmVyLCBpbm5lclN1YlNjaGVkdWxlciwgKCkgPT4gZG9Jbm5lclN1YihidWZmZXJlZFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRvSW5uZXJTdWIoYnVmZmVyZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBjYW4gY29tcGxldGUsIGFuZCBjb21wbGV0ZSBpZiBzby5cbiAgICAgICAgICAgICAgY2hlY2tDb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9O1xuXG4gIC8vIFN1YnNjcmliZSB0byBvdXIgc291cmNlIG9ic2VydmFibGUuXG4gIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIG91dGVyTmV4dCwgKCkgPT4ge1xuICAgICAgLy8gT3V0ZXIgY29tcGxldGVkLCBtYWtlIGEgbm90ZSBvZiBpdCwgYW5kIGNoZWNrIHRvIHNlZSBpZiB3ZSBjYW4gY29tcGxldGUgZXZlcnl0aGluZy5cbiAgICAgIGlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgY2hlY2tDb21wbGV0ZSgpO1xuICAgIH0pXG4gICk7XG5cbiAgLy8gQWRkaXRpb25hbCBmaW5hbGl6YXRpb24gKGZvciB3aGVuIHRoZSBkZXN0aW5hdGlvbiBpcyB0b3JuIGRvd24pLlxuICAvLyBPdGhlciBmaW5hbGl6YXRpb24gaXMgYWRkZWQgaW1wbGljaXRseSB2aWEgc3Vic2NyaXB0aW9uIGFib3ZlLlxuICByZXR1cm4gKCkgPT4ge1xuICAgIGFkZGl0aW9uYWxGaW5hbGl6ZXI/LigpO1xuICB9O1xufVxuIl19
