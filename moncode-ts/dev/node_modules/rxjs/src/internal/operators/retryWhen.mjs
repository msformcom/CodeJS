import { innerFrom } from '../observable/innerFrom.mjs';
import { Subject } from '../Subject.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will emit the Throwable that caused the error to the `ObservableInput` returned from `notifier`.
 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
 * subscription. Otherwise this method will resubscribe to the source Observable.
 *
 * ![](retryWhen.png)
 *
 * Retry an observable sequence on error based on custom criteria.
 *
 * ## Example
 *
 * ```ts
 * import { interval, map, retryWhen, tap, delayWhen, timer } from 'rxjs';
 *
 * const source = interval(1000);
 * const result = source.pipe(
 *   map(value => {
 *     if (value > 5) {
 *       // error will be picked up by retryWhen
 *       throw value;
 *     }
 *     return value;
 *   }),
 *   retryWhen(errors =>
 *     errors.pipe(
 *       // log error message
 *       tap(value => console.log(`Value ${ value } was too high!`)),
 *       // restart in 5 seconds
 *       delayWhen(value => timer(value * 1000))
 *     )
 *   )
 * );
 *
 * result.subscribe(value => console.log(value));
 *
 * // results:
 * // 0
 * // 1
 * // 2
 * // 3
 * // 4
 * // 5
 * // 'Value 6 was too high!'
 * // - Wait 5 seconds then repeat
 * ```
 *
 * @see {@link retry}
 *
 * @param notifier Function that receives an Observable of notifications with which a
 * user can `complete` or `error`, aborting the retry.
 * @return A function that returns an `ObservableInput` that mirrors the source
 * Observable with the exception of an `error`.
 * @deprecated Will be removed in v9 or v10, use {@link retry}'s `delay` option instead.
 * Will be removed in v9 or v10. Use {@link retry}'s {@link RetryConfig#delay delay} option instead.
 * Instead of `retryWhen(() => notify$)`, use: `retry({ delay: () => notify$ })`.
 */
export function retryWhen(notifier) {
    return operate((source, subscriber) => {
        let innerSub;
        let syncResub = false;
        let errors$;
        const subscribeForRetryWhen = () => {
            innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, (err) => {
                if (!errors$) {
                    errors$ = new Subject();
                    innerFrom(notifier(errors$)).subscribe(createOperatorSubscriber(subscriber, () => 
                    // If we have an innerSub, this was an asynchronous call, kick off the retry.
                    // Otherwise, if we don't have an innerSub yet, that's because the inner subscription
                    // call hasn't even returned yet. We've arrived here synchronously.
                    // So we flag that we want to resub, such that we can ensure finalization
                    // happens before we resubscribe.
                    innerSub ? subscribeForRetryWhen() : (syncResub = true)));
                }
                if (errors$) {
                    // We have set up the notifier without error.
                    errors$.next(err);
                }
            }));
            if (syncResub) {
                // Ensure that the inner subscription is torn down before
                // moving on to the next subscription in the synchronous case.
                // If we don't do this here, all inner subscriptions will not be
                // torn down until the entire observable is done.
                innerSub.unsubscribe();
                innerSub = null;
                // We may need to do this multiple times, so reset the flag.
                syncResub = false;
                // Resubscribe
                subscribeForRetryWhen();
            }
        };
        // Start the subscription
        subscribeForRetryWhen();
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvcmV0cnlXaGVuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBSXJDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFaEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0RHO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FBSSxRQUEyRDtJQUN0RixPQUFPLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTtRQUNwQyxJQUFJLFFBQTZCLENBQUM7UUFDbEMsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLElBQUksT0FBcUIsQ0FBQztRQUUxQixNQUFNLHFCQUFxQixHQUFHLEdBQUcsRUFBRTtZQUNqQyxRQUFRLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FDekIsd0JBQXdCLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRTtnQkFDakUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO29CQUNiLE9BQU8sR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO29CQUN4QixTQUFTLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUNwQyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsR0FBRyxFQUFFO29CQUN4Qyw2RUFBNkU7b0JBQzdFLHFGQUFxRjtvQkFDckYsbUVBQW1FO29CQUNuRSx5RUFBeUU7b0JBQ3pFLGlDQUFpQztvQkFDakMsUUFBUSxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FDeEQsQ0FDRixDQUFDO2dCQUNKLENBQUM7Z0JBQ0QsSUFBSSxPQUFPLEVBQUUsQ0FBQztvQkFDWiw2Q0FBNkM7b0JBQzdDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3BCLENBQUM7WUFDSCxDQUFDLENBQUMsQ0FDSCxDQUFDO1lBRUYsSUFBSSxTQUFTLEVBQUUsQ0FBQztnQkFDZCx5REFBeUQ7Z0JBQ3pELDhEQUE4RDtnQkFDOUQsZ0VBQWdFO2dCQUNoRSxpREFBaUQ7Z0JBQ2pELFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDdkIsUUFBUSxHQUFHLElBQUksQ0FBQztnQkFDaEIsNERBQTREO2dCQUM1RCxTQUFTLEdBQUcsS0FBSyxDQUFDO2dCQUNsQixjQUFjO2dCQUNkLHFCQUFxQixFQUFFLENBQUM7WUFDMUIsQ0FBQztRQUNILENBQUMsQ0FBQztRQUVGLHlCQUF5QjtRQUN6QixxQkFBcUIsRUFBRSxDQUFDO0lBQzFCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3JldHJ5V2hlbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbmltcG9ydCB7IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiwgT2JzZXJ2YWJsZUlucHV0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGFuIGBlcnJvcmAuIElmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZVxuICogY2FsbHMgYGVycm9yYCwgdGhpcyBtZXRob2Qgd2lsbCBlbWl0IHRoZSBUaHJvd2FibGUgdGhhdCBjYXVzZWQgdGhlIGVycm9yIHRvIHRoZSBgT2JzZXJ2YWJsZUlucHV0YCByZXR1cm5lZCBmcm9tIGBub3RpZmllcmAuXG4gKiBJZiB0aGF0IE9ic2VydmFibGUgY2FsbHMgYGNvbXBsZXRlYCBvciBgZXJyb3JgIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBjb21wbGV0ZWAgb3IgYGVycm9yYCBvbiB0aGUgY2hpbGRcbiAqIHN1YnNjcmlwdGlvbi4gT3RoZXJ3aXNlIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqICFbXShyZXRyeVdoZW4ucG5nKVxuICpcbiAqIFJldHJ5IGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb24gZXJyb3IgYmFzZWQgb24gY3VzdG9tIGNyaXRlcmlhLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaW50ZXJ2YWwsIG1hcCwgcmV0cnlXaGVuLCB0YXAsIGRlbGF5V2hlbiwgdGltZXIgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UgPSBpbnRlcnZhbCgxMDAwKTtcbiAqIGNvbnN0IHJlc3VsdCA9IHNvdXJjZS5waXBlKFxuICogICBtYXAodmFsdWUgPT4ge1xuICogICAgIGlmICh2YWx1ZSA+IDUpIHtcbiAqICAgICAgIC8vIGVycm9yIHdpbGwgYmUgcGlja2VkIHVwIGJ5IHJldHJ5V2hlblxuICogICAgICAgdGhyb3cgdmFsdWU7XG4gKiAgICAgfVxuICogICAgIHJldHVybiB2YWx1ZTtcbiAqICAgfSksXG4gKiAgIHJldHJ5V2hlbihlcnJvcnMgPT5cbiAqICAgICBlcnJvcnMucGlwZShcbiAqICAgICAgIC8vIGxvZyBlcnJvciBtZXNzYWdlXG4gKiAgICAgICB0YXAodmFsdWUgPT4gY29uc29sZS5sb2coYFZhbHVlICR7IHZhbHVlIH0gd2FzIHRvbyBoaWdoIWApKSxcbiAqICAgICAgIC8vIHJlc3RhcnQgaW4gNSBzZWNvbmRzXG4gKiAgICAgICBkZWxheVdoZW4odmFsdWUgPT4gdGltZXIodmFsdWUgKiAxMDAwKSlcbiAqICAgICApXG4gKiAgIClcbiAqICk7XG4gKlxuICogcmVzdWx0LnN1YnNjcmliZSh2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xuICpcbiAqIC8vIHJlc3VsdHM6XG4gKiAvLyAwXG4gKiAvLyAxXG4gKiAvLyAyXG4gKiAvLyAzXG4gKiAvLyA0XG4gKiAvLyA1XG4gKiAvLyAnVmFsdWUgNiB3YXMgdG9vIGhpZ2ghJ1xuICogLy8gLSBXYWl0IDUgc2Vjb25kcyB0aGVuIHJlcGVhdFxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgcmV0cnl9XG4gKlxuICogQHBhcmFtIG5vdGlmaWVyIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYW4gT2JzZXJ2YWJsZSBvZiBub3RpZmljYXRpb25zIHdpdGggd2hpY2ggYVxuICogdXNlciBjYW4gYGNvbXBsZXRlYCBvciBgZXJyb3JgLCBhYm9ydGluZyB0aGUgcmV0cnkuXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGBPYnNlcnZhYmxlSW5wdXRgIHRoYXQgbWlycm9ycyB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBhbiBgZXJyb3JgLlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY5IG9yIHYxMCwgdXNlIHtAbGluayByZXRyeX0ncyBgZGVsYXlgIG9wdGlvbiBpbnN0ZWFkLlxuICogV2lsbCBiZSByZW1vdmVkIGluIHY5IG9yIHYxMC4gVXNlIHtAbGluayByZXRyeX0ncyB7QGxpbmsgUmV0cnlDb25maWcjZGVsYXkgZGVsYXl9IG9wdGlvbiBpbnN0ZWFkLlxuICogSW5zdGVhZCBvZiBgcmV0cnlXaGVuKCgpID0+IG5vdGlmeSQpYCwgdXNlOiBgcmV0cnkoeyBkZWxheTogKCkgPT4gbm90aWZ5JCB9KWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeVdoZW48VD4obm90aWZpZXI6IChlcnJvcnM6IE9ic2VydmFibGU8YW55PikgPT4gT2JzZXJ2YWJsZUlucHV0PGFueT4pOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4ge1xuICByZXR1cm4gb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgbGV0IGlubmVyU3ViOiBTdWJzY3JpcHRpb24gfCBudWxsO1xuICAgIGxldCBzeW5jUmVzdWIgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3JzJDogU3ViamVjdDxhbnk+O1xuXG4gICAgY29uc3Qgc3Vic2NyaWJlRm9yUmV0cnlXaGVuID0gKCkgPT4ge1xuICAgICAgaW5uZXJTdWIgPSBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIWVycm9ycyQpIHtcbiAgICAgICAgICAgIGVycm9ycyQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgICAgaW5uZXJGcm9tKG5vdGlmaWVyKGVycm9ycyQpKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCAoKSA9PlxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW5uZXJTdWIsIHRoaXMgd2FzIGFuIGFzeW5jaHJvbm91cyBjYWxsLCBraWNrIG9mZiB0aGUgcmV0cnkuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSBkb24ndCBoYXZlIGFuIGlubmVyU3ViIHlldCwgdGhhdCdzIGJlY2F1c2UgdGhlIGlubmVyIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIC8vIGNhbGwgaGFzbid0IGV2ZW4gcmV0dXJuZWQgeWV0LiBXZSd2ZSBhcnJpdmVkIGhlcmUgc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgICAgICAvLyBTbyB3ZSBmbGFnIHRoYXQgd2Ugd2FudCB0byByZXN1Yiwgc3VjaCB0aGF0IHdlIGNhbiBlbnN1cmUgZmluYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgLy8gaGFwcGVucyBiZWZvcmUgd2UgcmVzdWJzY3JpYmUuXG4gICAgICAgICAgICAgICAgaW5uZXJTdWIgPyBzdWJzY3JpYmVGb3JSZXRyeVdoZW4oKSA6IChzeW5jUmVzdWIgPSB0cnVlKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3JzJCkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBzZXQgdXAgdGhlIG5vdGlmaWVyIHdpdGhvdXQgZXJyb3IuXG4gICAgICAgICAgICBlcnJvcnMkLm5leHQoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBpZiAoc3luY1Jlc3ViKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBpbm5lciBzdWJzY3JpcHRpb24gaXMgdG9ybiBkb3duIGJlZm9yZVxuICAgICAgICAvLyBtb3Zpbmcgb24gdG8gdGhlIG5leHQgc3Vic2NyaXB0aW9uIGluIHRoZSBzeW5jaHJvbm91cyBjYXNlLlxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBkbyB0aGlzIGhlcmUsIGFsbCBpbm5lciBzdWJzY3JpcHRpb25zIHdpbGwgbm90IGJlXG4gICAgICAgIC8vIHRvcm4gZG93biB1bnRpbCB0aGUgZW50aXJlIG9ic2VydmFibGUgaXMgZG9uZS5cbiAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgaW5uZXJTdWIgPSBudWxsO1xuICAgICAgICAvLyBXZSBtYXkgbmVlZCB0byBkbyB0aGlzIG11bHRpcGxlIHRpbWVzLCBzbyByZXNldCB0aGUgZmxhZy5cbiAgICAgICAgc3luY1Jlc3ViID0gZmFsc2U7XG4gICAgICAgIC8vIFJlc3Vic2NyaWJlXG4gICAgICAgIHN1YnNjcmliZUZvclJldHJ5V2hlbigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTdGFydCB0aGUgc3Vic2NyaXB0aW9uXG4gICAgc3Vic2NyaWJlRm9yUmV0cnlXaGVuKCk7XG4gIH0pO1xufVxuIl19
