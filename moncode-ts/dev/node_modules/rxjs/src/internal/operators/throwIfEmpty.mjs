import { EmptyError } from '../util/EmptyError.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * If the source observable completes without emitting a value, it will emit
 * an error. The error will be created at that time by the optional
 * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.
 *
 * ![](throwIfEmpty.png)
 *
 * ## Example
 *
 * Throw an error if the document wasn't clicked within 1 second
 *
 * ```ts
 * import { fromEvent, takeUntil, timer, throwIfEmpty } from 'rxjs';
 *
 * const click$ = fromEvent(document, 'click');
 *
 * click$.pipe(
 *   takeUntil(timer(1000)),
 *   throwIfEmpty(() => new Error('The document was not clicked within 1 second'))
 * )
 * .subscribe({
 *   next() {
 *    console.log('The document was clicked');
 *   },
 *   error(err) {
 *     console.error(err.message);
 *   }
 * });
 * ```
 *
 * @param errorFactory A factory function called to produce the
 * error to be thrown when the source observable completes without emitting a
 * value.
 * @return A function that returns an Observable that throws an error if the
 * source Observable completed without emitting.
 */
export function throwIfEmpty(errorFactory = defaultErrorFactory) {
    return operate((source, subscriber) => {
        let hasValue = false;
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            hasValue = true;
            subscriber.next(value);
        }, () => (hasValue ? subscriber.complete() : subscriber.error(errorFactory()))));
    });
}
function defaultErrorFactory() {
    return new EmptyError();
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGhyb3dJZkVtcHR5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVoRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRWhFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1DRztBQUNILE1BQU0sVUFBVSxZQUFZLENBQUksZUFBMEIsbUJBQW1CO0lBQzNFLE9BQU8sT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxFQUFFO1FBQ3BDLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixNQUFNLENBQUMsU0FBUyxDQUNkLHdCQUF3QixDQUN0QixVQUFVLEVBQ1YsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNSLFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDaEIsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6QixDQUFDLEVBQ0QsR0FBRyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQzVFLENBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsbUJBQW1CO0lBQzFCLE9BQU8sSUFBSSxVQUFVLEVBQUUsQ0FBQztBQUMxQixDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGhyb3dJZkVtcHR5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1wdHlFcnJvciB9IGZyb20gJy4uL3V0aWwvRW1wdHlFcnJvcic7XG5pbXBvcnQgeyBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcblxuLyoqXG4gKiBJZiB0aGUgc291cmNlIG9ic2VydmFibGUgY29tcGxldGVzIHdpdGhvdXQgZW1pdHRpbmcgYSB2YWx1ZSwgaXQgd2lsbCBlbWl0XG4gKiBhbiBlcnJvci4gVGhlIGVycm9yIHdpbGwgYmUgY3JlYXRlZCBhdCB0aGF0IHRpbWUgYnkgdGhlIG9wdGlvbmFsXG4gKiBgZXJyb3JGYWN0b3J5YCBhcmd1bWVudCwgb3RoZXJ3aXNlLCB0aGUgZXJyb3Igd2lsbCBiZSB7QGxpbmsgRW1wdHlFcnJvcn0uXG4gKlxuICogIVtdKHRocm93SWZFbXB0eS5wbmcpXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIFRocm93IGFuIGVycm9yIGlmIHRoZSBkb2N1bWVudCB3YXNuJ3QgY2xpY2tlZCB3aXRoaW4gMSBzZWNvbmRcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50LCB0YWtlVW50aWwsIHRpbWVyLCB0aHJvd0lmRW1wdHkgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBjbGljayQgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICpcbiAqIGNsaWNrJC5waXBlKFxuICogICB0YWtlVW50aWwodGltZXIoMTAwMCkpLFxuICogICB0aHJvd0lmRW1wdHkoKCkgPT4gbmV3IEVycm9yKCdUaGUgZG9jdW1lbnQgd2FzIG5vdCBjbGlja2VkIHdpdGhpbiAxIHNlY29uZCcpKVxuICogKVxuICogLnN1YnNjcmliZSh7XG4gKiAgIG5leHQoKSB7XG4gKiAgICBjb25zb2xlLmxvZygnVGhlIGRvY3VtZW50IHdhcyBjbGlja2VkJyk7XG4gKiAgIH0sXG4gKiAgIGVycm9yKGVycikge1xuICogICAgIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlcnJvckZhY3RvcnkgQSBmYWN0b3J5IGZ1bmN0aW9uIGNhbGxlZCB0byBwcm9kdWNlIHRoZVxuICogZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gdGhlIHNvdXJjZSBvYnNlcnZhYmxlIGNvbXBsZXRlcyB3aXRob3V0IGVtaXR0aW5nIGFcbiAqIHZhbHVlLlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgdGhyb3dzIGFuIGVycm9yIGlmIHRoZVxuICogc291cmNlIE9ic2VydmFibGUgY29tcGxldGVkIHdpdGhvdXQgZW1pdHRpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd0lmRW1wdHk8VD4oZXJyb3JGYWN0b3J5OiAoKSA9PiBhbnkgPSBkZWZhdWx0RXJyb3JGYWN0b3J5KTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIGxldCBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoXG4gICAgICAgIHN1YnNjcmliZXIsXG4gICAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiAoaGFzVmFsdWUgPyBzdWJzY3JpYmVyLmNvbXBsZXRlKCkgOiBzdWJzY3JpYmVyLmVycm9yKGVycm9yRmFjdG9yeSgpKSlcbiAgICAgIClcbiAgICApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEVycm9yRmFjdG9yeSgpIHtcbiAgcmV0dXJuIG5ldyBFbXB0eUVycm9yKCk7XG59XG4iXX0=
