import { identity } from '../util/identity.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Skip a specified number of values before the completion of an observable.
 *
 * ![](skipLast.png)
 *
 * Returns an observable that will emit values as soon as it can, given a number of
 * skipped values. For example, if you `skipLast(3)` on a source, when the source
 * emits its fourth value, the first value the source emitted will finally be emitted
 * from the returned observable, as it is no longer part of what needs to be skipped.
 *
 * All values emitted by the result of `skipLast(N)` will be delayed by `N` emissions,
 * as each value is held in a buffer until enough values have been emitted that that
 * the buffered value may finally be sent to the consumer.
 *
 * After subscribing, unsubscribing will not result in the emission of the buffered
 * skipped values.
 *
 * ## Example
 *
 * Skip the last 2 values of an observable with many values
 *
 * ```ts
 * import { of, skipLast } from 'rxjs';
 *
 * const numbers = of(1, 2, 3, 4, 5);
 * const skipLastTwo = numbers.pipe(skipLast(2));
 * skipLastTwo.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 1 2 3
 * // (4 and 5 are skipped)
 * ```
 *
 * @see {@link skip}
 * @see {@link skipUntil}
 * @see {@link skipWhile}
 * @see {@link take}
 *
 * @param skipCount Number of elements to skip from the end of the source Observable.
 * @return A function that returns an Observable that skips the last `count`
 * values emitted by the source Observable.
 */
export function skipLast(skipCount) {
    return skipCount <= 0
        ? // For skipCounts less than or equal to zero, we are just mirroring the source.
            identity
        : operate((source, subscriber) => {
            // A ring buffer to hold the values while we wait to see
            // if we can emit it or it's part of the "skipped" last values.
            // Note that it is the _same size_ as the skip count.
            let ring = new Array(skipCount);
            // The number of values seen so far. This is used to get
            // the index of the current value when it arrives.
            let seen = 0;
            source.subscribe(createOperatorSubscriber(subscriber, (value) => {
                // Get the index of the value we have right now
                // relative to all other values we've seen, then
                // increment `seen`. This ensures we've moved to
                // the next slot in our ring buffer.
                const valueIndex = seen++;
                if (valueIndex < skipCount) {
                    // If we haven't seen enough values to fill our buffer yet,
                    // Then we aren't to a number of seen values where we can
                    // emit anything, so let's just start by filling the ring buffer.
                    ring[valueIndex] = value;
                }
                else {
                    // We are traversing over the ring array in such
                    // a way that when we get to the end, we loop back
                    // and go to the start.
                    const index = valueIndex % skipCount;
                    // Pull the oldest value out so we can emit it,
                    // and stuff the new value in it's place.
                    const oldValue = ring[index];
                    ring[index] = value;
                    // Emit the old value. It is important that this happens
                    // after we swap the value in the buffer, if it happens
                    // before we swap the value in the buffer, then a synchronous
                    // source can get the buffer out of whack.
                    subscriber.next(oldValue);
                }
            }));
            return () => {
                // Release our values in memory
                ring = null;
            };
        });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcExhc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFaEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeUNHO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FBSSxTQUFpQjtJQUMzQyxPQUFPLFNBQVMsSUFBSSxDQUFDO1FBQ25CLENBQUMsQ0FBQywrRUFBK0U7WUFDL0UsUUFBUTtRQUNWLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7WUFDN0Isd0RBQXdEO1lBQ3hELCtEQUErRDtZQUMvRCxxREFBcUQ7WUFDckQsSUFBSSxJQUFJLEdBQVEsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDckMsd0RBQXdEO1lBQ3hELGtEQUFrRDtZQUNsRCxJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7WUFDYixNQUFNLENBQUMsU0FBUyxDQUNkLHdCQUF3QixDQUFDLFVBQVUsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUM3QywrQ0FBK0M7Z0JBQy9DLGdEQUFnRDtnQkFDaEQsZ0RBQWdEO2dCQUNoRCxvQ0FBb0M7Z0JBQ3BDLE1BQU0sVUFBVSxHQUFHLElBQUksRUFBRSxDQUFDO2dCQUMxQixJQUFJLFVBQVUsR0FBRyxTQUFTLEVBQUUsQ0FBQztvQkFDM0IsMkRBQTJEO29CQUMzRCx5REFBeUQ7b0JBQ3pELGlFQUFpRTtvQkFDakUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFDM0IsQ0FBQztxQkFBTSxDQUFDO29CQUNOLGdEQUFnRDtvQkFDaEQsa0RBQWtEO29CQUNsRCx1QkFBdUI7b0JBQ3ZCLE1BQU0sS0FBSyxHQUFHLFVBQVUsR0FBRyxTQUFTLENBQUM7b0JBQ3JDLCtDQUErQztvQkFDL0MseUNBQXlDO29CQUN6QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7b0JBQ3BCLHdEQUF3RDtvQkFDeEQsdURBQXVEO29CQUN2RCw2REFBNkQ7b0JBQzdELDBDQUEwQztvQkFDMUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDNUIsQ0FBQztZQUNILENBQUMsQ0FBQyxDQUNILENBQUM7WUFFRixPQUFPLEdBQUcsRUFBRTtnQkFDViwrQkFBK0I7Z0JBQy9CLElBQUksR0FBRyxJQUFLLENBQUM7WUFDZixDQUFDLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztBQUNULENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy9za2lwTGFzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSAnLi4vdXRpbC9pZGVudGl0eSc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcblxuLyoqXG4gKiBTa2lwIGEgc3BlY2lmaWVkIG51bWJlciBvZiB2YWx1ZXMgYmVmb3JlIHRoZSBjb21wbGV0aW9uIG9mIGFuIG9ic2VydmFibGUuXG4gKlxuICogIVtdKHNraXBMYXN0LnBuZylcbiAqXG4gKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCB3aWxsIGVtaXQgdmFsdWVzIGFzIHNvb24gYXMgaXQgY2FuLCBnaXZlbiBhIG51bWJlciBvZlxuICogc2tpcHBlZCB2YWx1ZXMuIEZvciBleGFtcGxlLCBpZiB5b3UgYHNraXBMYXN0KDMpYCBvbiBhIHNvdXJjZSwgd2hlbiB0aGUgc291cmNlXG4gKiBlbWl0cyBpdHMgZm91cnRoIHZhbHVlLCB0aGUgZmlyc3QgdmFsdWUgdGhlIHNvdXJjZSBlbWl0dGVkIHdpbGwgZmluYWxseSBiZSBlbWl0dGVkXG4gKiBmcm9tIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlLCBhcyBpdCBpcyBubyBsb25nZXIgcGFydCBvZiB3aGF0IG5lZWRzIHRvIGJlIHNraXBwZWQuXG4gKlxuICogQWxsIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSByZXN1bHQgb2YgYHNraXBMYXN0KE4pYCB3aWxsIGJlIGRlbGF5ZWQgYnkgYE5gIGVtaXNzaW9ucyxcbiAqIGFzIGVhY2ggdmFsdWUgaXMgaGVsZCBpbiBhIGJ1ZmZlciB1bnRpbCBlbm91Z2ggdmFsdWVzIGhhdmUgYmVlbiBlbWl0dGVkIHRoYXQgdGhhdFxuICogdGhlIGJ1ZmZlcmVkIHZhbHVlIG1heSBmaW5hbGx5IGJlIHNlbnQgdG8gdGhlIGNvbnN1bWVyLlxuICpcbiAqIEFmdGVyIHN1YnNjcmliaW5nLCB1bnN1YnNjcmliaW5nIHdpbGwgbm90IHJlc3VsdCBpbiB0aGUgZW1pc3Npb24gb2YgdGhlIGJ1ZmZlcmVkXG4gKiBza2lwcGVkIHZhbHVlcy5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogU2tpcCB0aGUgbGFzdCAyIHZhbHVlcyBvZiBhbiBvYnNlcnZhYmxlIHdpdGggbWFueSB2YWx1ZXNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgb2YsIHNraXBMYXN0IH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgbnVtYmVycyA9IG9mKDEsIDIsIDMsIDQsIDUpO1xuICogY29uc3Qgc2tpcExhc3RUd28gPSBudW1iZXJzLnBpcGUoc2tpcExhc3QoMikpO1xuICogc2tpcExhc3RUd28uc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW46XG4gKiAvLyAxIDIgM1xuICogLy8gKDQgYW5kIDUgYXJlIHNraXBwZWQpXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBza2lwfVxuICogQHNlZSB7QGxpbmsgc2tpcFVudGlsfVxuICogQHNlZSB7QGxpbmsgc2tpcFdoaWxlfVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAcGFyYW0gc2tpcENvdW50IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBza2lwcyB0aGUgbGFzdCBgY291bnRgXG4gKiB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBza2lwTGFzdDxUPihza2lwQ291bnQ6IG51bWJlcik6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPiB7XG4gIHJldHVybiBza2lwQ291bnQgPD0gMFxuICAgID8gLy8gRm9yIHNraXBDb3VudHMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8sIHdlIGFyZSBqdXN0IG1pcnJvcmluZyB0aGUgc291cmNlLlxuICAgICAgaWRlbnRpdHlcbiAgICA6IG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAvLyBBIHJpbmcgYnVmZmVyIHRvIGhvbGQgdGhlIHZhbHVlcyB3aGlsZSB3ZSB3YWl0IHRvIHNlZVxuICAgICAgICAvLyBpZiB3ZSBjYW4gZW1pdCBpdCBvciBpdCdzIHBhcnQgb2YgdGhlIFwic2tpcHBlZFwiIGxhc3QgdmFsdWVzLlxuICAgICAgICAvLyBOb3RlIHRoYXQgaXQgaXMgdGhlIF9zYW1lIHNpemVfIGFzIHRoZSBza2lwIGNvdW50LlxuICAgICAgICBsZXQgcmluZzogVFtdID0gbmV3IEFycmF5KHNraXBDb3VudCk7XG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgdmFsdWVzIHNlZW4gc28gZmFyLiBUaGlzIGlzIHVzZWQgdG8gZ2V0XG4gICAgICAgIC8vIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCB2YWx1ZSB3aGVuIGl0IGFycml2ZXMuXG4gICAgICAgIGxldCBzZWVuID0gMDtcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShcbiAgICAgICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSB3ZSBoYXZlIHJpZ2h0IG5vd1xuICAgICAgICAgICAgLy8gcmVsYXRpdmUgdG8gYWxsIG90aGVyIHZhbHVlcyB3ZSd2ZSBzZWVuLCB0aGVuXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgYHNlZW5gLiBUaGlzIGVuc3VyZXMgd2UndmUgbW92ZWQgdG9cbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IHNsb3QgaW4gb3VyIHJpbmcgYnVmZmVyLlxuICAgICAgICAgICAgY29uc3QgdmFsdWVJbmRleCA9IHNlZW4rKztcbiAgICAgICAgICAgIGlmICh2YWx1ZUluZGV4IDwgc2tpcENvdW50KSB7XG4gICAgICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3Qgc2VlbiBlbm91Z2ggdmFsdWVzIHRvIGZpbGwgb3VyIGJ1ZmZlciB5ZXQsXG4gICAgICAgICAgICAgIC8vIFRoZW4gd2UgYXJlbid0IHRvIGEgbnVtYmVyIG9mIHNlZW4gdmFsdWVzIHdoZXJlIHdlIGNhblxuICAgICAgICAgICAgICAvLyBlbWl0IGFueXRoaW5nLCBzbyBsZXQncyBqdXN0IHN0YXJ0IGJ5IGZpbGxpbmcgdGhlIHJpbmcgYnVmZmVyLlxuICAgICAgICAgICAgICByaW5nW3ZhbHVlSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBhcmUgdHJhdmVyc2luZyBvdmVyIHRoZSByaW5nIGFycmF5IGluIHN1Y2hcbiAgICAgICAgICAgICAgLy8gYSB3YXkgdGhhdCB3aGVuIHdlIGdldCB0byB0aGUgZW5kLCB3ZSBsb29wIGJhY2tcbiAgICAgICAgICAgICAgLy8gYW5kIGdvIHRvIHRoZSBzdGFydC5cbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB2YWx1ZUluZGV4ICUgc2tpcENvdW50O1xuICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBvbGRlc3QgdmFsdWUgb3V0IHNvIHdlIGNhbiBlbWl0IGl0LFxuICAgICAgICAgICAgICAvLyBhbmQgc3R1ZmYgdGhlIG5ldyB2YWx1ZSBpbiBpdCdzIHBsYWNlLlxuICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHJpbmdbaW5kZXhdO1xuICAgICAgICAgICAgICByaW5nW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAvLyBFbWl0IHRoZSBvbGQgdmFsdWUuIEl0IGlzIGltcG9ydGFudCB0aGF0IHRoaXMgaGFwcGVuc1xuICAgICAgICAgICAgICAvLyBhZnRlciB3ZSBzd2FwIHRoZSB2YWx1ZSBpbiB0aGUgYnVmZmVyLCBpZiBpdCBoYXBwZW5zXG4gICAgICAgICAgICAgIC8vIGJlZm9yZSB3ZSBzd2FwIHRoZSB2YWx1ZSBpbiB0aGUgYnVmZmVyLCB0aGVuIGEgc3luY2hyb25vdXNcbiAgICAgICAgICAgICAgLy8gc291cmNlIGNhbiBnZXQgdGhlIGJ1ZmZlciBvdXQgb2Ygd2hhY2suXG4gICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIC8vIFJlbGVhc2Ugb3VyIHZhbHVlcyBpbiBtZW1vcnlcbiAgICAgICAgICByaW5nID0gbnVsbCE7XG4gICAgICAgIH07XG4gICAgICB9KTtcbn1cbiJdfQ==
