import { EMPTY } from '../observable/empty.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
import { timer } from '../observable/timer.mjs';
/**
 * Returns an Observable that will resubscribe to the source stream when the source stream completes.
 *
 * <span class="informal">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>
 *
 * ![](repeat.png)
 *
 * Repeat will output values from a source until the source completes, then it will resubscribe to the
 * source a specified number of times, with a specified delay. Repeat can be particularly useful in
 * combination with closing operators like {@link take}, {@link takeUntil}, {@link first}, or {@link takeWhile},
 * as it can be used to restart a source again from scratch.
 *
 * Repeat is very similar to {@link retry}, where {@link retry} will resubscribe to the source in the error case, but
 * `repeat` will resubscribe if the source completes.
 *
 * Note that `repeat` will _not_ catch errors. Use {@link retry} for that.
 *
 * - `repeat(0)` returns an empty observable
 * - `repeat()` will repeat forever
 * - `repeat({ delay: 200 })` will repeat forever, with a delay of 200ms between repetitions.
 * - `repeat({ count: 2, delay: 400 })` will repeat twice, with a delay of 400ms between repetitions.
 * - `repeat({ delay: (count) => timer(count * 1000) })` will repeat forever, but will have a delay that grows by one second for each repetition.
 *
 * ## Example
 *
 * Repeat a message stream
 *
 * ```ts
 * import { of, repeat } from 'rxjs';
 *
 * const source = of('Repeat message');
 * const result = source.pipe(repeat(3));
 *
 * result.subscribe(x => console.log(x));
 *
 * // Results
 * // 'Repeat message'
 * // 'Repeat message'
 * // 'Repeat message'
 * ```
 *
 * Repeat 3 values, 2 times
 *
 * ```ts
 * import { interval, take, repeat } from 'rxjs';
 *
 * const source = interval(1000);
 * const result = source.pipe(take(3), repeat(2));
 *
 * result.subscribe(x => console.log(x));
 *
 * // Results every second
 * // 0
 * // 1
 * // 2
 * // 0
 * // 1
 * // 2
 * ```
 *
 * Defining two complex repeats with delays on the same source.
 * Note that the second repeat cannot be called until the first
 * repeat as exhausted it's count.
 *
 * ```ts
 * import { defer, of, repeat } from 'rxjs';
 *
 * const source = defer(() => {
 *    return of(`Hello, it is ${new Date()}`)
 * });
 *
 * source.pipe(
 *    // Repeat 3 times with a delay of 1 second between repetitions
 *    repeat({
 *      count: 3,
 *      delay: 1000,
 *    }),
 *
 *    // *Then* repeat forever, but with an exponential step-back
 *    // maxing out at 1 minute.
 *    repeat({
 *      delay: (count) => timer(Math.min(60000, 2 ^ count * 1000))
 *    })
 * )
 * ```
 *
 * @see {@link repeatWhen}
 * @see {@link retry}
 *
 * @param count The number of times the source Observable items are repeated, a count of 0 will yield
 * an empty Observable.
 */
export function repeat(countOrConfig) {
    let count = Infinity;
    let delay;
    if (countOrConfig != null) {
        if (typeof countOrConfig === 'object') {
            ({ count = Infinity, delay } = countOrConfig);
        }
        else {
            count = countOrConfig;
        }
    }
    return count <= 0
        ? () => EMPTY
        : operate((source, subscriber) => {
            let soFar = 0;
            let sourceSub;
            const resubscribe = () => {
                sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
                sourceSub = null;
                if (delay != null) {
                    const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(soFar));
                    const notifierSubscriber = createOperatorSubscriber(subscriber, () => {
                        notifierSubscriber.unsubscribe();
                        subscribeToSource();
                    });
                    notifier.subscribe(notifierSubscriber);
                }
                else {
                    subscribeToSource();
                }
            };
            const subscribeToSource = () => {
                let syncUnsub = false;
                sourceSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, () => {
                    if (++soFar < count) {
                        if (sourceSub) {
                            resubscribe();
                        }
                        else {
                            syncUnsub = true;
                        }
                    }
                    else {
                        subscriber.complete();
                    }
                }));
                if (syncUnsub) {
                    resubscribe();
                }
            };
            subscribeToSource();
        });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVwZWF0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUM1QyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRXZDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFpQjVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkZHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FBSSxhQUFxQztJQUM3RCxJQUFJLEtBQUssR0FBRyxRQUFRLENBQUM7SUFDckIsSUFBSSxLQUE0QixDQUFDO0lBRWpDLElBQUksYUFBYSxJQUFJLElBQUksRUFBRSxDQUFDO1FBQzFCLElBQUksT0FBTyxhQUFhLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDdEMsQ0FBQyxFQUFFLEtBQUssR0FBRyxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsYUFBYSxDQUFDLENBQUM7UUFDaEQsQ0FBQzthQUFNLENBQUM7WUFDTixLQUFLLEdBQUcsYUFBYSxDQUFDO1FBQ3hCLENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxLQUFLLElBQUksQ0FBQztRQUNmLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLO1FBQ2IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTtZQUM3QixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7WUFDZCxJQUFJLFNBQThCLENBQUM7WUFFbkMsTUFBTSxXQUFXLEdBQUcsR0FBRyxFQUFFO2dCQUN2QixTQUFTLGFBQVQsU0FBUyx1QkFBVCxTQUFTLENBQUUsV0FBVyxFQUFFLENBQUM7Z0JBQ3pCLFNBQVMsR0FBRyxJQUFJLENBQUM7Z0JBQ2pCLElBQUksS0FBSyxJQUFJLElBQUksRUFBRSxDQUFDO29CQUNsQixNQUFNLFFBQVEsR0FBRyxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO29CQUNwRixNQUFNLGtCQUFrQixHQUFHLHdCQUF3QixDQUFDLFVBQVUsRUFBRSxHQUFHLEVBQUU7d0JBQ25FLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxDQUFDO3dCQUNqQyxpQkFBaUIsRUFBRSxDQUFDO29CQUN0QixDQUFDLENBQUMsQ0FBQztvQkFDSCxRQUFRLENBQUMsU0FBUyxDQUFDLGtCQUFrQixDQUFDLENBQUM7Z0JBQ3pDLENBQUM7cUJBQU0sQ0FBQztvQkFDTixpQkFBaUIsRUFBRSxDQUFDO2dCQUN0QixDQUFDO1lBQ0gsQ0FBQyxDQUFDO1lBRUYsTUFBTSxpQkFBaUIsR0FBRyxHQUFHLEVBQUU7Z0JBQzdCLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztnQkFDdEIsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQzFCLHdCQUF3QixDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFO29CQUNuRCxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssRUFBRSxDQUFDO3dCQUNwQixJQUFJLFNBQVMsRUFBRSxDQUFDOzRCQUNkLFdBQVcsRUFBRSxDQUFDO3dCQUNoQixDQUFDOzZCQUFNLENBQUM7NEJBQ04sU0FBUyxHQUFHLElBQUksQ0FBQzt3QkFDbkIsQ0FBQztvQkFDSCxDQUFDO3lCQUFNLENBQUM7d0JBQ04sVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUN4QixDQUFDO2dCQUNILENBQUMsQ0FBQyxDQUNILENBQUM7Z0JBRUYsSUFBSSxTQUFTLEVBQUUsQ0FBQztvQkFDZCxXQUFXLEVBQUUsQ0FBQztnQkFDaEIsQ0FBQztZQUNILENBQUMsQ0FBQztZQUVGLGlCQUFpQixFQUFFLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFDVCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVwZWF0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IEVNUFRZIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9lbXB0eSc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiwgT2JzZXJ2YWJsZUlucHV0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuaW1wb3J0IHsgdGltZXIgfSBmcm9tICcuLi9vYnNlcnZhYmxlL3RpbWVyJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXBlYXRDb25maWcge1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHNvdXJjZS4gRGVmYXVsdHMgdG8gYEluZmluaXR5YC5cbiAgICovXG4gIGNvdW50PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJZiBhIGBudW1iZXJgLCB3aWxsIGRlbGF5IHRoZSByZXBlYXQgb2YgdGhlIHNvdXJjZSBieSB0aGF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqIElmIGEgZnVuY3Rpb24sIGl0IHdpbGwgcHJvdmlkZSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBzb3VyY2UgaGFzIGJlZW4gc3Vic2NyaWJlZCB0byxcbiAgICogYW5kIHRoZSByZXR1cm4gdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgb2JzZXJ2YWJsZSBpbnB1dCB0aGF0IHdpbGwgbm90aWZ5IHdoZW4gdGhlIHNvdXJjZVxuICAgKiBzaG91bGQgYmUgcmVwZWF0ZWQuIElmIHRoZSBub3RpZmllciBvYnNlcnZhYmxlIGlzIGVtcHR5LCB0aGUgcmVzdWx0IHdpbGwgY29tcGxldGUuXG4gICAqL1xuICBkZWxheT86IG51bWJlciB8ICgoY291bnQ6IG51bWJlcikgPT4gT2JzZXJ2YWJsZUlucHV0PGFueT4pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBzdHJlYW0gd2hlbiB0aGUgc291cmNlIHN0cmVhbSBjb21wbGV0ZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlJlcGVhdHMgYWxsIHZhbHVlcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UuIEl0J3MgbGlrZSB7QGxpbmsgcmV0cnl9LCBidXQgZm9yIG5vbiBlcnJvciBjYXNlcy48L3NwYW4+XG4gKlxuICogIVtdKHJlcGVhdC5wbmcpXG4gKlxuICogUmVwZWF0IHdpbGwgb3V0cHV0IHZhbHVlcyBmcm9tIGEgc291cmNlIHVudGlsIHRoZSBzb3VyY2UgY29tcGxldGVzLCB0aGVuIGl0IHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlXG4gKiBzb3VyY2UgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLCB3aXRoIGEgc3BlY2lmaWVkIGRlbGF5LiBSZXBlYXQgY2FuIGJlIHBhcnRpY3VsYXJseSB1c2VmdWwgaW5cbiAqIGNvbWJpbmF0aW9uIHdpdGggY2xvc2luZyBvcGVyYXRvcnMgbGlrZSB7QGxpbmsgdGFrZX0sIHtAbGluayB0YWtlVW50aWx9LCB7QGxpbmsgZmlyc3R9LCBvciB7QGxpbmsgdGFrZVdoaWxlfSxcbiAqIGFzIGl0IGNhbiBiZSB1c2VkIHRvIHJlc3RhcnQgYSBzb3VyY2UgYWdhaW4gZnJvbSBzY3JhdGNoLlxuICpcbiAqIFJlcGVhdCBpcyB2ZXJ5IHNpbWlsYXIgdG8ge0BsaW5rIHJldHJ5fSwgd2hlcmUge0BsaW5rIHJldHJ5fSB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgaW4gdGhlIGVycm9yIGNhc2UsIGJ1dFxuICogYHJlcGVhdGAgd2lsbCByZXN1YnNjcmliZSBpZiB0aGUgc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiBOb3RlIHRoYXQgYHJlcGVhdGAgd2lsbCBfbm90XyBjYXRjaCBlcnJvcnMuIFVzZSB7QGxpbmsgcmV0cnl9IGZvciB0aGF0LlxuICpcbiAqIC0gYHJlcGVhdCgwKWAgcmV0dXJucyBhbiBlbXB0eSBvYnNlcnZhYmxlXG4gKiAtIGByZXBlYXQoKWAgd2lsbCByZXBlYXQgZm9yZXZlclxuICogLSBgcmVwZWF0KHsgZGVsYXk6IDIwMCB9KWAgd2lsbCByZXBlYXQgZm9yZXZlciwgd2l0aCBhIGRlbGF5IG9mIDIwMG1zIGJldHdlZW4gcmVwZXRpdGlvbnMuXG4gKiAtIGByZXBlYXQoeyBjb3VudDogMiwgZGVsYXk6IDQwMCB9KWAgd2lsbCByZXBlYXQgdHdpY2UsIHdpdGggYSBkZWxheSBvZiA0MDBtcyBiZXR3ZWVuIHJlcGV0aXRpb25zLlxuICogLSBgcmVwZWF0KHsgZGVsYXk6IChjb3VudCkgPT4gdGltZXIoY291bnQgKiAxMDAwKSB9KWAgd2lsbCByZXBlYXQgZm9yZXZlciwgYnV0IHdpbGwgaGF2ZSBhIGRlbGF5IHRoYXQgZ3Jvd3MgYnkgb25lIHNlY29uZCBmb3IgZWFjaCByZXBldGl0aW9uLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBSZXBlYXQgYSBtZXNzYWdlIHN0cmVhbVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBvZiwgcmVwZWF0IH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3Qgc291cmNlID0gb2YoJ1JlcGVhdCBtZXNzYWdlJyk7XG4gKiBjb25zdCByZXN1bHQgPSBzb3VyY2UucGlwZShyZXBlYXQoMykpO1xuICpcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0c1xuICogLy8gJ1JlcGVhdCBtZXNzYWdlJ1xuICogLy8gJ1JlcGVhdCBtZXNzYWdlJ1xuICogLy8gJ1JlcGVhdCBtZXNzYWdlJ1xuICogYGBgXG4gKlxuICogUmVwZWF0IDMgdmFsdWVzLCAyIHRpbWVzXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGludGVydmFsLCB0YWtlLCByZXBlYXQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UgPSBpbnRlcnZhbCgxMDAwKTtcbiAqIGNvbnN0IHJlc3VsdCA9IHNvdXJjZS5waXBlKHRha2UoMyksIHJlcGVhdCgyKSk7XG4gKlxuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGV2ZXJ5IHNlY29uZFxuICogLy8gMFxuICogLy8gMVxuICogLy8gMlxuICogLy8gMFxuICogLy8gMVxuICogLy8gMlxuICogYGBgXG4gKlxuICogRGVmaW5pbmcgdHdvIGNvbXBsZXggcmVwZWF0cyB3aXRoIGRlbGF5cyBvbiB0aGUgc2FtZSBzb3VyY2UuXG4gKiBOb3RlIHRoYXQgdGhlIHNlY29uZCByZXBlYXQgY2Fubm90IGJlIGNhbGxlZCB1bnRpbCB0aGUgZmlyc3RcbiAqIHJlcGVhdCBhcyBleGhhdXN0ZWQgaXQncyBjb3VudC5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZGVmZXIsIG9mLCByZXBlYXQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UgPSBkZWZlcigoKSA9PiB7XG4gKiAgICByZXR1cm4gb2YoYEhlbGxvLCBpdCBpcyAke25ldyBEYXRlKCl9YClcbiAqIH0pO1xuICpcbiAqIHNvdXJjZS5waXBlKFxuICogICAgLy8gUmVwZWF0IDMgdGltZXMgd2l0aCBhIGRlbGF5IG9mIDEgc2Vjb25kIGJldHdlZW4gcmVwZXRpdGlvbnNcbiAqICAgIHJlcGVhdCh7XG4gKiAgICAgIGNvdW50OiAzLFxuICogICAgICBkZWxheTogMTAwMCxcbiAqICAgIH0pLFxuICpcbiAqICAgIC8vICpUaGVuKiByZXBlYXQgZm9yZXZlciwgYnV0IHdpdGggYW4gZXhwb25lbnRpYWwgc3RlcC1iYWNrXG4gKiAgICAvLyBtYXhpbmcgb3V0IGF0IDEgbWludXRlLlxuICogICAgcmVwZWF0KHtcbiAqICAgICAgZGVsYXk6IChjb3VudCkgPT4gdGltZXIoTWF0aC5taW4oNjAwMDAsIDIgXiBjb3VudCAqIDEwMDApKVxuICogICAgfSlcbiAqIClcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHJlcGVhdFdoZW59XG4gKiBAc2VlIHtAbGluayByZXRyeX1cbiAqXG4gKiBAcGFyYW0gY291bnQgVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgc291cmNlIE9ic2VydmFibGUgaXRlbXMgYXJlIHJlcGVhdGVkLCBhIGNvdW50IG9mIDAgd2lsbCB5aWVsZFxuICogYW4gZW1wdHkgT2JzZXJ2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGVhdDxUPihjb3VudE9yQ29uZmlnPzogbnVtYmVyIHwgUmVwZWF0Q29uZmlnKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgbGV0IGNvdW50ID0gSW5maW5pdHk7XG4gIGxldCBkZWxheTogUmVwZWF0Q29uZmlnWydkZWxheSddO1xuXG4gIGlmIChjb3VudE9yQ29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGNvdW50T3JDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAoeyBjb3VudCA9IEluZmluaXR5LCBkZWxheSB9ID0gY291bnRPckNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gY291bnRPckNvbmZpZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY291bnQgPD0gMFxuICAgID8gKCkgPT4gRU1QVFlcbiAgICA6IG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICBsZXQgc29GYXIgPSAwO1xuICAgICAgICBsZXQgc291cmNlU3ViOiBTdWJzY3JpcHRpb24gfCBudWxsO1xuXG4gICAgICAgIGNvbnN0IHJlc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICAgIHNvdXJjZVN1Yj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBzb3VyY2VTdWIgPSBudWxsO1xuICAgICAgICAgIGlmIChkZWxheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBub3RpZmllciA9IHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgPyB0aW1lcihkZWxheSkgOiBpbm5lckZyb20oZGVsYXkoc29GYXIpKTtcbiAgICAgICAgICAgIGNvbnN0IG5vdGlmaWVyU3Vic2NyaWJlciA9IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCAoKSA9PiB7XG4gICAgICAgICAgICAgIG5vdGlmaWVyU3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICBzdWJzY3JpYmVUb1NvdXJjZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub3RpZmllci5zdWJzY3JpYmUobm90aWZpZXJTdWJzY3JpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlVG9Tb3VyY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlVG9Tb3VyY2UgPSAoKSA9PiB7XG4gICAgICAgICAgbGV0IHN5bmNVbnN1YiA9IGZhbHNlO1xuICAgICAgICAgIHNvdXJjZVN1YiA9IHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICAgICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdW5kZWZpbmVkLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICgrK3NvRmFyIDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlU3ViKSB7XG4gICAgICAgICAgICAgICAgICByZXN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzeW5jVW5zdWIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChzeW5jVW5zdWIpIHtcbiAgICAgICAgICAgIHJlc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN1YnNjcmliZVRvU291cmNlKCk7XG4gICAgICB9KTtcbn1cbiJdfQ==
