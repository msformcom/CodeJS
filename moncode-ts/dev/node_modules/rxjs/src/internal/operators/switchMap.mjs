import { innerFrom } from '../observable/innerFrom.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switchAll}.</span>
 *
 * ![](switchMap.png)
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * ## Example
 *
 * Generate new Observable according to source Observable values
 *
 * ```ts
 * import { of, switchMap } from 'rxjs';
 *
 * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));
 * switched.subscribe(x => console.log(x));
 * // outputs
 * // 1
 * // 1
 * // 1
 * // 2
 * // 4
 * // 8
 * // 3
 * // 9
 * // 27
 * ```
 *
 * Restart an interval Observable on every click event
 *
 * ```ts
 * import { fromEvent, switchMap, interval } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(switchMap(() => interval(1000)));
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchAll}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @return A function that returns an Observable that emits the result of
 * applying the projection function (and the optional deprecated
 * `resultSelector`) to each item emitted by the source Observable and taking
 * only the values from the most recently projected inner Observable.
 */
export function switchMap(project, resultSelector) {
    return operate((source, subscriber) => {
        let innerSubscriber = null;
        let index = 0;
        // Whether or not the source subscription has completed
        let isComplete = false;
        // We only complete the result if the source is complete AND we don't have an active inner subscription.
        // This is called both when the source completes and when the inners complete.
        const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            // Cancel the previous inner subscription if there was one
            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
            let innerIndex = 0;
            const outerIndex = index++;
            // Start the next inner subscription
            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, 
            // When we get a new inner value, next it through. Note that this is
            // handling the deprecate result selector here. This is because with this architecture
            // it ends up being smaller than using the map operator.
            (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {
                // The inner has completed. Null out the inner subscriber to
                // free up memory and to signal that we have no inner subscription
                // currently.
                innerSubscriber = null;
                checkComplete();
            })));
        }, () => {
            isComplete = true;
            checkComplete();
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoTWFwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBZ0JoRSxtQ0FBbUM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOERHO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FDdkIsT0FBdUMsRUFDdkMsY0FBNkc7SUFFN0csT0FBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDcEMsSUFBSSxlQUFlLEdBQTBDLElBQUksQ0FBQztRQUNsRSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDZCx1REFBdUQ7UUFDdkQsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBRXZCLHdHQUF3RztRQUN4Ryw4RUFBOEU7UUFDOUUsTUFBTSxhQUFhLEdBQUcsR0FBRyxFQUFFLENBQUMsVUFBVSxJQUFJLENBQUMsZUFBZSxJQUFJLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVwRixNQUFNLENBQUMsU0FBUyxDQUNkLHdCQUF3QixDQUN0QixVQUFVLEVBQ1YsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNSLDBEQUEwRDtZQUMxRCxlQUFlLGFBQWYsZUFBZSx1QkFBZixlQUFlLENBQUUsV0FBVyxFQUFFLENBQUM7WUFDL0IsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO1lBQ25CLE1BQU0sVUFBVSxHQUFHLEtBQUssRUFBRSxDQUFDO1lBQzNCLG9DQUFvQztZQUNwQyxTQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FDN0MsQ0FBQyxlQUFlLEdBQUcsd0JBQXdCLENBQ3pDLFVBQVU7WUFDVixvRUFBb0U7WUFDcEUsc0ZBQXNGO1lBQ3RGLHdEQUF3RDtZQUN4RCxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFDMUgsR0FBRyxFQUFFO2dCQUNILDREQUE0RDtnQkFDNUQsa0VBQWtFO2dCQUNsRSxhQUFhO2dCQUNiLGVBQWUsR0FBRyxJQUFLLENBQUM7Z0JBQ3hCLGFBQWEsRUFBRSxDQUFDO1lBQ2xCLENBQUMsQ0FDRixDQUFDLENBQ0gsQ0FBQztRQUNKLENBQUMsRUFDRCxHQUFHLEVBQUU7WUFDSCxVQUFVLEdBQUcsSUFBSSxDQUFDO1lBQ2xCLGFBQWEsRUFBRSxDQUFDO1FBQ2xCLENBQUMsQ0FDRixDQUNGLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hNYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlSW5wdXQsIE9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmVkVmFsdWVPZiB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBzd2l0Y2hNYXA8VCwgTyBleHRlbmRzIE9ic2VydmFibGVJbnB1dDxhbnk+PihcbiAgcHJvamVjdDogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBPXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIE9ic2VydmVkVmFsdWVPZjxPPj47XG4vKiogQGRlcHJlY2F0ZWQgVGhlIGByZXN1bHRTZWxlY3RvcmAgcGFyYW1ldGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OC4gVXNlIGFuIGlubmVyIGBtYXBgIGluc3RlYWQuIERldGFpbHM6IGh0dHBzOi8vcnhqcy5kZXYvZGVwcmVjYXRpb25zL3Jlc3VsdFNlbGVjdG9yICovXG5leHBvcnQgZnVuY3Rpb24gc3dpdGNoTWFwPFQsIE8gZXh0ZW5kcyBPYnNlcnZhYmxlSW5wdXQ8YW55Pj4oXG4gIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gTyxcbiAgcmVzdWx0U2VsZWN0b3I6IHVuZGVmaW5lZFxuKTogT3BlcmF0b3JGdW5jdGlvbjxULCBPYnNlcnZlZFZhbHVlT2Y8Tz4+O1xuLyoqIEBkZXByZWNhdGVkIFRoZSBgcmVzdWx0U2VsZWN0b3JgIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gdjguIFVzZSBhbiBpbm5lciBgbWFwYCBpbnN0ZWFkLiBEZXRhaWxzOiBodHRwczovL3J4anMuZGV2L2RlcHJlY2F0aW9ucy9yZXN1bHRTZWxlY3RvciAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN3aXRjaE1hcDxULCBSLCBPIGV4dGVuZHMgT2JzZXJ2YWJsZUlucHV0PGFueT4+KFxuICBwcm9qZWN0OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE8sXG4gIHJlc3VsdFNlbGVjdG9yOiAob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogT2JzZXJ2ZWRWYWx1ZU9mPE8+LCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUlxuKTogT3BlcmF0b3JGdW5jdGlvbjxULCBSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgZW1pdHRpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgc3dpdGNoQWxsfS48L3NwYW4+XG4gKlxuICogIVtdKHN3aXRjaE1hcC5wbmcpXG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgaW5uZXIgT2JzZXJ2YWJsZS4gV2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsIGBzd2l0Y2hNYXBgXG4gKiBzdG9wcyBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zXG4gKiBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBuZXcgb25lLiBJdCBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3JcbiAqIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIEdlbmVyYXRlIG5ldyBPYnNlcnZhYmxlIGFjY29yZGluZyB0byBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgb2YsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IHN3aXRjaGVkID0gb2YoMSwgMiwgMykucGlwZShzd2l0Y2hNYXAoeCA9PiBvZih4LCB4ICoqIDIsIHggKiogMykpKTtcbiAqIHN3aXRjaGVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIC8vIG91dHB1dHNcbiAqIC8vIDFcbiAqIC8vIDFcbiAqIC8vIDFcbiAqIC8vIDJcbiAqIC8vIDRcbiAqIC8vIDhcbiAqIC8vIDNcbiAqIC8vIDlcbiAqIC8vIDI3XG4gKiBgYGBcbiAqXG4gKiBSZXN0YXJ0IGFuIGludGVydmFsIE9ic2VydmFibGUgb24gZXZlcnkgY2xpY2sgZXZlbnRcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50LCBzd2l0Y2hNYXAsIGludGVydmFsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGNsaWNrcy5waXBlKHN3aXRjaE1hcCgoKSA9PiBpbnRlcnZhbCgxMDAwKSkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaEFsbH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlSW5wdXR9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0IG9mXG4gKiBhcHBseWluZyB0aGUgcHJvamVjdGlvbiBmdW5jdGlvbiAoYW5kIHRoZSBvcHRpb25hbCBkZXByZWNhdGVkXG4gKiBgcmVzdWx0U2VsZWN0b3JgKSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHRha2luZ1xuICogb25seSB0aGUgdmFsdWVzIGZyb20gdGhlIG1vc3QgcmVjZW50bHkgcHJvamVjdGVkIGlubmVyIE9ic2VydmFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzd2l0Y2hNYXA8VCwgUiwgTyBleHRlbmRzIE9ic2VydmFibGVJbnB1dDxhbnk+PihcbiAgcHJvamVjdDogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBPLFxuICByZXN1bHRTZWxlY3Rvcj86IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBPYnNlcnZlZFZhbHVlT2Y8Tz4sIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIE9ic2VydmVkVmFsdWVPZjxPPiB8IFI+IHtcbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIGxldCBpbm5lclN1YnNjcmliZXI6IFN1YnNjcmliZXI8T2JzZXJ2ZWRWYWx1ZU9mPE8+PiB8IG51bGwgPSBudWxsO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgLy8gV2hldGhlciBvciBub3QgdGhlIHNvdXJjZSBzdWJzY3JpcHRpb24gaGFzIGNvbXBsZXRlZFxuICAgIGxldCBpc0NvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAvLyBXZSBvbmx5IGNvbXBsZXRlIHRoZSByZXN1bHQgaWYgdGhlIHNvdXJjZSBpcyBjb21wbGV0ZSBBTkQgd2UgZG9uJ3QgaGF2ZSBhbiBhY3RpdmUgaW5uZXIgc3Vic2NyaXB0aW9uLlxuICAgIC8vIFRoaXMgaXMgY2FsbGVkIGJvdGggd2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcyBhbmQgd2hlbiB0aGUgaW5uZXJzIGNvbXBsZXRlLlxuICAgIGNvbnN0IGNoZWNrQ29tcGxldGUgPSAoKSA9PiBpc0NvbXBsZXRlICYmICFpbm5lclN1YnNjcmliZXIgJiYgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuXG4gICAgc291cmNlLnN1YnNjcmliZShcbiAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgLy8gQ2FuY2VsIHRoZSBwcmV2aW91cyBpbm5lciBzdWJzY3JpcHRpb24gaWYgdGhlcmUgd2FzIG9uZVxuICAgICAgICAgIGlubmVyU3Vic2NyaWJlcj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBsZXQgaW5uZXJJbmRleCA9IDA7XG4gICAgICAgICAgY29uc3Qgb3V0ZXJJbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgaW5uZXIgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgaW5uZXJGcm9tKHByb2plY3QodmFsdWUsIG91dGVySW5kZXgpKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAoaW5uZXJTdWJzY3JpYmVyID0gY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAgICAgICAvLyBXaGVuIHdlIGdldCBhIG5ldyBpbm5lciB2YWx1ZSwgbmV4dCBpdCB0aHJvdWdoLiBOb3RlIHRoYXQgdGhpcyBpc1xuICAgICAgICAgICAgICAvLyBoYW5kbGluZyB0aGUgZGVwcmVjYXRlIHJlc3VsdCBzZWxlY3RvciBoZXJlLiBUaGlzIGlzIGJlY2F1c2Ugd2l0aCB0aGlzIGFyY2hpdGVjdHVyZVxuICAgICAgICAgICAgICAvLyBpdCBlbmRzIHVwIGJlaW5nIHNtYWxsZXIgdGhhbiB1c2luZyB0aGUgbWFwIG9wZXJhdG9yLlxuICAgICAgICAgICAgICAoaW5uZXJWYWx1ZSkgPT4gc3Vic2NyaWJlci5uZXh0KHJlc3VsdFNlbGVjdG9yID8gcmVzdWx0U2VsZWN0b3IodmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgrKykgOiBpbm5lclZhbHVlKSxcbiAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBpbm5lciBoYXMgY29tcGxldGVkLiBOdWxsIG91dCB0aGUgaW5uZXIgc3Vic2NyaWJlciB0b1xuICAgICAgICAgICAgICAgIC8vIGZyZWUgdXAgbWVtb3J5IGFuZCB0byBzaWduYWwgdGhhdCB3ZSBoYXZlIG5vIGlubmVyIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseS5cbiAgICAgICAgICAgICAgICBpbm5lclN1YnNjcmliZXIgPSBudWxsITtcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBsZXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGNoZWNrQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH0pO1xufVxuIl19
