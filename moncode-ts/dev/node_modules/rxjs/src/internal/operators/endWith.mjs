import { concat } from '../observable/concat.mjs';
import { of } from '../observable/of.mjs';
/**
 * Returns an observable that will emit all values from the source, then synchronously emit
 * the provided value(s) immediately after the source completes.
 *
 * NOTE: Passing a last argument of a Scheduler is _deprecated_, and may result in incorrect
 * types in TypeScript.
 *
 * This is useful for knowing when an observable ends. Particularly when paired with an
 * operator like {@link takeUntil}
 *
 * ![](endWith.png)
 *
 * ## Example
 *
 * Emit values to know when an interval starts and stops. The interval will
 * stop when a user clicks anywhere on the document.
 *
 * ```ts
 * import { interval, map, fromEvent, startWith, takeUntil, endWith } from 'rxjs';
 *
 * const ticker$ = interval(5000).pipe(
 *   map(() => 'tick')
 * );
 *
 * const documentClicks$ = fromEvent(document, 'click');
 *
 * ticker$.pipe(
 *   startWith('interval started'),
 *   takeUntil(documentClicks$),
 *   endWith('interval ended by click')
 * )
 * .subscribe(x => console.log(x));
 *
 * // Result (assuming a user clicks after 15 seconds)
 * // 'interval started'
 * // 'tick'
 * // 'tick'
 * // 'tick'
 * // 'interval ended by click'
 * ```
 *
 * @see {@link startWith}
 * @see {@link concat}
 * @see {@link takeUntil}
 *
 * @param values Items you want the modified Observable to emit last.
 * @return A function that returns an Observable that emits all values from the
 * source, then synchronously emits the provided value(s) immediately after the
 * source completes.
 */
export function endWith(...values) {
    return (source) => concat(source, of(...values));
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvZW5kV2l0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDOUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBWXRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaURHO0FBQ0gsTUFBTSxVQUFVLE9BQU8sQ0FBSSxHQUFHLE1BQWdDO0lBQzVELE9BQU8sQ0FBQyxNQUFxQixFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFrQixDQUFDO0FBQ25GLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy9lbmRXaXRoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIHByZXR0aWVyICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tICcuLi9vYnNlcnZhYmxlL2NvbmNhdCc7XG5pbXBvcnQgeyBvZiB9IGZyb20gJy4uL29ic2VydmFibGUvb2YnO1xuaW1wb3J0IHsgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uLCBTY2hlZHVsZXJMaWtlLCBPcGVyYXRvckZ1bmN0aW9uLCBWYWx1ZUZyb21BcnJheSB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqIEBkZXByZWNhdGVkIFRoZSBgc2NoZWR1bGVyYCBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIHY4LiBVc2UgYHNjaGVkdWxlZGAgYW5kIGBjb25jYXRBbGxgLiBEZXRhaWxzOiBodHRwczovL3J4anMuZGV2L2RlcHJlY2F0aW9ucy9zY2hlZHVsZXItYXJndW1lbnQgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRXaXRoPFQ+KHNjaGVkdWxlcjogU2NoZWR1bGVyTGlrZSk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPjtcbi8qKiBAZGVwcmVjYXRlZCBUaGUgYHNjaGVkdWxlcmAgcGFyYW1ldGVyIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OC4gVXNlIGBzY2hlZHVsZWRgIGFuZCBgY29uY2F0QWxsYC4gRGV0YWlsczogaHR0cHM6Ly9yeGpzLmRldi9kZXByZWNhdGlvbnMvc2NoZWR1bGVyLWFyZ3VtZW50ICovXG5leHBvcnQgZnVuY3Rpb24gZW5kV2l0aDxULCBBIGV4dGVuZHMgdW5rbm93bltdID0gVFtdPihcbiAgLi4udmFsdWVzQW5kU2NoZWR1bGVyOiBbLi4uQSwgU2NoZWR1bGVyTGlrZV1cbik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVCB8IFZhbHVlRnJvbUFycmF5PEE+PjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVuZFdpdGg8VCwgQSBleHRlbmRzIHVua25vd25bXSA9IFRbXT4oLi4udmFsdWVzOiBBKTogT3BlcmF0b3JGdW5jdGlvbjxULCBUIHwgVmFsdWVGcm9tQXJyYXk8QT4+O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IHdpbGwgZW1pdCBhbGwgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSwgdGhlbiBzeW5jaHJvbm91c2x5IGVtaXRcbiAqIHRoZSBwcm92aWRlZCB2YWx1ZShzKSBpbW1lZGlhdGVseSBhZnRlciB0aGUgc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiBOT1RFOiBQYXNzaW5nIGEgbGFzdCBhcmd1bWVudCBvZiBhIFNjaGVkdWxlciBpcyBfZGVwcmVjYXRlZF8sIGFuZCBtYXkgcmVzdWx0IGluIGluY29ycmVjdFxuICogdHlwZXMgaW4gVHlwZVNjcmlwdC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3Iga25vd2luZyB3aGVuIGFuIG9ic2VydmFibGUgZW5kcy4gUGFydGljdWxhcmx5IHdoZW4gcGFpcmVkIHdpdGggYW5cbiAqIG9wZXJhdG9yIGxpa2Uge0BsaW5rIHRha2VVbnRpbH1cbiAqXG4gKiAhW10oZW5kV2l0aC5wbmcpXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIEVtaXQgdmFsdWVzIHRvIGtub3cgd2hlbiBhbiBpbnRlcnZhbCBzdGFydHMgYW5kIHN0b3BzLiBUaGUgaW50ZXJ2YWwgd2lsbFxuICogc3RvcCB3aGVuIGEgdXNlciBjbGlja3MgYW55d2hlcmUgb24gdGhlIGRvY3VtZW50LlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpbnRlcnZhbCwgbWFwLCBmcm9tRXZlbnQsIHN0YXJ0V2l0aCwgdGFrZVVudGlsLCBlbmRXaXRoIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgdGlja2VyJCA9IGludGVydmFsKDUwMDApLnBpcGUoXG4gKiAgIG1hcCgoKSA9PiAndGljaycpXG4gKiApO1xuICpcbiAqIGNvbnN0IGRvY3VtZW50Q2xpY2tzJCA9IGZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKlxuICogdGlja2VyJC5waXBlKFxuICogICBzdGFydFdpdGgoJ2ludGVydmFsIHN0YXJ0ZWQnKSxcbiAqICAgdGFrZVVudGlsKGRvY3VtZW50Q2xpY2tzJCksXG4gKiAgIGVuZFdpdGgoJ2ludGVydmFsIGVuZGVkIGJ5IGNsaWNrJylcbiAqIClcbiAqIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0IChhc3N1bWluZyBhIHVzZXIgY2xpY2tzIGFmdGVyIDE1IHNlY29uZHMpXG4gKiAvLyAnaW50ZXJ2YWwgc3RhcnRlZCdcbiAqIC8vICd0aWNrJ1xuICogLy8gJ3RpY2snXG4gKiAvLyAndGljaydcbiAqIC8vICdpbnRlcnZhbCBlbmRlZCBieSBjbGljaydcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHN0YXJ0V2l0aH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIEl0ZW1zIHlvdSB3YW50IHRoZSBtb2RpZmllZCBPYnNlcnZhYmxlIHRvIGVtaXQgbGFzdC5cbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSB0aGVcbiAqIHNvdXJjZSwgdGhlbiBzeW5jaHJvbm91c2x5IGVtaXRzIHRoZSBwcm92aWRlZCB2YWx1ZShzKSBpbW1lZGlhdGVseSBhZnRlciB0aGVcbiAqIHNvdXJjZSBjb21wbGV0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRXaXRoPFQ+KC4uLnZhbHVlczogQXJyYXk8VCB8IFNjaGVkdWxlckxpa2U+KTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IGNvbmNhdChzb3VyY2UsIG9mKC4uLnZhbHVlcykpIGFzIE9ic2VydmFibGU8VD47XG59XG4iXX0=
