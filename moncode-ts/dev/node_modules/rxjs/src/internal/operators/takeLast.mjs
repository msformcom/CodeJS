import { EMPTY } from '../observable/empty.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Waits for the source to complete, then emits the last N values from the source,
 * as specified by the `count` argument.
 *
 * ![](takeLast.png)
 *
 * `takeLast` results in an observable that will hold values up to `count` values in memory,
 * until the source completes. It then pushes all values in memory to the consumer, in the
 * order they were received from the source, then notifies the consumer that it is
 * complete.
 *
 * If for some reason the source completes before the `count` supplied to `takeLast` is reached,
 * all values received until that point are emitted, and then completion is notified.
 *
 * **Warning**: Using `takeLast` with an observable that never completes will result
 * in an observable that never emits a value.
 *
 * ## Example
 *
 * Take the last 3 values of an Observable with many values
 *
 * ```ts
 * import { range, takeLast } from 'rxjs';
 *
 * const many = range(1, 100);
 * const lastThree = many.pipe(takeLast(3));
 * lastThree.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link take}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param count The maximum number of values to emit from the end of
 * the sequence of values emitted by the source Observable.
 * @return A function that returns an Observable that emits at most the last
 * `count` values emitted by the source Observable.
 */
export function takeLast(count) {
    return count <= 0
        ? () => EMPTY
        : operate((source, subscriber) => {
            // This buffer will hold the values we are going to emit
            // when the source completes. Since we only want to take the
            // last N values, we can't emit until we're sure we're not getting
            // any more values.
            let buffer = [];
            source.subscribe(createOperatorSubscriber(subscriber, (value) => {
                // Add the most recent value onto the end of our buffer.
                buffer.push(value);
                // If our buffer is now larger than the number of values we
                // want to take, we remove the oldest value from the buffer.
                count < buffer.length && buffer.shift();
            }, () => {
                // The source completed, we now know what are last values
                // are, emit them in the order they were received.
                for (const value of buffer) {
                    subscriber.next(value);
                }
                subscriber.complete();
            }, 
            // Errors are passed through to the consumer
            undefined, () => {
                // During finalization release the values in our buffer.
                buffer = null;
            }));
        });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZUxhc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRTVDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFaEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0NHO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FBSSxLQUFhO0lBQ3ZDLE9BQU8sS0FBSyxJQUFJLENBQUM7UUFDZixDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSztRQUNiLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7WUFDN0Isd0RBQXdEO1lBQ3hELDREQUE0RDtZQUM1RCxrRUFBa0U7WUFDbEUsbUJBQW1CO1lBQ25CLElBQUksTUFBTSxHQUFRLEVBQUUsQ0FBQztZQUNyQixNQUFNLENBQUMsU0FBUyxDQUNkLHdCQUF3QixDQUN0QixVQUFVLEVBQ1YsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDUix3REFBd0Q7Z0JBQ3hELE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ25CLDJEQUEyRDtnQkFDM0QsNERBQTREO2dCQUM1RCxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDMUMsQ0FBQyxFQUNELEdBQUcsRUFBRTtnQkFDSCx5REFBeUQ7Z0JBQ3pELGtEQUFrRDtnQkFDbEQsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUUsQ0FBQztvQkFDM0IsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDekIsQ0FBQztnQkFDRCxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDeEIsQ0FBQztZQUNELDRDQUE0QztZQUM1QyxTQUFTLEVBQ1QsR0FBRyxFQUFFO2dCQUNILHdEQUF3RDtnQkFDeEQsTUFBTSxHQUFHLElBQUssQ0FBQztZQUNqQixDQUFDLENBQ0YsQ0FDRixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7QUFDVCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZUxhc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFTVBUWSB9IGZyb20gJy4uL29ic2VydmFibGUvZW1wdHknO1xuaW1wb3J0IHsgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5cbi8qKlxuICogV2FpdHMgZm9yIHRoZSBzb3VyY2UgdG8gY29tcGxldGUsIHRoZW4gZW1pdHMgdGhlIGxhc3QgTiB2YWx1ZXMgZnJvbSB0aGUgc291cmNlLFxuICogYXMgc3BlY2lmaWVkIGJ5IHRoZSBgY291bnRgIGFyZ3VtZW50LlxuICpcbiAqICFbXSh0YWtlTGFzdC5wbmcpXG4gKlxuICogYHRha2VMYXN0YCByZXN1bHRzIGluIGFuIG9ic2VydmFibGUgdGhhdCB3aWxsIGhvbGQgdmFsdWVzIHVwIHRvIGBjb3VudGAgdmFsdWVzIGluIG1lbW9yeSxcbiAqIHVudGlsIHRoZSBzb3VyY2UgY29tcGxldGVzLiBJdCB0aGVuIHB1c2hlcyBhbGwgdmFsdWVzIGluIG1lbW9yeSB0byB0aGUgY29uc3VtZXIsIGluIHRoZVxuICogb3JkZXIgdGhleSB3ZXJlIHJlY2VpdmVkIGZyb20gdGhlIHNvdXJjZSwgdGhlbiBub3RpZmllcyB0aGUgY29uc3VtZXIgdGhhdCBpdCBpc1xuICogY29tcGxldGUuXG4gKlxuICogSWYgZm9yIHNvbWUgcmVhc29uIHRoZSBzb3VyY2UgY29tcGxldGVzIGJlZm9yZSB0aGUgYGNvdW50YCBzdXBwbGllZCB0byBgdGFrZUxhc3RgIGlzIHJlYWNoZWQsXG4gKiBhbGwgdmFsdWVzIHJlY2VpdmVkIHVudGlsIHRoYXQgcG9pbnQgYXJlIGVtaXR0ZWQsIGFuZCB0aGVuIGNvbXBsZXRpb24gaXMgbm90aWZpZWQuXG4gKlxuICogKipXYXJuaW5nKio6IFVzaW5nIGB0YWtlTGFzdGAgd2l0aCBhbiBvYnNlcnZhYmxlIHRoYXQgbmV2ZXIgY29tcGxldGVzIHdpbGwgcmVzdWx0XG4gKiBpbiBhbiBvYnNlcnZhYmxlIHRoYXQgbmV2ZXIgZW1pdHMgYSB2YWx1ZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogVGFrZSB0aGUgbGFzdCAzIHZhbHVlcyBvZiBhbiBPYnNlcnZhYmxlIHdpdGggbWFueSB2YWx1ZXNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcmFuZ2UsIHRha2VMYXN0IH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgbWFueSA9IHJhbmdlKDEsIDEwMCk7XG4gKiBjb25zdCBsYXN0VGhyZWUgPSBtYW55LnBpcGUodGFrZUxhc3QoMykpO1xuICogbGFzdFRocmVlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlVW50aWx9XG4gKiBAc2VlIHtAbGluayB0YWtlV2hpbGV9XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSBjb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgdmFsdWVzIHRvIGVtaXQgZnJvbSB0aGUgZW5kIG9mXG4gKiB0aGUgc2VxdWVuY2Ugb2YgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYXQgbW9zdCB0aGUgbGFzdFxuICogYGNvdW50YCB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWtlTGFzdDxUPihjb3VudDogbnVtYmVyKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgcmV0dXJuIGNvdW50IDw9IDBcbiAgICA/ICgpID0+IEVNUFRZXG4gICAgOiBvcGVyYXRlKChzb3VyY2UsIHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgLy8gVGhpcyBidWZmZXIgd2lsbCBob2xkIHRoZSB2YWx1ZXMgd2UgYXJlIGdvaW5nIHRvIGVtaXRcbiAgICAgICAgLy8gd2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcy4gU2luY2Ugd2Ugb25seSB3YW50IHRvIHRha2UgdGhlXG4gICAgICAgIC8vIGxhc3QgTiB2YWx1ZXMsIHdlIGNhbid0IGVtaXQgdW50aWwgd2UncmUgc3VyZSB3ZSdyZSBub3QgZ2V0dGluZ1xuICAgICAgICAvLyBhbnkgbW9yZSB2YWx1ZXMuXG4gICAgICAgIGxldCBidWZmZXI6IFRbXSA9IFtdO1xuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgICAgIHN1YnNjcmliZXIsXG4gICAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgLy8gQWRkIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBvbnRvIHRoZSBlbmQgb2Ygb3VyIGJ1ZmZlci5cbiAgICAgICAgICAgICAgYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAvLyBJZiBvdXIgYnVmZmVyIGlzIG5vdyBsYXJnZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyB3ZVxuICAgICAgICAgICAgICAvLyB3YW50IHRvIHRha2UsIHdlIHJlbW92ZSB0aGUgb2xkZXN0IHZhbHVlIGZyb20gdGhlIGJ1ZmZlci5cbiAgICAgICAgICAgICAgY291bnQgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgLy8gVGhlIHNvdXJjZSBjb21wbGV0ZWQsIHdlIG5vdyBrbm93IHdoYXQgYXJlIGxhc3QgdmFsdWVzXG4gICAgICAgICAgICAgIC8vIGFyZSwgZW1pdCB0aGVtIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVjZWl2ZWQuXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRXJyb3JzIGFyZSBwYXNzZWQgdGhyb3VnaCB0byB0aGUgY29uc3VtZXJcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgLy8gRHVyaW5nIGZpbmFsaXphdGlvbiByZWxlYXNlIHRoZSB2YWx1ZXMgaW4gb3VyIGJ1ZmZlci5cbiAgICAgICAgICAgICAgYnVmZmVyID0gbnVsbCE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSk7XG59XG4iXX0=
