import { asyncScheduler } from '../scheduler/async.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Emits a notification from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent notification from each burst of emissions.</span>
 *
 * ![](debounceTime.png)
 *
 * `debounceTime` delays notifications emitted by the source Observable, but drops
 * previous pending delayed emissions if a new notification arrives on the source
 * Observable. This operator keeps track of the most recent notification from the
 * source Observable, and emits that only when `dueTime` has passed
 * without any other notification appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous notification will be dropped
 * and will not be emitted and a new `dueTime` is scheduled.
 * If the completing event happens during `dueTime` the last cached notification
 * is emitted before the completion event is forwarded to the output observable.
 * If the error event happens during `dueTime` or after it only the error event is
 * forwarded to the output observable. The cache notification is not emitted in this case.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * notification to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link SchedulerLike} for
 * managing timers.
 *
 * ## Example
 *
 * Emit the most recent click after a burst of clicks
 *
 * ```ts
 * import { fromEvent, debounceTime } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(debounceTime(1000));
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link audit}
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link sample}
 * @see {@link sampleTime}
 * @see {@link throttle}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for
 * managing the timers that handle the timeout for each value.
 * @return A function that returns an Observable that delays the emissions of
 * the source Observable by the specified `dueTime`, and may drop some values
 * if they occur too frequently.
 */
export function debounceTime(dueTime, scheduler = asyncScheduler) {
    return operate((source, subscriber) => {
        let activeTask = null;
        let lastValue = null;
        let lastTime = null;
        const emit = () => {
            if (activeTask) {
                // We have a value! Free up memory first, then emit the value.
                activeTask.unsubscribe();
                activeTask = null;
                const value = lastValue;
                lastValue = null;
                subscriber.next(value);
            }
        };
        function emitWhenIdle() {
            // This is called `dueTime` after the first value
            // but we might have received new values during this window!
            const targetTime = lastTime + dueTime;
            const now = scheduler.now();
            if (now < targetTime) {
                // On that case, re-schedule to the new target
                activeTask = this.schedule(undefined, targetTime - now);
                subscriber.add(activeTask);
                return;
            }
            emit();
        }
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            lastValue = value;
            lastTime = scheduler.now();
            // Only set up a task if it's not already up
            if (!activeTask) {
                activeTask = scheduler.schedule(emitWhenIdle, dueTime);
                subscriber.add(activeTask);
            }
        }, () => {
            // Source completed.
            // Emit any pending debounced values then complete
            emit();
            subscriber.complete();
        }, 
        // Pass all errors through to consumer.
        undefined, () => {
            // Finalization.
            lastValue = activeTask = null;
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVib3VuY2VUaW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUdwRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRWhFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdERztBQUNILE1BQU0sVUFBVSxZQUFZLENBQUksT0FBZSxFQUFFLFlBQTJCLGNBQWM7SUFDeEYsT0FBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDcEMsSUFBSSxVQUFVLEdBQXdCLElBQUksQ0FBQztRQUMzQyxJQUFJLFNBQVMsR0FBYSxJQUFJLENBQUM7UUFDL0IsSUFBSSxRQUFRLEdBQWtCLElBQUksQ0FBQztRQUVuQyxNQUFNLElBQUksR0FBRyxHQUFHLEVBQUU7WUFDaEIsSUFBSSxVQUFVLEVBQUUsQ0FBQztnQkFDZiw4REFBOEQ7Z0JBQzlELFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDekIsVUFBVSxHQUFHLElBQUksQ0FBQztnQkFDbEIsTUFBTSxLQUFLLEdBQUcsU0FBVSxDQUFDO2dCQUN6QixTQUFTLEdBQUcsSUFBSSxDQUFDO2dCQUNqQixVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pCLENBQUM7UUFDSCxDQUFDLENBQUM7UUFDRixTQUFTLFlBQVk7WUFDbkIsaURBQWlEO1lBQ2pELDREQUE0RDtZQUU1RCxNQUFNLFVBQVUsR0FBRyxRQUFTLEdBQUcsT0FBTyxDQUFDO1lBQ3ZDLE1BQU0sR0FBRyxHQUFHLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUM1QixJQUFJLEdBQUcsR0FBRyxVQUFVLEVBQUUsQ0FBQztnQkFDckIsOENBQThDO2dCQUM5QyxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsVUFBVSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN4RCxVQUFVLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUMzQixPQUFPO1lBQ1QsQ0FBQztZQUVELElBQUksRUFBRSxDQUFDO1FBQ1QsQ0FBQztRQUVELE1BQU0sQ0FBQyxTQUFTLENBQ2Qsd0JBQXdCLENBQ3RCLFVBQVUsRUFDVixDQUFDLEtBQVEsRUFBRSxFQUFFO1lBQ1gsU0FBUyxHQUFHLEtBQUssQ0FBQztZQUNsQixRQUFRLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBRTNCLDRDQUE0QztZQUM1QyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ2hCLFVBQVUsR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDdkQsVUFBVSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUM3QixDQUFDO1FBQ0gsQ0FBQyxFQUNELEdBQUcsRUFBRTtZQUNILG9CQUFvQjtZQUNwQixrREFBa0Q7WUFDbEQsSUFBSSxFQUFFLENBQUM7WUFDUCxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDeEIsQ0FBQztRQUNELHVDQUF1QztRQUN2QyxTQUFTLEVBQ1QsR0FBRyxFQUFFO1lBQ0gsZ0JBQWdCO1lBQ2hCLFNBQVMsR0FBRyxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ2hDLENBQUMsQ0FDRixDQUNGLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy9kZWJvdW5jZVRpbWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3luY1NjaGVkdWxlciB9IGZyb20gJy4uL3NjaGVkdWxlci9hc3luYyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uLCBTY2hlZHVsZXJBY3Rpb24sIFNjaGVkdWxlckxpa2UgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcblxuLyoqXG4gKiBFbWl0cyBhIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbmx5IGFmdGVyIGEgcGFydGljdWxhciB0aW1lIHNwYW5cbiAqIGhhcyBwYXNzZWQgd2l0aG91dCBhbm90aGVyIHNvdXJjZSBlbWlzc2lvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBkZWxheX0sIGJ1dCBwYXNzZXMgb25seSB0aGUgbW9zdFxuICogcmVjZW50IG5vdGlmaWNhdGlvbiBmcm9tIGVhY2ggYnVyc3Qgb2YgZW1pc3Npb25zLjwvc3Bhbj5cbiAqXG4gKiAhW10oZGVib3VuY2VUaW1lLnBuZylcbiAqXG4gKiBgZGVib3VuY2VUaW1lYCBkZWxheXMgbm90aWZpY2F0aW9ucyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IGRyb3BzXG4gKiBwcmV2aW91cyBwZW5kaW5nIGRlbGF5ZWQgZW1pc3Npb25zIGlmIGEgbmV3IG5vdGlmaWNhdGlvbiBhcnJpdmVzIG9uIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoaXMgb3BlcmF0b3Iga2VlcHMgdHJhY2sgb2YgdGhlIG1vc3QgcmVjZW50IG5vdGlmaWNhdGlvbiBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGF0IG9ubHkgd2hlbiBgZHVlVGltZWAgaGFzIHBhc3NlZFxuICogd2l0aG91dCBhbnkgb3RoZXIgbm90aWZpY2F0aW9uIGFwcGVhcmluZyBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGEgbmV3IHZhbHVlXG4gKiBhcHBlYXJzIGJlZm9yZSBgZHVlVGltZWAgc2lsZW5jZSBvY2N1cnMsIHRoZSBwcmV2aW91cyBub3RpZmljYXRpb24gd2lsbCBiZSBkcm9wcGVkXG4gKiBhbmQgd2lsbCBub3QgYmUgZW1pdHRlZCBhbmQgYSBuZXcgYGR1ZVRpbWVgIGlzIHNjaGVkdWxlZC5cbiAqIElmIHRoZSBjb21wbGV0aW5nIGV2ZW50IGhhcHBlbnMgZHVyaW5nIGBkdWVUaW1lYCB0aGUgbGFzdCBjYWNoZWQgbm90aWZpY2F0aW9uXG4gKiBpcyBlbWl0dGVkIGJlZm9yZSB0aGUgY29tcGxldGlvbiBldmVudCBpcyBmb3J3YXJkZWQgdG8gdGhlIG91dHB1dCBvYnNlcnZhYmxlLlxuICogSWYgdGhlIGVycm9yIGV2ZW50IGhhcHBlbnMgZHVyaW5nIGBkdWVUaW1lYCBvciBhZnRlciBpdCBvbmx5IHRoZSBlcnJvciBldmVudCBpc1xuICogZm9yd2FyZGVkIHRvIHRoZSBvdXRwdXQgb2JzZXJ2YWJsZS4gVGhlIGNhY2hlIG5vdGlmaWNhdGlvbiBpcyBub3QgZW1pdHRlZCBpbiB0aGlzIGNhc2UuXG4gKlxuICogVGhpcyBpcyBhIHJhdGUtbGltaXRpbmcgb3BlcmF0b3IsIGJlY2F1c2UgaXQgaXMgaW1wb3NzaWJsZSBmb3IgbW9yZSB0aGFuIG9uZVxuICogbm90aWZpY2F0aW9uIHRvIGJlIGVtaXR0ZWQgaW4gYW55IHRpbWUgd2luZG93IG9mIGR1cmF0aW9uIGBkdWVUaW1lYCwgYnV0IGl0IGlzIGFsc29cbiAqIGEgZGVsYXktbGlrZSBvcGVyYXRvciBzaW5jZSBvdXRwdXQgZW1pc3Npb25zIGRvIG5vdCBvY2N1ciBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gKiB0aGV5IGRpZCBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIE9wdGlvbmFsbHkgdGFrZXMgYSB7QGxpbmsgU2NoZWR1bGVyTGlrZX0gZm9yXG4gKiBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIEVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGFmdGVyIGEgYnVyc3Qgb2YgY2xpY2tzXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21FdmVudCwgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGNsaWNrcy5waXBlKGRlYm91bmNlVGltZSgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXR9XG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVlVGltZSBUaGUgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lXG4gKiB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGZvciB0aGUgd2luZG93IG9mXG4gKiB0aW1lIHJlcXVpcmVkIHRvIHdhaXQgZm9yIGVtaXNzaW9uIHNpbGVuY2UgYmVmb3JlIGVtaXR0aW5nIHRoZSBtb3N0IHJlY2VudFxuICogc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtTY2hlZHVsZXJMaWtlfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUge0BsaW5rIFNjaGVkdWxlckxpa2V9IHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHRpbWVvdXQgZm9yIGVhY2ggdmFsdWUuXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZlxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IHRoZSBzcGVjaWZpZWQgYGR1ZVRpbWVgLCBhbmQgbWF5IGRyb3Agc29tZSB2YWx1ZXNcbiAqIGlmIHRoZXkgb2NjdXIgdG9vIGZyZXF1ZW50bHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVRpbWU8VD4oZHVlVGltZTogbnVtYmVyLCBzY2hlZHVsZXI6IFNjaGVkdWxlckxpa2UgPSBhc3luY1NjaGVkdWxlcik6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPiB7XG4gIHJldHVybiBvcGVyYXRlKChzb3VyY2UsIHN1YnNjcmliZXIpID0+IHtcbiAgICBsZXQgYWN0aXZlVGFzazogU3Vic2NyaXB0aW9uIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGxhc3RWYWx1ZTogVCB8IG51bGwgPSBudWxsO1xuICAgIGxldCBsYXN0VGltZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdCBlbWl0ID0gKCkgPT4ge1xuICAgICAgaWYgKGFjdGl2ZVRhc2spIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIHZhbHVlISBGcmVlIHVwIG1lbW9yeSBmaXJzdCwgdGhlbiBlbWl0IHRoZSB2YWx1ZS5cbiAgICAgICAgYWN0aXZlVGFzay51bnN1YnNjcmliZSgpO1xuICAgICAgICBhY3RpdmVUYXNrID0gbnVsbDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsYXN0VmFsdWUhO1xuICAgICAgICBsYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gZW1pdFdoZW5JZGxlKHRoaXM6IFNjaGVkdWxlckFjdGlvbjx1bmtub3duPikge1xuICAgICAgLy8gVGhpcyBpcyBjYWxsZWQgYGR1ZVRpbWVgIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgLy8gYnV0IHdlIG1pZ2h0IGhhdmUgcmVjZWl2ZWQgbmV3IHZhbHVlcyBkdXJpbmcgdGhpcyB3aW5kb3chXG5cbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBsYXN0VGltZSEgKyBkdWVUaW1lO1xuICAgICAgY29uc3Qgbm93ID0gc2NoZWR1bGVyLm5vdygpO1xuICAgICAgaWYgKG5vdyA8IHRhcmdldFRpbWUpIHtcbiAgICAgICAgLy8gT24gdGhhdCBjYXNlLCByZS1zY2hlZHVsZSB0byB0aGUgbmV3IHRhcmdldFxuICAgICAgICBhY3RpdmVUYXNrID0gdGhpcy5zY2hlZHVsZSh1bmRlZmluZWQsIHRhcmdldFRpbWUgLSBub3cpO1xuICAgICAgICBzdWJzY3JpYmVyLmFkZChhY3RpdmVUYXNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbWl0KCk7XG4gICAgfVxuXG4gICAgc291cmNlLnN1YnNjcmliZShcbiAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgKHZhbHVlOiBUKSA9PiB7XG4gICAgICAgICAgbGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgbGFzdFRpbWUgPSBzY2hlZHVsZXIubm93KCk7XG5cbiAgICAgICAgICAvLyBPbmx5IHNldCB1cCBhIHRhc2sgaWYgaXQncyBub3QgYWxyZWFkeSB1cFxuICAgICAgICAgIGlmICghYWN0aXZlVGFzaykge1xuICAgICAgICAgICAgYWN0aXZlVGFzayA9IHNjaGVkdWxlci5zY2hlZHVsZShlbWl0V2hlbklkbGUsIGR1ZVRpbWUpO1xuICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoYWN0aXZlVGFzayk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gU291cmNlIGNvbXBsZXRlZC5cbiAgICAgICAgICAvLyBFbWl0IGFueSBwZW5kaW5nIGRlYm91bmNlZCB2YWx1ZXMgdGhlbiBjb21wbGV0ZVxuICAgICAgICAgIGVtaXQoKTtcbiAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBhc3MgYWxsIGVycm9ycyB0aHJvdWdoIHRvIGNvbnN1bWVyLlxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBGaW5hbGl6YXRpb24uXG4gICAgICAgICAgbGFzdFZhbHVlID0gYWN0aXZlVGFzayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9KTtcbn1cbiJdfQ==
