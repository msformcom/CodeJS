import { argsOrArgArray } from '../util/argsOrArgArray.mjs';
import { onErrorResumeNext as oERNCreate } from '../observable/onErrorResumeNext.mjs';
/**
 * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
 * that was passed.
 *
 * <span class="informal">Execute series of Observables, subscribes to next one on error or complete.</span>
 *
 * ![](onErrorResumeNext.png)
 *
 * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as
 * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same
 * as the source.
 *
 * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.
 * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`
 * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting
 * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another
 * Observable in provided series, no matter if previous Observable completed or ended with an error. This will
 * be happening until there is no more Observables left in the series, at which point returned Observable will
 * complete - even if the last subscribed stream ended with an error.
 *
 * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive
 * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable
 * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with
 * an error.
 *
 * Note that you do not get any access to errors emitted by the Observables. In particular do not
 * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take
 * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.
 *
 *
 * ## Example
 *
 * Subscribe to the next Observable after map fails
 *
 * ```ts
 * import { of, onErrorResumeNext, map } from 'rxjs';
 *
 * of(1, 2, 3, 0)
 *   .pipe(
 *     map(x => {
 *       if (x === 0) {
 *         throw Error();
 *       }
 *
 *       return 10 / x;
 *     }),
 *     onErrorResumeNext(of(1, 2, 3))
 *   )
 *   .subscribe({
 *     next: val => console.log(val),
 *     error: err => console.log(err),          // Will never be called.
 *     complete: () => console.log('that\'s it!')
 *   });
 *
 * // Logs:
 * // 10
 * // 5
 * // 3.3333333333333335
 * // 1
 * // 2
 * // 3
 * // 'that's it!'
 * ```
 *
 * @see {@link concat}
 * @see {@link catchError}
 *
 * @param {...ObservableInput} sources Observables passed either directly or as an array.
 * @return A function that returns an Observable that emits values from source
 * Observable, but - if it errors - subscribes to the next passed Observable
 * and so on, until it completes or runs out of Observables.
 */
export function onErrorResumeNextWith(...sources) {
    // For some reason, TS 4.1 RC gets the inference wrong here and infers the
    // result to be `A[number][]` - completely dropping the ObservableInput part
    // of the type. This makes no sense whatsoever. As a workaround, the type is
    // asserted explicitly.
    const nextSources = argsOrArgArray(sources);
    return (source) => oERNCreate(source, ...nextSources);
}
/**
 * @deprecated Renamed. Use {@link onErrorResumeNextWith} instead. Will be removed in v8.
 */
export const onErrorResumeNext = onErrorResumeNextWith;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvb25FcnJvclJlc3VtZU5leHRXaXRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsaUJBQWlCLElBQUksVUFBVSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFTbEY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUVHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQixDQUNuQyxHQUFHLE9BQXNFO0lBRXpFLDBFQUEwRTtJQUMxRSw0RUFBNEU7SUFDNUUsNEVBQTRFO0lBQzVFLHVCQUF1QjtJQUN2QixNQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsT0FBTyxDQUF1QyxDQUFDO0lBRWxGLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBRyxxQkFBcUIsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL29uRXJyb3JSZXN1bWVOZXh0V2l0aC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGVJbnB1dFR1cGxlLCBPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXJnc09yQXJnQXJyYXkgfSBmcm9tICcuLi91dGlsL2FyZ3NPckFyZ0FycmF5JztcbmltcG9ydCB7IG9uRXJyb3JSZXN1bWVOZXh0IGFzIG9FUk5DcmVhdGUgfSBmcm9tICcuLi9vYnNlcnZhYmxlL29uRXJyb3JSZXN1bWVOZXh0JztcblxuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0V2l0aDxULCBBIGV4dGVuZHMgcmVhZG9ubHkgdW5rbm93bltdPihcbiAgc291cmNlczogWy4uLk9ic2VydmFibGVJbnB1dFR1cGxlPEE+XVxuKTogT3BlcmF0b3JGdW5jdGlvbjxULCBUIHwgQVtudW1iZXJdPjtcbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dFdpdGg8VCwgQSBleHRlbmRzIHJlYWRvbmx5IHVua25vd25bXT4oXG4gIC4uLnNvdXJjZXM6IFsuLi5PYnNlcnZhYmxlSW5wdXRUdXBsZTxBPl1cbik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVCB8IEFbbnVtYmVyXT47XG5cbi8qKlxuICogV2hlbiBhbnkgb2YgdGhlIHByb3ZpZGVkIE9ic2VydmFibGUgZW1pdHMgYW4gY29tcGxldGUgb3IgZXJyb3Igbm90aWZpY2F0aW9uLCBpdCBpbW1lZGlhdGVseSBzdWJzY3JpYmVzIHRvIHRoZSBuZXh0IG9uZVxuICogdGhhdCB3YXMgcGFzc2VkLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FeGVjdXRlIHNlcmllcyBvZiBPYnNlcnZhYmxlcywgc3Vic2NyaWJlcyB0byBuZXh0IG9uZSBvbiBlcnJvciBvciBjb21wbGV0ZS48L3NwYW4+XG4gKlxuICogIVtdKG9uRXJyb3JSZXN1bWVOZXh0LnBuZylcbiAqXG4gKiBgb25FcnJvclJlc3VtZU5leHRgIGlzIGFuIG9wZXJhdG9yIHRoYXQgYWNjZXB0cyBhIHNlcmllcyBvZiBPYnNlcnZhYmxlcywgcHJvdmlkZWQgZWl0aGVyIGRpcmVjdGx5IGFzXG4gKiBhcmd1bWVudHMgb3IgYXMgYW4gYXJyYXkuIElmIG5vIHNpbmdsZSBPYnNlcnZhYmxlIGlzIHByb3ZpZGVkLCByZXR1cm5lZCBPYnNlcnZhYmxlIHdpbGwgc2ltcGx5IGJlaGF2ZSB0aGUgc2FtZVxuICogYXMgdGhlIHNvdXJjZS5cbiAqXG4gKiBgb25FcnJvclJlc3VtZU5leHRgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHN0YXJ0cyBieSBzdWJzY3JpYmluZyBhbmQgcmUtZW1pdHRpbmcgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogV2hlbiBpdHMgc3RyZWFtIG9mIHZhbHVlcyBlbmRzIC0gbm8gbWF0dGVyIGlmIE9ic2VydmFibGUgY29tcGxldGVkIG9yIGVtaXR0ZWQgYW4gZXJyb3IgLSBgb25FcnJvclJlc3VtZU5leHRgXG4gKiB3aWxsIHN1YnNjcmliZSB0byB0aGUgZmlyc3QgT2JzZXJ2YWJsZSB0aGF0IHdhcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIG1ldGhvZC4gSXQgd2lsbCBzdGFydCByZS1lbWl0dGluZ1xuICogaXRzIHZhbHVlcyBhcyB3ZWxsIGFuZCAtIGFnYWluIC0gd2hlbiB0aGF0IHN0cmVhbSBlbmRzLCBgb25FcnJvclJlc3VtZU5leHRgIHdpbGwgcHJvY2VlZCB0byBzdWJzY3JpYmluZyB5ZXQgYW5vdGhlclxuICogT2JzZXJ2YWJsZSBpbiBwcm92aWRlZCBzZXJpZXMsIG5vIG1hdHRlciBpZiBwcmV2aW91cyBPYnNlcnZhYmxlIGNvbXBsZXRlZCBvciBlbmRlZCB3aXRoIGFuIGVycm9yLiBUaGlzIHdpbGxcbiAqIGJlIGhhcHBlbmluZyB1bnRpbCB0aGVyZSBpcyBubyBtb3JlIE9ic2VydmFibGVzIGxlZnQgaW4gdGhlIHNlcmllcywgYXQgd2hpY2ggcG9pbnQgcmV0dXJuZWQgT2JzZXJ2YWJsZSB3aWxsXG4gKiBjb21wbGV0ZSAtIGV2ZW4gaWYgdGhlIGxhc3Qgc3Vic2NyaWJlZCBzdHJlYW0gZW5kZWQgd2l0aCBhbiBlcnJvci5cbiAqXG4gKiBgb25FcnJvclJlc3VtZU5leHRgIGNhbiBiZSB0aGVyZWZvcmUgdGhvdWdodCBvZiBhcyB2ZXJzaW9uIG9mIHtAbGluayBjb25jYXR9IG9wZXJhdG9yLCB3aGljaCBpcyBtb3JlIHBlcm1pc3NpdmVcbiAqIHdoZW4gaXQgY29tZXMgdG8gdGhlIGVycm9ycyBlbWl0dGVkIGJ5IGl0cyBpbnB1dCBPYnNlcnZhYmxlcy4gV2hpbGUgYGNvbmNhdGAgc3Vic2NyaWJlcyB0byB0aGUgbmV4dCBPYnNlcnZhYmxlXG4gKiBpbiBzZXJpZXMgb25seSBpZiBwcmV2aW91cyBvbmUgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCwgYG9uRXJyb3JSZXN1bWVOZXh0YCBzdWJzY3JpYmVzIGV2ZW4gaWYgaXQgZW5kZWQgd2l0aFxuICogYW4gZXJyb3IuXG4gKlxuICogTm90ZSB0aGF0IHlvdSBkbyBub3QgZ2V0IGFueSBhY2Nlc3MgdG8gZXJyb3JzIGVtaXR0ZWQgYnkgdGhlIE9ic2VydmFibGVzLiBJbiBwYXJ0aWN1bGFyIGRvIG5vdFxuICogZXhwZWN0IHRoZXNlIGVycm9ycyB0byBhcHBlYXIgaW4gZXJyb3IgY2FsbGJhY2sgcGFzc2VkIHRvIHtAbGluayBPYnNlcnZhYmxlI3N1YnNjcmliZX0uIElmIHlvdSB3YW50IHRvIHRha2VcbiAqIHNwZWNpZmljIGFjdGlvbnMgYmFzZWQgb24gd2hhdCBlcnJvciB3YXMgZW1pdHRlZCBieSBhbiBPYnNlcnZhYmxlLCB5b3Ugc2hvdWxkIHRyeSBvdXQge0BsaW5rIGNhdGNoRXJyb3J9IGluc3RlYWQuXG4gKlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBTdWJzY3JpYmUgdG8gdGhlIG5leHQgT2JzZXJ2YWJsZSBhZnRlciBtYXAgZmFpbHNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgb2YsIG9uRXJyb3JSZXN1bWVOZXh0LCBtYXAgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBvZigxLCAyLCAzLCAwKVxuICogICAucGlwZShcbiAqICAgICBtYXAoeCA9PiB7XG4gKiAgICAgICBpZiAoeCA9PT0gMCkge1xuICogICAgICAgICB0aHJvdyBFcnJvcigpO1xuICogICAgICAgfVxuICpcbiAqICAgICAgIHJldHVybiAxMCAvIHg7XG4gKiAgICAgfSksXG4gKiAgICAgb25FcnJvclJlc3VtZU5leHQob2YoMSwgMiwgMykpXG4gKiAgIClcbiAqICAgLnN1YnNjcmliZSh7XG4gKiAgICAgbmV4dDogdmFsID0+IGNvbnNvbGUubG9nKHZhbCksXG4gKiAgICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmxvZyhlcnIpLCAgICAgICAgICAvLyBXaWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAqICAgICBjb21wbGV0ZTogKCkgPT4gY29uc29sZS5sb2coJ3RoYXRcXCdzIGl0IScpXG4gKiAgIH0pO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyAxMFxuICogLy8gNVxuICogLy8gMy4zMzMzMzMzMzMzMzMzMzM1XG4gKiAvLyAxXG4gKiAvLyAyXG4gKiAvLyAzXG4gKiAvLyAndGhhdCdzIGl0ISdcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIGNhdGNoRXJyb3J9XG4gKlxuICogQHBhcmFtIHsuLi5PYnNlcnZhYmxlSW5wdXR9IHNvdXJjZXMgT2JzZXJ2YWJsZXMgcGFzc2VkIGVpdGhlciBkaXJlY3RseSBvciBhcyBhbiBhcnJheS5cbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHZhbHVlcyBmcm9tIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgYnV0IC0gaWYgaXQgZXJyb3JzIC0gc3Vic2NyaWJlcyB0byB0aGUgbmV4dCBwYXNzZWQgT2JzZXJ2YWJsZVxuICogYW5kIHNvIG9uLCB1bnRpbCBpdCBjb21wbGV0ZXMgb3IgcnVucyBvdXQgb2YgT2JzZXJ2YWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dFdpdGg8VCwgQSBleHRlbmRzIHJlYWRvbmx5IHVua25vd25bXT4oXG4gIC4uLnNvdXJjZXM6IFtbLi4uT2JzZXJ2YWJsZUlucHV0VHVwbGU8QT5dXSB8IFsuLi5PYnNlcnZhYmxlSW5wdXRUdXBsZTxBPl1cbik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVCB8IEFbbnVtYmVyXT4ge1xuICAvLyBGb3Igc29tZSByZWFzb24sIFRTIDQuMSBSQyBnZXRzIHRoZSBpbmZlcmVuY2Ugd3JvbmcgaGVyZSBhbmQgaW5mZXJzIHRoZVxuICAvLyByZXN1bHQgdG8gYmUgYEFbbnVtYmVyXVtdYCAtIGNvbXBsZXRlbHkgZHJvcHBpbmcgdGhlIE9ic2VydmFibGVJbnB1dCBwYXJ0XG4gIC8vIG9mIHRoZSB0eXBlLiBUaGlzIG1ha2VzIG5vIHNlbnNlIHdoYXRzb2V2ZXIuIEFzIGEgd29ya2Fyb3VuZCwgdGhlIHR5cGUgaXNcbiAgLy8gYXNzZXJ0ZWQgZXhwbGljaXRseS5cbiAgY29uc3QgbmV4dFNvdXJjZXMgPSBhcmdzT3JBcmdBcnJheShzb3VyY2VzKSBhcyB1bmtub3duIGFzIE9ic2VydmFibGVJbnB1dFR1cGxlPEE+O1xuXG4gIHJldHVybiAoc291cmNlKSA9PiBvRVJOQ3JlYXRlKHNvdXJjZSwgLi4ubmV4dFNvdXJjZXMpO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFJlbmFtZWQuIFVzZSB7QGxpbmsgb25FcnJvclJlc3VtZU5leHRXaXRofSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gKi9cbmV4cG9ydCBjb25zdCBvbkVycm9yUmVzdW1lTmV4dCA9IG9uRXJyb3JSZXN1bWVOZXh0V2l0aDtcbiJdfQ==
