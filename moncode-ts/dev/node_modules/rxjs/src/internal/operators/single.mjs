import { EmptyError } from '../util/EmptyError.mjs';
import { SequenceError } from '../util/SequenceError.mjs';
import { NotFoundError } from '../util/NotFoundError.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
/**
 * Returns an observable that asserts that only one value is
 * emitted from the observable that matches the predicate. If no
 * predicate is provided, then it will assert that the observable
 * only emits one value.
 *
 * In the event that the observable is empty, it will throw an
 * {@link EmptyError}.
 *
 * In the event that two values are found that match the predicate,
 * or when there are two values emitted and no predicate, it will
 * throw a {@link SequenceError}
 *
 * In the event that no values match the predicate, if one is provided,
 * it will throw a {@link NotFoundError}
 *
 * ## Example
 *
 * Expect only `name` beginning with `'B'`
 *
 * ```ts
 * import { of, single } from 'rxjs';
 *
 * const source1 = of(
 *  { name: 'Ben' },
 *  { name: 'Tracy' },
 *  { name: 'Laney' },
 *  { name: 'Lily' }
 * );
 *
 * source1
 *   .pipe(single(x => x.name.startsWith('B')))
 *   .subscribe(x => console.log(x));
 * // Emits 'Ben'
 *
 *
 * const source2 = of(
 *  { name: 'Ben' },
 *  { name: 'Tracy' },
 *  { name: 'Bradley' },
 *  { name: 'Lincoln' }
 * );
 *
 * source2
 *   .pipe(single(x => x.name.startsWith('B')))
 *   .subscribe({ error: err => console.error(err) });
 * // Error emitted: SequenceError('Too many values match')
 *
 *
 * const source3 = of(
 *  { name: 'Laney' },
 *  { name: 'Tracy' },
 *  { name: 'Lily' },
 *  { name: 'Lincoln' }
 * );
 *
 * source3
 *   .pipe(single(x => x.name.startsWith('B')))
 *   .subscribe({ error: err => console.error(err) });
 * // Error emitted: NotFoundError('No values match')
 * ```
 *
 * @see {@link first}
 * @see {@link find}
 * @see {@link findIndex}
 * @see {@link elementAt}
 *
 * @throws {NotFoundError} Delivers an NotFoundError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @throws {SequenceError} Delivers a SequenceError if more than one value is emitted that matches the
 * provided predicate. If no predicate is provided, will deliver a SequenceError if more
 * than one value comes from the source
 * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
 * @return A function that returns an Observable that emits the single item
 * emitted by the source Observable that matches the predicate.
 */
export function single(predicate) {
    return operate((source, subscriber) => {
        let hasValue = false;
        let singleValue;
        let seenValue = false;
        let index = 0;
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            seenValue = true;
            if (!predicate || predicate(value, index++, source)) {
                hasValue && subscriber.error(new SequenceError('Too many matching values'));
                hasValue = true;
                singleValue = value;
            }
        }, () => {
            if (hasValue) {
                subscriber.next(singleValue);
                subscriber.complete();
            }
            else {
                subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());
            }
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc2luZ2xlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUdoRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFLaEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJFRztBQUNILE1BQU0sVUFBVSxNQUFNLENBQUksU0FBdUU7SUFDL0YsT0FBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDcEMsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksV0FBYyxDQUFDO1FBQ25CLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDZCxNQUFNLENBQUMsU0FBUyxDQUNkLHdCQUF3QixDQUN0QixVQUFVLEVBQ1YsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNSLFNBQVMsR0FBRyxJQUFJLENBQUM7WUFDakIsSUFBSSxDQUFDLFNBQVMsSUFBSSxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUM7Z0JBQ3BELFFBQVEsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksYUFBYSxDQUFDLDBCQUEwQixDQUFDLENBQUMsQ0FBQztnQkFDNUUsUUFBUSxHQUFHLElBQUksQ0FBQztnQkFDaEIsV0FBVyxHQUFHLEtBQUssQ0FBQztZQUN0QixDQUFDO1FBQ0gsQ0FBQyxFQUNELEdBQUcsRUFBRTtZQUNILElBQUksUUFBUSxFQUFFLENBQUM7Z0JBQ2IsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDN0IsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3hCLENBQUM7aUJBQU0sQ0FBQztnQkFDTixVQUFVLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxhQUFhLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1lBQzNGLENBQUM7UUFDSCxDQUFDLENBQ0YsQ0FDRixDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvc2luZ2xlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgRW1wdHlFcnJvciB9IGZyb20gJy4uL3V0aWwvRW1wdHlFcnJvcic7XG5cbmltcG9ydCB7IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiwgT3BlcmF0b3JGdW5jdGlvbiwgVHJ1dGh5VHlwZXNPZiB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFNlcXVlbmNlRXJyb3IgfSBmcm9tICcuLi91dGlsL1NlcXVlbmNlRXJyb3InO1xuaW1wb3J0IHsgTm90Rm91bmRFcnJvciB9IGZyb20gJy4uL3V0aWwvTm90Rm91bmRFcnJvcic7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmdsZTxUPihwcmVkaWNhdGU6IEJvb2xlYW5Db25zdHJ1Y3Rvcik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVHJ1dGh5VHlwZXNPZjxUPj47XG5leHBvcnQgZnVuY3Rpb24gc2luZ2xlPFQ+KHByZWRpY2F0ZT86ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGFzc2VydHMgdGhhdCBvbmx5IG9uZSB2YWx1ZSBpc1xuICogZW1pdHRlZCBmcm9tIHRoZSBvYnNlcnZhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLiBJZiBub1xuICogcHJlZGljYXRlIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYXNzZXJ0IHRoYXQgdGhlIG9ic2VydmFibGVcbiAqIG9ubHkgZW1pdHMgb25lIHZhbHVlLlxuICpcbiAqIEluIHRoZSBldmVudCB0aGF0IHRoZSBvYnNlcnZhYmxlIGlzIGVtcHR5LCBpdCB3aWxsIHRocm93IGFuXG4gKiB7QGxpbmsgRW1wdHlFcnJvcn0uXG4gKlxuICogSW4gdGhlIGV2ZW50IHRoYXQgdHdvIHZhbHVlcyBhcmUgZm91bmQgdGhhdCBtYXRjaCB0aGUgcHJlZGljYXRlLFxuICogb3Igd2hlbiB0aGVyZSBhcmUgdHdvIHZhbHVlcyBlbWl0dGVkIGFuZCBubyBwcmVkaWNhdGUsIGl0IHdpbGxcbiAqIHRocm93IGEge0BsaW5rIFNlcXVlbmNlRXJyb3J9XG4gKlxuICogSW4gdGhlIGV2ZW50IHRoYXQgbm8gdmFsdWVzIG1hdGNoIHRoZSBwcmVkaWNhdGUsIGlmIG9uZSBpcyBwcm92aWRlZCxcbiAqIGl0IHdpbGwgdGhyb3cgYSB7QGxpbmsgTm90Rm91bmRFcnJvcn1cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogRXhwZWN0IG9ubHkgYG5hbWVgIGJlZ2lubmluZyB3aXRoIGAnQidgXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mLCBzaW5nbGUgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBzb3VyY2UxID0gb2YoXG4gKiAgeyBuYW1lOiAnQmVuJyB9LFxuICogIHsgbmFtZTogJ1RyYWN5JyB9LFxuICogIHsgbmFtZTogJ0xhbmV5JyB9LFxuICogIHsgbmFtZTogJ0xpbHknIH1cbiAqICk7XG4gKlxuICogc291cmNlMVxuICogICAucGlwZShzaW5nbGUoeCA9PiB4Lm5hbWUuc3RhcnRzV2l0aCgnQicpKSlcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIC8vIEVtaXRzICdCZW4nXG4gKlxuICpcbiAqIGNvbnN0IHNvdXJjZTIgPSBvZihcbiAqICB7IG5hbWU6ICdCZW4nIH0sXG4gKiAgeyBuYW1lOiAnVHJhY3knIH0sXG4gKiAgeyBuYW1lOiAnQnJhZGxleScgfSxcbiAqICB7IG5hbWU6ICdMaW5jb2xuJyB9XG4gKiApO1xuICpcbiAqIHNvdXJjZTJcbiAqICAgLnBpcGUoc2luZ2xlKHggPT4geC5uYW1lLnN0YXJ0c1dpdGgoJ0InKSkpXG4gKiAgIC5zdWJzY3JpYmUoeyBlcnJvcjogZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSB9KTtcbiAqIC8vIEVycm9yIGVtaXR0ZWQ6IFNlcXVlbmNlRXJyb3IoJ1RvbyBtYW55IHZhbHVlcyBtYXRjaCcpXG4gKlxuICpcbiAqIGNvbnN0IHNvdXJjZTMgPSBvZihcbiAqICB7IG5hbWU6ICdMYW5leScgfSxcbiAqICB7IG5hbWU6ICdUcmFjeScgfSxcbiAqICB7IG5hbWU6ICdMaWx5JyB9LFxuICogIHsgbmFtZTogJ0xpbmNvbG4nIH1cbiAqICk7XG4gKlxuICogc291cmNlM1xuICogICAucGlwZShzaW5nbGUoeCA9PiB4Lm5hbWUuc3RhcnRzV2l0aCgnQicpKSlcbiAqICAgLnN1YnNjcmliZSh7IGVycm9yOiBlcnIgPT4gY29uc29sZS5lcnJvcihlcnIpIH0pO1xuICogLy8gRXJyb3IgZW1pdHRlZDogTm90Rm91bmRFcnJvcignTm8gdmFsdWVzIG1hdGNoJylcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZpcnN0fVxuICogQHNlZSB7QGxpbmsgZmluZH1cbiAqIEBzZWUge0BsaW5rIGZpbmRJbmRleH1cbiAqIEBzZWUge0BsaW5rIGVsZW1lbnRBdH1cbiAqXG4gKiBAdGhyb3dzIHtOb3RGb3VuZEVycm9yfSBEZWxpdmVycyBhbiBOb3RGb3VuZEVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmBcbiAqIGNhbGxiYWNrIGlmIHRoZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBiZWZvcmUgYW55IGBuZXh0YCBub3RpZmljYXRpb24gd2FzIHNlbnQuXG4gKiBAdGhyb3dzIHtTZXF1ZW5jZUVycm9yfSBEZWxpdmVycyBhIFNlcXVlbmNlRXJyb3IgaWYgbW9yZSB0aGFuIG9uZSB2YWx1ZSBpcyBlbWl0dGVkIHRoYXQgbWF0Y2hlcyB0aGVcbiAqIHByb3ZpZGVkIHByZWRpY2F0ZS4gSWYgbm8gcHJlZGljYXRlIGlzIHByb3ZpZGVkLCB3aWxsIGRlbGl2ZXIgYSBTZXF1ZW5jZUVycm9yIGlmIG1vcmVcbiAqIHRoYW4gb25lIHZhbHVlIGNvbWVzIGZyb20gdGhlIHNvdXJjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIC0gQSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZXZhbHVhdGUgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgc2luZ2xlIGl0ZW1cbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZ2xlPFQ+KHByZWRpY2F0ZT86ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIGxldCBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgIGxldCBzaW5nbGVWYWx1ZTogVDtcbiAgICBsZXQgc2VlblZhbHVlID0gZmFsc2U7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICBzZWVuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgrKywgc291cmNlKSkge1xuICAgICAgICAgICAgaGFzVmFsdWUgJiYgc3Vic2NyaWJlci5lcnJvcihuZXcgU2VxdWVuY2VFcnJvcignVG9vIG1hbnkgbWF0Y2hpbmcgdmFsdWVzJykpO1xuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgc2luZ2xlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChzaW5nbGVWYWx1ZSk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3Ioc2VlblZhbHVlID8gbmV3IE5vdEZvdW5kRXJyb3IoJ05vIG1hdGNoaW5nIHZhbHVlcycpIDogbmV3IEVtcHR5RXJyb3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSk7XG59XG4iXX0=
