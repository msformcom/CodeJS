import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * ![](throttle.svg)
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * ## Example
 *
 * Emit clicks at a rate of at most one click per second
 *
 * ```ts
 * import { fromEvent, throttle, interval } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(throttle(() => interval(1000)));
 *
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param durationSelector A function that receives a value from the source
 * Observable, for computing the silencing duration for each source value,
 * returned as an `ObservableInput`.
 * @param config A configuration object to define `leading` and `trailing`
 * behavior. Defaults to `{ leading: true, trailing: false }`.
 * @return A function that returns an Observable that performs the throttle
 * operation to limit the rate of emissions from the source.
 */
export function throttle(durationSelector, config) {
    return operate((source, subscriber) => {
        const { leading = true, trailing = false } = config !== null && config !== void 0 ? config : {};
        let hasValue = false;
        let sendValue = null;
        let throttled = null;
        let isComplete = false;
        const endThrottling = () => {
            throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
            throttled = null;
            if (trailing) {
                send();
                isComplete && subscriber.complete();
            }
        };
        const cleanupThrottling = () => {
            throttled = null;
            isComplete && subscriber.complete();
        };
        const startThrottle = (value) => (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));
        const send = () => {
            if (hasValue) {
                // Ensure we clear out our value and hasValue flag
                // before we emit, otherwise reentrant code can cause
                // issues here.
                hasValue = false;
                const value = sendValue;
                sendValue = null;
                // Emit the value.
                subscriber.next(value);
                !isComplete && startThrottle(value);
            }
        };
        source.subscribe(createOperatorSubscriber(subscriber, 
        // Regarding the presence of throttled.closed in the following
        // conditions, if a synchronous duration selector is specified - weird,
        // but legal - an already-closed subscription will be assigned to
        // throttled, so the subscription's closed property needs to be checked,
        // too.
        (value) => {
            hasValue = true;
            sendValue = value;
            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, () => {
            isComplete = true;
            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGhyb3R0bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFnQ3BEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2Q0c7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUFJLGdCQUFvRCxFQUFFLE1BQXVCO0lBQ3ZHLE9BQU8sT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxFQUFFO1FBQ3BDLE1BQU0sRUFBRSxPQUFPLEdBQUcsSUFBSSxFQUFFLFFBQVEsR0FBRyxLQUFLLEVBQUUsR0FBRyxNQUFNLGFBQU4sTUFBTSxjQUFOLE1BQU0sR0FBSSxFQUFFLENBQUM7UUFDMUQsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksU0FBUyxHQUFhLElBQUksQ0FBQztRQUMvQixJQUFJLFNBQVMsR0FBd0IsSUFBSSxDQUFDO1FBQzFDLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQztRQUV2QixNQUFNLGFBQWEsR0FBRyxHQUFHLEVBQUU7WUFDekIsU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFFLFdBQVcsRUFBRSxDQUFDO1lBQ3pCLFNBQVMsR0FBRyxJQUFJLENBQUM7WUFDakIsSUFBSSxRQUFRLEVBQUUsQ0FBQztnQkFDYixJQUFJLEVBQUUsQ0FBQztnQkFDUCxVQUFVLElBQUksVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3RDLENBQUM7UUFDSCxDQUFDLENBQUM7UUFFRixNQUFNLGlCQUFpQixHQUFHLEdBQUcsRUFBRTtZQUM3QixTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ2pCLFVBQVUsSUFBSSxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDdEMsQ0FBQyxDQUFDO1FBRUYsTUFBTSxhQUFhLEdBQUcsQ0FBQyxLQUFRLEVBQUUsRUFBRSxDQUNqQyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsd0JBQXdCLENBQUMsVUFBVSxFQUFFLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVySSxNQUFNLElBQUksR0FBRyxHQUFHLEVBQUU7WUFDaEIsSUFBSSxRQUFRLEVBQUUsQ0FBQztnQkFDYixrREFBa0Q7Z0JBQ2xELHFEQUFxRDtnQkFDckQsZUFBZTtnQkFDZixRQUFRLEdBQUcsS0FBSyxDQUFDO2dCQUNqQixNQUFNLEtBQUssR0FBRyxTQUFVLENBQUM7Z0JBQ3pCLFNBQVMsR0FBRyxJQUFJLENBQUM7Z0JBQ2pCLGtCQUFrQjtnQkFDbEIsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDdkIsQ0FBQyxVQUFVLElBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RDLENBQUM7UUFDSCxDQUFDLENBQUM7UUFFRixNQUFNLENBQUMsU0FBUyxDQUNkLHdCQUF3QixDQUN0QixVQUFVO1FBQ1YsOERBQThEO1FBQzlELHVFQUF1RTtRQUN2RSxpRUFBaUU7UUFDakUsd0VBQXdFO1FBQ3hFLE9BQU87UUFDUCxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ1IsUUFBUSxHQUFHLElBQUksQ0FBQztZQUNoQixTQUFTLEdBQUcsS0FBSyxDQUFDO1lBQ2xCLENBQUMsQ0FBQyxTQUFTLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNqRixDQUFDLEVBQ0QsR0FBRyxFQUFFO1lBQ0gsVUFBVSxHQUFHLElBQUksQ0FBQztZQUNsQixDQUFDLENBQUMsUUFBUSxJQUFJLFFBQVEsSUFBSSxTQUFTLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3JGLENBQUMsQ0FDRixDQUNGLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy90aHJvdHRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbmltcG9ydCB7IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiwgT2JzZXJ2YWJsZUlucHV0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBpbm5lckZyb20gfSBmcm9tICcuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSc7XG5cbi8qKlxuICogQW4gb2JqZWN0IGludGVyZmFjZSB1c2VkIGJ5IHtAbGluayB0aHJvdHRsZX0gb3Ige0BsaW5rIHRocm90dGxlVGltZX0gdGhhdCBlbnN1cmVcbiAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGVzZSBvcGVyYXRvcnMuXG4gKlxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGhyb3R0bGVDb25maWcge1xuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmVzdWx0aW5nIE9ic2VydmFibGUgd2lsbCBlbWl0IHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2VcbiAgICogT2JzZXJ2YWJsZSBhdCB0aGUgKipzdGFydCoqIG9mIHRoZSBcInRocm90dGxpbmdcIiBwcm9jZXNzICh3aGVuIHN0YXJ0aW5nIGFuXG4gICAqIGludGVybmFsIHRpbWVyIHRoYXQgcHJldmVudHMgb3RoZXIgZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZSB0byBwYXNzIHRocm91Z2gpLlxuICAgKiBJZiBgZmFsc2VgLCBpdCB3aWxsIG5vdCBlbWl0IHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhdCB0aGVcbiAgICogc3RhcnQgb2YgdGhlIFwidGhyb3R0bGluZ1wiIHByb2Nlc3MuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG86IGB0cnVlYC5cbiAgICovXG4gIGxlYWRpbmc/OiBib29sZWFuO1xuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmVzdWx0aW5nIE9ic2VydmFibGUgd2lsbCBlbWl0IHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlIHNvdXJjZVxuICAgKiBPYnNlcnZhYmxlIGF0IHRoZSAqKmVuZCoqIG9mIHRoZSBcInRocm90dGxpbmdcIiBwcm9jZXNzICh3aGVuIGVuZGluZyBhbiBpbnRlcm5hbFxuICAgKiB0aW1lciB0aGF0IHByZXZlbnRzIG90aGVyIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UgdG8gcGFzcyB0aHJvdWdoKS5cbiAgICogSWYgYGZhbHNlYCwgaXQgd2lsbCBub3QgZW1pdCB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhdCB0aGVcbiAgICogZW5kIG9mIHRoZSBcInRocm90dGxpbmdcIiBwcm9jZXNzLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvOiBgZmFsc2VgLlxuICAgKi9cbiAgdHJhaWxpbmc/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gaWdub3JlcyBzdWJzZXF1ZW50IHNvdXJjZVxuICogdmFsdWVzIGZvciBhIGR1cmF0aW9uIGRldGVybWluZWQgYnkgYW5vdGhlciBPYnNlcnZhYmxlLCB0aGVuIHJlcGVhdHMgdGhpc1xuICogcHJvY2Vzcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayB0aHJvdHRsZVRpbWV9LCBidXQgdGhlIHNpbGVuY2luZ1xuICogZHVyYXRpb24gaXMgZGV0ZXJtaW5lZCBieSBhIHNlY29uZCBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiAhW10odGhyb3R0bGUuc3ZnKVxuICpcbiAqIGB0aHJvdHRsZWAgZW1pdHMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHdoZW4gaXRzIGludGVybmFsIHRpbWVyIGlzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkLiBJbml0aWFsbHksIHRoZSB0aW1lciBpcyBkaXNhYmxlZC4gQXMgc29vbiBhcyB0aGUgZmlyc3Qgc291cmNlXG4gKiB2YWx1ZSBhcnJpdmVzLCBpdCBpcyBmb3J3YXJkZWQgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQgYnkgY2FsbGluZyB0aGUgYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIHdpdGggdGhlIHNvdXJjZSB2YWx1ZSxcbiAqIHdoaWNoIHJldHVybnMgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlLiBXaGVuIHRoZSBkdXJhdGlvbiBPYnNlcnZhYmxlIGVtaXRzIGFcbiAqIHZhbHVlLCB0aGUgdGltZXIgaXMgZGlzYWJsZWQsIGFuZCB0aGlzIHByb2Nlc3MgcmVwZWF0cyBmb3IgdGhlXG4gKiBuZXh0IHNvdXJjZSB2YWx1ZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogRW1pdCBjbGlja3MgYXQgYSByYXRlIG9mIGF0IG1vc3Qgb25lIGNsaWNrIHBlciBzZWNvbmRcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50LCB0aHJvdHRsZSwgaW50ZXJ2YWwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBjbGlja3MgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogY29uc3QgcmVzdWx0ID0gY2xpY2tzLnBpcGUodGhyb3R0bGUoKCkgPT4gaW50ZXJ2YWwoMTAwMCkpKTtcbiAqXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXR9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5V2hlbn1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHNpbGVuY2luZyBkdXJhdGlvbiBmb3IgZWFjaCBzb3VyY2UgdmFsdWUsXG4gKiByZXR1cm5lZCBhcyBhbiBgT2JzZXJ2YWJsZUlucHV0YC5cbiAqIEBwYXJhbSBjb25maWcgQSBjb25maWd1cmF0aW9uIG9iamVjdCB0byBkZWZpbmUgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgXG4gKiBiZWhhdmlvci4gRGVmYXVsdHMgdG8gYHsgbGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IGZhbHNlIH1gLlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgdGhlIHRocm90dGxlXG4gKiBvcGVyYXRpb24gdG8gbGltaXQgdGhlIHJhdGUgb2YgZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlPFQ+KGR1cmF0aW9uU2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gT2JzZXJ2YWJsZUlucHV0PGFueT4sIGNvbmZpZz86IFRocm90dGxlQ29uZmlnKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIGNvbnN0IHsgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gZmFsc2UgfSA9IGNvbmZpZyA/PyB7fTtcbiAgICBsZXQgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICBsZXQgc2VuZFZhbHVlOiBUIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHRocm90dGxlZDogU3Vic2NyaXB0aW9uIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGlzQ29tcGxldGUgPSBmYWxzZTtcblxuICAgIGNvbnN0IGVuZFRocm90dGxpbmcgPSAoKSA9PiB7XG4gICAgICB0aHJvdHRsZWQ/LnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aHJvdHRsZWQgPSBudWxsO1xuICAgICAgaWYgKHRyYWlsaW5nKSB7XG4gICAgICAgIHNlbmQoKTtcbiAgICAgICAgaXNDb21wbGV0ZSAmJiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNsZWFudXBUaHJvdHRsaW5nID0gKCkgPT4ge1xuICAgICAgdGhyb3R0bGVkID0gbnVsbDtcbiAgICAgIGlzQ29tcGxldGUgJiYgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBzdGFydFRocm90dGxlID0gKHZhbHVlOiBUKSA9PlxuICAgICAgKHRocm90dGxlZCA9IGlubmVyRnJvbShkdXJhdGlvblNlbGVjdG9yKHZhbHVlKSkuc3Vic2NyaWJlKGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBlbmRUaHJvdHRsaW5nLCBjbGVhbnVwVGhyb3R0bGluZykpKTtcblxuICAgIGNvbnN0IHNlbmQgPSAoKSA9PiB7XG4gICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgLy8gRW5zdXJlIHdlIGNsZWFyIG91dCBvdXIgdmFsdWUgYW5kIGhhc1ZhbHVlIGZsYWdcbiAgICAgICAgLy8gYmVmb3JlIHdlIGVtaXQsIG90aGVyd2lzZSByZWVudHJhbnQgY29kZSBjYW4gY2F1c2VcbiAgICAgICAgLy8gaXNzdWVzIGhlcmUuXG4gICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2VuZFZhbHVlITtcbiAgICAgICAgc2VuZFZhbHVlID0gbnVsbDtcbiAgICAgICAgLy8gRW1pdCB0aGUgdmFsdWUuXG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICFpc0NvbXBsZXRlICYmIHN0YXJ0VGhyb3R0bGUodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAvLyBSZWdhcmRpbmcgdGhlIHByZXNlbmNlIG9mIHRocm90dGxlZC5jbG9zZWQgaW4gdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBjb25kaXRpb25zLCBpZiBhIHN5bmNocm9ub3VzIGR1cmF0aW9uIHNlbGVjdG9yIGlzIHNwZWNpZmllZCAtIHdlaXJkLFxuICAgICAgICAvLyBidXQgbGVnYWwgLSBhbiBhbHJlYWR5LWNsb3NlZCBzdWJzY3JpcHRpb24gd2lsbCBiZSBhc3NpZ25lZCB0b1xuICAgICAgICAvLyB0aHJvdHRsZWQsIHNvIHRoZSBzdWJzY3JpcHRpb24ncyBjbG9zZWQgcHJvcGVydHkgbmVlZHMgdG8gYmUgY2hlY2tlZCxcbiAgICAgICAgLy8gdG9vLlxuICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgc2VuZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgISh0aHJvdHRsZWQgJiYgIXRocm90dGxlZC5jbG9zZWQpICYmIChsZWFkaW5nID8gc2VuZCgpIDogc3RhcnRUaHJvdHRsZSh2YWx1ZSkpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgISh0cmFpbGluZyAmJiBoYXNWYWx1ZSAmJiB0aHJvdHRsZWQgJiYgIXRocm90dGxlZC5jbG9zZWQpICYmIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH0pO1xufVxuIl19
