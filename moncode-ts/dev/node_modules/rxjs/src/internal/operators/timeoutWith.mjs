import { async } from '../scheduler/async.mjs';
import { isValidDate } from '../util/isDate.mjs';
import { timeout } from './timeout.mjs';
/**
 * When the passed timespan elapses before the source emits any given value, it will unsubscribe from the source,
 * and switch the subscription to another observable.
 *
 * <span class="informal">Used to switch to a different observable if your source is being slow.</span>
 *
 * Useful in cases where:
 *
 * - You want to switch to a different source that may be faster.
 * - You want to notify a user that the data stream is slow.
 * - You want to emit a custom error rather than the {@link TimeoutError} emitted
 *   by the default usage of {@link timeout}.
 *
 * If the first parameter is passed as Date and the time of the Date arrives before the first value arrives from the source,
 * it will unsubscribe from the source and switch the subscription to another observable.
 *
 * <span class="informal">Use Date object to switch to a different observable if the first value doesn't arrive by a specific time.</span>
 *
 * Can be used to set a timeout only for the first value, however it's recommended to use the {@link timeout} operator with
 * the `first` configuration to get the same effect.
 *
 * ## Examples
 *
 * Fallback to a faster observable
 *
 * ```ts
 * import { interval, timeoutWith } from 'rxjs';
 *
 * const slow$ = interval(1000);
 * const faster$ = interval(500);
 *
 * slow$
 *   .pipe(timeoutWith(900, faster$))
 *   .subscribe(console.log);
 * ```
 *
 * Emit your own custom timeout error
 *
 * ```ts
 * import { interval, timeoutWith, throwError } from 'rxjs';
 *
 * class CustomTimeoutError extends Error {
 *   constructor() {
 *     super('It was too slow');
 *     this.name = 'CustomTimeoutError';
 *   }
 * }
 *
 * const slow$ = interval(1000);
 *
 * slow$
 *   .pipe(timeoutWith(900, throwError(() => new CustomTimeoutError())))
 *   .subscribe({
 *     error: err => console.error(err.message)
 *   });
 * ```
 *
 * @see {@link timeout}
 *
 * @param due When passed a number, used as the time (in milliseconds) allowed between each value from the source before timeout
 * is triggered. When passed a Date, used as the exact time at which the timeout will be triggered if the first value does not arrive.
 * @param withObservable The observable to switch to when timeout occurs.
 * @param scheduler The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}
 * @return A function that returns an Observable that mirrors behaviour of the
 * source Observable, unless timeout happens when it starts emitting values
 * from the `ObservableInput` passed as a second parameter.
 * @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use {@link timeout} with the configuration
 * object: `timeout({ each: 100, with: () => a$, scheduler })`. Instead of `timeoutWith(someDate, a$, scheduler)`, use {@link timeout}
 * with the configuration object: `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8.
 */
export function timeoutWith(due, withObservable, scheduler) {
    let first;
    let each;
    let _with;
    scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async;
    if (isValidDate(due)) {
        first = due;
    }
    else if (typeof due === 'number') {
        each = due;
    }
    if (withObservable) {
        _with = () => withObservable;
    }
    else {
        throw new TypeError('No observable provided to switch to');
    }
    if (first == null && each == null) {
        // Ensure timeout was provided at runtime.
        throw new TypeError('No timeout provided.');
    }
    return timeout({
        first,
        each,
        scheduler,
        with: _with,
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZW91dFdpdGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3QyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBU3BDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxRUc7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUN6QixHQUFrQixFQUNsQixjQUFrQyxFQUNsQyxTQUF5QjtJQUV6QixJQUFJLEtBQWdDLENBQUM7SUFDckMsSUFBSSxJQUF3QixDQUFDO0lBQzdCLElBQUksS0FBK0IsQ0FBQztJQUNwQyxTQUFTLEdBQUcsU0FBUyxhQUFULFNBQVMsY0FBVCxTQUFTLEdBQUksS0FBSyxDQUFDO0lBRS9CLElBQUksV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDckIsS0FBSyxHQUFHLEdBQUcsQ0FBQztJQUNkLENBQUM7U0FBTSxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQ25DLElBQUksR0FBRyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQsSUFBSSxjQUFjLEVBQUUsQ0FBQztRQUNuQixLQUFLLEdBQUcsR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDO0lBQy9CLENBQUM7U0FBTSxDQUFDO1FBQ04sTUFBTSxJQUFJLFNBQVMsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRCxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksRUFBRSxDQUFDO1FBQ2xDLDBDQUEwQztRQUMxQyxNQUFNLElBQUksU0FBUyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELE9BQU8sT0FBTyxDQUF3QjtRQUNwQyxLQUFLO1FBQ0wsSUFBSTtRQUNKLFNBQVM7UUFDVCxJQUFJLEVBQUUsS0FBSztLQUNaLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29wZXJhdG9ycy90aW1lb3V0V2l0aC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzeW5jIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IGlzVmFsaWREYXRlIH0gZnJvbSAnLi4vdXRpbC9pc0RhdGUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZUlucHV0LCBPcGVyYXRvckZ1bmN0aW9uLCBTY2hlZHVsZXJMaWtlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgdGltZW91dCB9IGZyb20gJy4vdGltZW91dCc7XG5cbi8qKiBAZGVwcmVjYXRlZCBSZXBsYWNlZCB3aXRoIHtAbGluayB0aW1lb3V0fS4gSW5zdGVhZCBvZiBgdGltZW91dFdpdGgoc29tZURhdGUsIGEkLCBzY2hlZHVsZXIpYCwgdXNlIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICogYHRpbWVvdXQoeyBmaXJzdDogc29tZURhdGUsIHdpdGg6ICgpID0+IGEkLCBzY2hlZHVsZXIgfSlgLiBXaWxsIGJlIHJlbW92ZWQgaW4gdjguICovXG5leHBvcnQgZnVuY3Rpb24gdGltZW91dFdpdGg8VCwgUj4oZHVlQnk6IERhdGUsIHN3aXRjaFRvOiBPYnNlcnZhYmxlSW5wdXQ8Uj4sIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2UpOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBSPjtcbi8qKiBAZGVwcmVjYXRlZCBSZXBsYWNlZCB3aXRoIHtAbGluayB0aW1lb3V0fS4gSW5zdGVhZCBvZiBgdGltZW91dFdpdGgoMTAwLCBhJCwgc2NoZWR1bGVyKWAsIHVzZSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAqICBgdGltZW91dCh7IGVhY2g6IDEwMCwgd2l0aDogKCkgPT4gYSQsIHNjaGVkdWxlciB9KWAuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0V2l0aDxULCBSPih3YWl0Rm9yOiBudW1iZXIsIHN3aXRjaFRvOiBPYnNlcnZhYmxlSW5wdXQ8Uj4sIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2UpOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBSPjtcblxuLyoqXG4gKiBXaGVuIHRoZSBwYXNzZWQgdGltZXNwYW4gZWxhcHNlcyBiZWZvcmUgdGhlIHNvdXJjZSBlbWl0cyBhbnkgZ2l2ZW4gdmFsdWUsIGl0IHdpbGwgdW5zdWJzY3JpYmUgZnJvbSB0aGUgc291cmNlLFxuICogYW5kIHN3aXRjaCB0aGUgc3Vic2NyaXB0aW9uIHRvIGFub3RoZXIgb2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VXNlZCB0byBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgb2JzZXJ2YWJsZSBpZiB5b3VyIHNvdXJjZSBpcyBiZWluZyBzbG93Ljwvc3Bhbj5cbiAqXG4gKiBVc2VmdWwgaW4gY2FzZXMgd2hlcmU6XG4gKlxuICogLSBZb3Ugd2FudCB0byBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgc291cmNlIHRoYXQgbWF5IGJlIGZhc3Rlci5cbiAqIC0gWW91IHdhbnQgdG8gbm90aWZ5IGEgdXNlciB0aGF0IHRoZSBkYXRhIHN0cmVhbSBpcyBzbG93LlxuICogLSBZb3Ugd2FudCB0byBlbWl0IGEgY3VzdG9tIGVycm9yIHJhdGhlciB0aGFuIHRoZSB7QGxpbmsgVGltZW91dEVycm9yfSBlbWl0dGVkXG4gKiAgIGJ5IHRoZSBkZWZhdWx0IHVzYWdlIG9mIHtAbGluayB0aW1lb3V0fS5cbiAqXG4gKiBJZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIHBhc3NlZCBhcyBEYXRlIGFuZCB0aGUgdGltZSBvZiB0aGUgRGF0ZSBhcnJpdmVzIGJlZm9yZSB0aGUgZmlyc3QgdmFsdWUgYXJyaXZlcyBmcm9tIHRoZSBzb3VyY2UsXG4gKiBpdCB3aWxsIHVuc3Vic2NyaWJlIGZyb20gdGhlIHNvdXJjZSBhbmQgc3dpdGNoIHRoZSBzdWJzY3JpcHRpb24gdG8gYW5vdGhlciBvYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Vc2UgRGF0ZSBvYmplY3QgdG8gc3dpdGNoIHRvIGEgZGlmZmVyZW50IG9ic2VydmFibGUgaWYgdGhlIGZpcnN0IHZhbHVlIGRvZXNuJ3QgYXJyaXZlIGJ5IGEgc3BlY2lmaWMgdGltZS48L3NwYW4+XG4gKlxuICogQ2FuIGJlIHVzZWQgdG8gc2V0IGEgdGltZW91dCBvbmx5IGZvciB0aGUgZmlyc3QgdmFsdWUsIGhvd2V2ZXIgaXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIHtAbGluayB0aW1lb3V0fSBvcGVyYXRvciB3aXRoXG4gKiB0aGUgYGZpcnN0YCBjb25maWd1cmF0aW9uIHRvIGdldCB0aGUgc2FtZSBlZmZlY3QuXG4gKlxuICogIyMgRXhhbXBsZXNcbiAqXG4gKiBGYWxsYmFjayB0byBhIGZhc3RlciBvYnNlcnZhYmxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGludGVydmFsLCB0aW1lb3V0V2l0aCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IHNsb3ckID0gaW50ZXJ2YWwoMTAwMCk7XG4gKiBjb25zdCBmYXN0ZXIkID0gaW50ZXJ2YWwoNTAwKTtcbiAqXG4gKiBzbG93JFxuICogICAucGlwZSh0aW1lb3V0V2l0aCg5MDAsIGZhc3RlciQpKVxuICogICAuc3Vic2NyaWJlKGNvbnNvbGUubG9nKTtcbiAqIGBgYFxuICpcbiAqIEVtaXQgeW91ciBvd24gY3VzdG9tIHRpbWVvdXQgZXJyb3JcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaW50ZXJ2YWwsIHRpbWVvdXRXaXRoLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY2xhc3MgQ3VzdG9tVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzdXBlcignSXQgd2FzIHRvbyBzbG93Jyk7XG4gKiAgICAgdGhpcy5uYW1lID0gJ0N1c3RvbVRpbWVvdXRFcnJvcic7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBjb25zdCBzbG93JCA9IGludGVydmFsKDEwMDApO1xuICpcbiAqIHNsb3ckXG4gKiAgIC5waXBlKHRpbWVvdXRXaXRoKDkwMCwgdGhyb3dFcnJvcigoKSA9PiBuZXcgQ3VzdG9tVGltZW91dEVycm9yKCkpKSlcbiAqICAgLnN1YnNjcmliZSh7XG4gKiAgICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlKVxuICogICB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHRpbWVvdXR9XG4gKlxuICogQHBhcmFtIGR1ZSBXaGVuIHBhc3NlZCBhIG51bWJlciwgdXNlZCBhcyB0aGUgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBhbGxvd2VkIGJldHdlZW4gZWFjaCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgYmVmb3JlIHRpbWVvdXRcbiAqIGlzIHRyaWdnZXJlZC4gV2hlbiBwYXNzZWQgYSBEYXRlLCB1c2VkIGFzIHRoZSBleGFjdCB0aW1lIGF0IHdoaWNoIHRoZSB0aW1lb3V0IHdpbGwgYmUgdHJpZ2dlcmVkIGlmIHRoZSBmaXJzdCB2YWx1ZSBkb2VzIG5vdCBhcnJpdmUuXG4gKiBAcGFyYW0gd2l0aE9ic2VydmFibGUgVGhlIG9ic2VydmFibGUgdG8gc3dpdGNoIHRvIHdoZW4gdGltZW91dCBvY2N1cnMuXG4gKiBAcGFyYW0gc2NoZWR1bGVyIFRoZSBzY2hlZHVsZXIgdG8gdXNlIHdpdGggdGltZS1yZWxhdGVkIG9wZXJhdGlvbnMgd2l0aGluIHRoaXMgb3BlcmF0b3IuIERlZmF1bHRzIHRvIHtAbGluayBhc3luY1NjaGVkdWxlcn1cbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgYmVoYXZpb3VyIG9mIHRoZVxuICogc291cmNlIE9ic2VydmFibGUsIHVubGVzcyB0aW1lb3V0IGhhcHBlbnMgd2hlbiBpdCBzdGFydHMgZW1pdHRpbmcgdmFsdWVzXG4gKiBmcm9tIHRoZSBgT2JzZXJ2YWJsZUlucHV0YCBwYXNzZWQgYXMgYSBzZWNvbmQgcGFyYW1ldGVyLlxuICogQGRlcHJlY2F0ZWQgUmVwbGFjZWQgd2l0aCB7QGxpbmsgdGltZW91dH0uIEluc3RlYWQgb2YgYHRpbWVvdXRXaXRoKDEwMCwgYSQsIHNjaGVkdWxlcilgLCB1c2Uge0BsaW5rIHRpbWVvdXR9IHdpdGggdGhlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdDogYHRpbWVvdXQoeyBlYWNoOiAxMDAsIHdpdGg6ICgpID0+IGEkLCBzY2hlZHVsZXIgfSlgLiBJbnN0ZWFkIG9mIGB0aW1lb3V0V2l0aChzb21lRGF0ZSwgYSQsIHNjaGVkdWxlcilgLCB1c2Uge0BsaW5rIHRpbWVvdXR9XG4gKiB3aXRoIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdDogYHRpbWVvdXQoeyBmaXJzdDogc29tZURhdGUsIHdpdGg6ICgpID0+IGEkLCBzY2hlZHVsZXIgfSlgLiBXaWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0V2l0aDxULCBSPihcbiAgZHVlOiBudW1iZXIgfCBEYXRlLFxuICB3aXRoT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZUlucHV0PFI+LFxuICBzY2hlZHVsZXI/OiBTY2hlZHVsZXJMaWtlXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBSPiB7XG4gIGxldCBmaXJzdDogbnVtYmVyIHwgRGF0ZSB8IHVuZGVmaW5lZDtcbiAgbGV0IGVhY2g6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgbGV0IF93aXRoOiAoKSA9PiBPYnNlcnZhYmxlSW5wdXQ8Uj47XG4gIHNjaGVkdWxlciA9IHNjaGVkdWxlciA/PyBhc3luYztcblxuICBpZiAoaXNWYWxpZERhdGUoZHVlKSkge1xuICAgIGZpcnN0ID0gZHVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkdWUgPT09ICdudW1iZXInKSB7XG4gICAgZWFjaCA9IGR1ZTtcbiAgfVxuXG4gIGlmICh3aXRoT2JzZXJ2YWJsZSkge1xuICAgIF93aXRoID0gKCkgPT4gd2l0aE9ic2VydmFibGU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gb2JzZXJ2YWJsZSBwcm92aWRlZCB0byBzd2l0Y2ggdG8nKTtcbiAgfVxuXG4gIGlmIChmaXJzdCA9PSBudWxsICYmIGVhY2ggPT0gbnVsbCkge1xuICAgIC8vIEVuc3VyZSB0aW1lb3V0IHdhcyBwcm92aWRlZCBhdCBydW50aW1lLlxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIHRpbWVvdXQgcHJvdmlkZWQuJyk7XG4gIH1cblxuICByZXR1cm4gdGltZW91dDxULCBPYnNlcnZhYmxlSW5wdXQ8Uj4+KHtcbiAgICBmaXJzdCxcbiAgICBlYWNoLFxuICAgIHNjaGVkdWxlcixcbiAgICB3aXRoOiBfd2l0aCxcbiAgfSk7XG59XG4iXX0=
