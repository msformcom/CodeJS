import { Subscription } from '../Subscription.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { arrRemove } from '../util/arrRemove.mjs';
import { asyncScheduler } from '../scheduler/async.mjs';
import { popScheduler } from '../util/args.mjs';
import { executeSchedule } from '../util/executeSchedule.mjs';
/* tslint:enable:max-line-length */
/**
 * Buffers the source Observable values for a specific time period.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * those arrays periodically in time.</span>
 *
 * ![](bufferTime.png)
 *
 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
 * Unless the optional argument `bufferCreationInterval` is given, it emits and
 * resets the buffer every `bufferTimeSpan` milliseconds. If
 * `bufferCreationInterval` is given, this operator opens the buffer every
 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
 * `maxBufferSize` is specified, the buffer will be closed either after
 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
 *
 * ## Examples
 *
 * Every second, emit an array of the recent click events
 *
 * ```ts
 * import { fromEvent, bufferTime } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const buffered = clicks.pipe(bufferTime(1000));
 * buffered.subscribe(x => console.log(x));
 * ```
 *
 * Every 5 seconds, emit the click events from the next 2 seconds
 *
 * ```ts
 * import { fromEvent, bufferTime } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const buffered = clicks.pipe(bufferTime(2000, 5000));
 * buffered.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link windowTime}
 *
 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
 * @param {number} [bufferCreationInterval] The interval at which to start new
 * buffers.
 * @param {number} [maxBufferSize] The maximum buffer size.
 * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine buffer boundaries.
 * @return A function that returns an Observable of arrays of buffered values.
 */
export function bufferTime(bufferTimeSpan, ...otherArgs) {
    var _a, _b;
    const scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
    const bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
    const maxBufferSize = otherArgs[1] || Infinity;
    return operate((source, subscriber) => {
        // The active buffers, their related subscriptions, and removal functions.
        let bufferRecords = [];
        // If true, it means that every time we emit a buffer, we want to start a new buffer
        // this is only really used for when *just* the buffer time span is passed.
        let restartOnEmit = false;
        /**
         * Does the work of emitting the buffer from the record, ensuring that the
         * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)
         * does not alter the buffer. Also checks to see if a new buffer needs to be started
         * after the emit.
         */
        const emit = (record) => {
            const { buffer, subs } = record;
            subs.unsubscribe();
            arrRemove(bufferRecords, record);
            subscriber.next(buffer);
            restartOnEmit && startBuffer();
        };
        /**
         * Called every time we start a new buffer. This does
         * the work of scheduling a job at the requested bufferTimeSpan
         * that will emit the buffer (if it's not unsubscribed before then).
         */
        const startBuffer = () => {
            if (bufferRecords) {
                const subs = new Subscription();
                subscriber.add(subs);
                const buffer = [];
                const record = {
                    buffer,
                    subs,
                };
                bufferRecords.push(record);
                executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);
            }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
            // The user passed both a bufferTimeSpan (required), and a creation interval
            // That means we need to start new buffers on the interval, and those buffers need
            // to wait the required time span before emitting.
            executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        }
        else {
            restartOnEmit = true;
        }
        startBuffer();
        const bufferTimeSubscriber = createOperatorSubscriber(subscriber, (value) => {
            // Copy the records, so if we need to remove one we
            // don't mutate the array. It's hard, but not impossible to
            // set up a buffer time that could mutate the array and
            // cause issues here.
            const recordsCopy = bufferRecords.slice();
            for (const record of recordsCopy) {
                // Loop over all buffers and
                const { buffer } = record;
                buffer.push(value);
                // If the buffer is over the max size, we need to emit it.
                maxBufferSize <= buffer.length && emit(record);
            }
        }, () => {
            // The source completed, emit all of the active
            // buffers we have before we complete.
            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
                subscriber.next(bufferRecords.shift().buffer);
            }
            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
            subscriber.complete();
            subscriber.unsubscribe();
        }, 
        // Pass all errors through to consumer.
        undefined, 
        // Clean up
        () => (bufferRecords = null));
        source.subscribe(bufferTimeSubscriber);
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyVGltZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFL0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDOUMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDNUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBZTFELG1DQUFtQztBQUVuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9ERztBQUNILE1BQU0sVUFBVSxVQUFVLENBQUksY0FBc0IsRUFBRSxHQUFHLFNBQWdCOztJQUN2RSxNQUFNLFNBQVMsR0FBRyxNQUFBLFlBQVksQ0FBQyxTQUFTLENBQUMsbUNBQUksY0FBYyxDQUFDO0lBQzVELE1BQU0sc0JBQXNCLEdBQUcsTUFBQyxTQUFTLENBQUMsQ0FBQyxDQUFZLG1DQUFJLElBQUksQ0FBQztJQUNoRSxNQUFNLGFBQWEsR0FBSSxTQUFTLENBQUMsQ0FBQyxDQUFZLElBQUksUUFBUSxDQUFDO0lBRTNELE9BQU8sT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxFQUFFO1FBQ3BDLDBFQUEwRTtRQUMxRSxJQUFJLGFBQWEsR0FBaUQsRUFBRSxDQUFDO1FBQ3JFLG9GQUFvRjtRQUNwRiwyRUFBMkU7UUFDM0UsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBRTFCOzs7OztXQUtHO1FBQ0gsTUFBTSxJQUFJLEdBQUcsQ0FB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aW1lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE9wZXJhdG9yRnVuY3Rpb24sIFNjaGVkdWxlckxpa2UgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IGFyclJlbW92ZSB9IGZyb20gJy4uL3V0aWwvYXJyUmVtb3ZlJztcbmltcG9ydCB7IGFzeW5jU2NoZWR1bGVyIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IHBvcFNjaGVkdWxlciB9IGZyb20gJy4uL3V0aWwvYXJncyc7XG5pbXBvcnQgeyBleGVjdXRlU2NoZWR1bGUgfSBmcm9tICcuLi91dGlsL2V4ZWN1dGVTY2hlZHVsZSc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRpbWU8VD4oYnVmZmVyVGltZVNwYW46IG51bWJlciwgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZSk6IE9wZXJhdG9yRnVuY3Rpb248VCwgVFtdPjtcbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJUaW1lPFQ+KFxuICBidWZmZXJUaW1lU3BhbjogbnVtYmVyLFxuICBidWZmZXJDcmVhdGlvbkludGVydmFsOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBzY2hlZHVsZXI/OiBTY2hlZHVsZXJMaWtlXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFRbXT47XG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVGltZTxUPihcbiAgYnVmZmVyVGltZVNwYW46IG51bWJlcixcbiAgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgbWF4QnVmZmVyU2l6ZTogbnVtYmVyLFxuICBzY2hlZHVsZXI/OiBTY2hlZHVsZXJMaWtlXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFRbXT47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBmb3IgYSBzcGVjaWZpYyB0aW1lIHBlcmlvZC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXksIGFuZCBlbWl0c1xuICogdGhvc2UgYXJyYXlzIHBlcmlvZGljYWxseSBpbiB0aW1lLjwvc3Bhbj5cbiAqXG4gKiAhW10oYnVmZmVyVGltZS5wbmcpXG4gKlxuICogQnVmZmVycyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIGZvciBhIHNwZWNpZmljIHRpbWUgZHVyYXRpb24gYGJ1ZmZlclRpbWVTcGFuYC5cbiAqIFVubGVzcyB0aGUgb3B0aW9uYWwgYXJndW1lbnQgYGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWxgIGlzIGdpdmVuLCBpdCBlbWl0cyBhbmRcbiAqIHJlc2V0cyB0aGUgYnVmZmVyIGV2ZXJ5IGBidWZmZXJUaW1lU3BhbmAgbWlsbGlzZWNvbmRzLiBJZlxuICogYGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWxgIGlzIGdpdmVuLCB0aGlzIG9wZXJhdG9yIG9wZW5zIHRoZSBidWZmZXIgZXZlcnlcbiAqIGBidWZmZXJDcmVhdGlvbkludGVydmFsYCBtaWxsaXNlY29uZHMgYW5kIGNsb3NlcyAoZW1pdHMgYW5kIHJlc2V0cykgdGhlXG4gKiBidWZmZXIgZXZlcnkgYGJ1ZmZlclRpbWVTcGFuYCBtaWxsaXNlY29uZHMuIFdoZW4gdGhlIG9wdGlvbmFsIGFyZ3VtZW50XG4gKiBgbWF4QnVmZmVyU2l6ZWAgaXMgc3BlY2lmaWVkLCB0aGUgYnVmZmVyIHdpbGwgYmUgY2xvc2VkIGVpdGhlciBhZnRlclxuICogYGJ1ZmZlclRpbWVTcGFuYCBtaWxsaXNlY29uZHMgb3Igd2hlbiBpdCBjb250YWlucyBgbWF4QnVmZmVyU2l6ZWAgZWxlbWVudHMuXG4gKlxuICogIyMgRXhhbXBsZXNcbiAqXG4gKiBFdmVyeSBzZWNvbmQsIGVtaXQgYW4gYXJyYXkgb2YgdGhlIHJlY2VudCBjbGljayBldmVudHNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50LCBidWZmZXJUaW1lIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNvbnN0IGJ1ZmZlcmVkID0gY2xpY2tzLnBpcGUoYnVmZmVyVGltZSgxMDAwKSk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiBgYGBcbiAqXG4gKiBFdmVyeSA1IHNlY29uZHMsIGVtaXQgdGhlIGNsaWNrIGV2ZW50cyBmcm9tIHRoZSBuZXh0IDIgc2Vjb25kc1xuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIGJ1ZmZlclRpbWUgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBjbGlja3MgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogY29uc3QgYnVmZmVyZWQgPSBjbGlja3MucGlwZShidWZmZXJUaW1lKDIwMDAsIDUwMDApKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclRpbWVTcGFuIFRoZSBhbW91bnQgb2YgdGltZSB0byBmaWxsIGVhY2ggYnVmZmVyIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJDcmVhdGlvbkludGVydmFsXSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gc3RhcnQgbmV3XG4gKiBidWZmZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhCdWZmZXJTaXplXSBUaGUgbWF4aW11bSBidWZmZXIgc2l6ZS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyTGlrZX0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAqIGludGVydmFscyB0aGF0IGRldGVybWluZSBidWZmZXIgYm91bmRhcmllcy5cbiAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSBvZiBhcnJheXMgb2YgYnVmZmVyZWQgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVGltZTxUPihidWZmZXJUaW1lU3BhbjogbnVtYmVyLCAuLi5vdGhlckFyZ3M6IGFueVtdKTogT3BlcmF0b3JGdW5jdGlvbjxULCBUW10+IHtcbiAgY29uc3Qgc2NoZWR1bGVyID0gcG9wU2NoZWR1bGVyKG90aGVyQXJncykgPz8gYXN5bmNTY2hlZHVsZXI7XG4gIGNvbnN0IGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSAob3RoZXJBcmdzWzBdIGFzIG51bWJlcikgPz8gbnVsbDtcbiAgY29uc3QgbWF4QnVmZmVyU2l6ZSA9IChvdGhlckFyZ3NbMV0gYXMgbnVtYmVyKSB8fCBJbmZpbml0eTtcblxuICByZXR1cm4gb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgLy8gVGhlIGFjdGl2ZSBidWZmZXJzLCB0aGVpciByZWxhdGVkIHN1YnNjcmlwdGlvbnMsIGFuZCByZW1vdmFsIGZ1bmN0aW9ucy5cbiAgICBsZXQgYnVmZmVyUmVjb3JkczogeyBidWZmZXI6IFRbXTsgc3ViczogU3Vic2NyaXB0aW9uIH1bXSB8IG51bGwgPSBbXTtcbiAgICAvLyBJZiB0cnVlLCBpdCBtZWFucyB0aGF0IGV2ZXJ5IHRpbWUgd2UgZW1pdCBhIGJ1ZmZlciwgd2Ugd2FudCB0byBzdGFydCBhIG5ldyBidWZmZXJcbiAgICAvLyB0aGlzIGlzIG9ubHkgcmVhbGx5IHVzZWQgZm9yIHdoZW4gKmp1c3QqIHRoZSBidWZmZXIgdGltZSBzcGFuIGlzIHBhc3NlZC5cbiAgICBsZXQgcmVzdGFydE9uRW1pdCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgd29yayBvZiBlbWl0dGluZyB0aGUgYnVmZmVyIGZyb20gdGhlIHJlY29yZCwgZW5zdXJpbmcgdGhhdCB0aGVcbiAgICAgKiByZWNvcmQgaXMgcmVtb3ZlZCBiZWZvcmUgdGhlIGVtaXNzaW9uIHNvIHJlZW50cmFudCBjb2RlIChmcm9tIHNvbWUgY3VzdG9tIHNjaGVkdWxpbmcsIHBlcmhhcHMpXG4gICAgICogZG9lcyBub3QgYWx0ZXIgdGhlIGJ1ZmZlci4gQWxzbyBjaGVja3MgdG8gc2VlIGlmIGEgbmV3IGJ1ZmZlciBuZWVkcyB0byBiZSBzdGFydGVkXG4gICAgICogYWZ0ZXIgdGhlIGVtaXQuXG4gICAgICovXG4gICAgY29uc3QgZW1pdCA9IChyZWNvcmQ6IHsgYnVmZmVyOiBUW107IHN1YnM6IFN1YnNjcmlwdGlvbiB9KSA9PiB7XG4gICAgICBjb25zdCB7IGJ1ZmZlciwgc3VicyB9ID0gcmVjb3JkO1xuICAgICAgc3Vicy51bnN1YnNjcmliZSgpO1xuICAgICAgYXJyUmVtb3ZlKGJ1ZmZlclJlY29yZHMsIHJlY29yZCk7XG4gICAgICBzdWJzY3JpYmVyLm5leHQoYnVmZmVyKTtcbiAgICAgIHJlc3RhcnRPbkVtaXQgJiYgc3RhcnRCdWZmZXIoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGV2ZXJ5IHRpbWUgd2Ugc3RhcnQgYSBuZXcgYnVmZmVyLiBUaGlzIGRvZXNcbiAgICAgKiB0aGUgd29yayBvZiBzY2hlZHVsaW5nIGEgam9iIGF0IHRoZSByZXF1ZXN0ZWQgYnVmZmVyVGltZVNwYW5cbiAgICAgKiB0aGF0IHdpbGwgZW1pdCB0aGUgYnVmZmVyIChpZiBpdCdzIG5vdCB1bnN1YnNjcmliZWQgYmVmb3JlIHRoZW4pLlxuICAgICAqL1xuICAgIGNvbnN0IHN0YXJ0QnVmZmVyID0gKCkgPT4ge1xuICAgICAgaWYgKGJ1ZmZlclJlY29yZHMpIHtcbiAgICAgICAgY29uc3Qgc3VicyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgc3Vic2NyaWJlci5hZGQoc3Vicyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcjogVFtdID0gW107XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHtcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgc3VicyxcbiAgICAgICAgfTtcbiAgICAgICAgYnVmZmVyUmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgIGV4ZWN1dGVTY2hlZHVsZShzdWJzLCBzY2hlZHVsZXIsICgpID0+IGVtaXQocmVjb3JkKSwgYnVmZmVyVGltZVNwYW4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCAhPT0gbnVsbCAmJiBidWZmZXJDcmVhdGlvbkludGVydmFsID49IDApIHtcbiAgICAgIC8vIFRoZSB1c2VyIHBhc3NlZCBib3RoIGEgYnVmZmVyVGltZVNwYW4gKHJlcXVpcmVkKSwgYW5kIGEgY3JlYXRpb24gaW50ZXJ2YWxcbiAgICAgIC8vIFRoYXQgbWVhbnMgd2UgbmVlZCB0byBzdGFydCBuZXcgYnVmZmVycyBvbiB0aGUgaW50ZXJ2YWwsIGFuZCB0aG9zZSBidWZmZXJzIG5lZWRcbiAgICAgIC8vIHRvIHdhaXQgdGhlIHJlcXVpcmVkIHRpbWUgc3BhbiBiZWZvcmUgZW1pdHRpbmcuXG4gICAgICBleGVjdXRlU2NoZWR1bGUoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCBzdGFydEJ1ZmZlciwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RhcnRPbkVtaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIHN0YXJ0QnVmZmVyKCk7XG5cbiAgICBjb25zdCBidWZmZXJUaW1lU3Vic2NyaWJlciA9IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgIHN1YnNjcmliZXIsXG4gICAgICAodmFsdWU6IFQpID0+IHtcbiAgICAgICAgLy8gQ29weSB0aGUgcmVjb3Jkcywgc28gaWYgd2UgbmVlZCB0byByZW1vdmUgb25lIHdlXG4gICAgICAgIC8vIGRvbid0IG11dGF0ZSB0aGUgYXJyYXkuIEl0J3MgaGFyZCwgYnV0IG5vdCBpbXBvc3NpYmxlIHRvXG4gICAgICAgIC8vIHNldCB1cCBhIGJ1ZmZlciB0aW1lIHRoYXQgY291bGQgbXV0YXRlIHRoZSBhcnJheSBhbmRcbiAgICAgICAgLy8gY2F1c2UgaXNzdWVzIGhlcmUuXG4gICAgICAgIGNvbnN0IHJlY29yZHNDb3B5ID0gYnVmZmVyUmVjb3JkcyEuc2xpY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkc0NvcHkpIHtcbiAgICAgICAgICAvLyBMb29wIG92ZXIgYWxsIGJ1ZmZlcnMgYW5kXG4gICAgICAgICAgY29uc3QgeyBidWZmZXIgfSA9IHJlY29yZDtcbiAgICAgICAgICBidWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgLy8gSWYgdGhlIGJ1ZmZlciBpcyBvdmVyIHRoZSBtYXggc2l6ZSwgd2UgbmVlZCB0byBlbWl0IGl0LlxuICAgICAgICAgIG1heEJ1ZmZlclNpemUgPD0gYnVmZmVyLmxlbmd0aCAmJiBlbWl0KHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIFRoZSBzb3VyY2UgY29tcGxldGVkLCBlbWl0IGFsbCBvZiB0aGUgYWN0aXZlXG4gICAgICAgIC8vIGJ1ZmZlcnMgd2UgaGF2ZSBiZWZvcmUgd2UgY29tcGxldGUuXG4gICAgICAgIHdoaWxlIChidWZmZXJSZWNvcmRzPy5sZW5ndGgpIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYnVmZmVyUmVjb3Jkcy5zaGlmdCgpIS5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRpbWVTdWJzY3JpYmVyPy51bnN1YnNjcmliZSgpO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIHN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBQYXNzIGFsbCBlcnJvcnMgdGhyb3VnaCB0byBjb25zdW1lci5cbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIC8vIENsZWFuIHVwXG4gICAgICAoKSA9PiAoYnVmZmVyUmVjb3JkcyA9IG51bGwpXG4gICAgKTtcblxuICAgIHNvdXJjZS5zdWJzY3JpYmUoYnVmZmVyVGltZVN1YnNjcmliZXIpO1xuICB9KTtcbn1cbiJdfQ==
