import { operate } from '../util/lift.mjs';
import { noop } from '../util/noop.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
/**
 * Emits a notification from the source Observable only after a particular time span
 * determined by another Observable has passed without another source emission.
 *
 * <span class="informal">It's like {@link debounceTime}, but the time span of
 * emission silence is determined by a second Observable.</span>
 *
 * ![](debounce.svg)
 *
 * `debounce` delays notifications emitted by the source Observable, but drops previous
 * pending delayed emissions if a new notification arrives on the source Observable.
 * This operator keeps track of the most recent notification from the source
 * Observable, and spawns a duration Observable by calling the
 * `durationSelector` function. The notification is emitted only when the duration
 * Observable emits a next notification, and if no other notification was emitted on
 * the source Observable since the duration Observable was spawned. If a new
 * notification appears before the duration Observable emits, the previous notification will
 * not be emitted and a new duration is scheduled from `durationSelector` is scheduled.
 * If the completing event happens during the scheduled duration the last cached notification
 * is emitted before the completion event is forwarded to the output observable.
 * If the error event happens during the scheduled duration or after it only the error event is
 * forwarded to the output observable. The cache notification is not emitted in this case.
 *
 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
 * delay-like operator since output emissions do not necessarily occur at the
 * same time as they did on the source Observable.
 *
 * ## Example
 *
 * Emit the most recent click after a burst of clicks
 *
 * ```ts
 * import { fromEvent, scan, debounce, interval } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(
 *   scan(i => ++i, 1),
 *   debounce(i => interval(200 * i))
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link audit}
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sample}
 * @see {@link sampleTime}
 * @see {@link throttle}
 * @see {@link throttleTime}
 *
 * @param durationSelector A function
 * that receives a value from the source Observable, for computing the timeout
 * duration for each source value, returned as an Observable or a Promise.
 * @return A function that returns an Observable that delays the emissions of
 * the source Observable by the specified duration Observable returned by
 * `durationSelector`, and may drop some values if they occur too frequently.
 */
export function debounce(durationSelector) {
    return operate((source, subscriber) => {
        let hasValue = false;
        let lastValue = null;
        // The subscriber/subscription for the current debounce, if there is one.
        let durationSubscriber = null;
        const emit = () => {
            // Unsubscribe any current debounce subscription we have,
            // we only cared about the first notification from it, and we
            // want to clean that subscription up as soon as possible.
            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
            durationSubscriber = null;
            if (hasValue) {
                // We have a value! Free up memory first, then emit the value.
                hasValue = false;
                const value = lastValue;
                lastValue = null;
                subscriber.next(value);
            }
        };
        source.subscribe(createOperatorSubscriber(subscriber, (value) => {
            // Cancel any pending debounce duration. We don't
            // need to null it out here yet tho, because we're just going
            // to create another one in a few lines.
            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
            hasValue = true;
            lastValue = value;
            // Capture our duration subscriber, so we can unsubscribe it when we're notified
            // and we're going to emit the value.
            durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);
            // Subscribe to the duration.
            innerFrom(durationSelector(value)).subscribe(durationSubscriber);
        }, () => {
            // Source completed.
            // Emit any pending debounced values then complete
            emit();
            subscriber.complete();
        }, 
        // Pass all errors through to consumer
        undefined, () => {
            // Finalization.
            lastValue = durationSubscriber = null;
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVib3VuY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3BDLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUVwRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeURHO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FBSSxnQkFBb0Q7SUFDOUUsT0FBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUU7UUFDcEMsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksU0FBUyxHQUFhLElBQUksQ0FBQztRQUMvQix5RUFBeUU7UUFDekUsSUFBSSxrQkFBa0IsR0FBMkIsSUFBSSxDQUFDO1FBRXRELE1BQU0sSUFBSSxHQUFHLEdBQUcsRUFBRTtZQUNoQix5REFBeUQ7WUFDekQsNkRBQTZEO1lBQzdELDBEQUEwRDtZQUMxRCxrQkFBa0IsYUFBbEIsa0JBQWtCLHVCQUFsQixrQkFBa0IsQ0FBRSxXQUFXLEVBQUUsQ0FBQztZQUNsQyxrQkFBa0IsR0FBRyxJQUFJLENBQUM7WUFDMUIsSUFBSSxRQUFRLEVBQUUsQ0FBQztnQkFDYiw4REFBOEQ7Z0JBQzlELFFBQVEsR0FBRyxLQUFLLENBQUM7Z0JBQ2pCLE1BQU0sS0FBSyxHQUFHLFNBQVUsQ0FBQztnQkFDekIsU0FBUyxHQUFHLElBQUksQ0FBQztnQkFDakIsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN6QixDQUFDO1FBQ0gsQ0FBQyxDQUFDO1FBRUYsTUFBTSxDQUFDLFNBQVMsQ0FDZCx3QkFBd0IsQ0FDdEIsVUFBVSxFQUNWLENBQUMsS0FBUSxFQUFFLEVBQUU7WUFDWCxpREFBaUQ7WUFDakQsNkRBQTZEO1lBQzdELHdDQUF3QztZQUN4QyxrQkFBa0IsYUFBbEIsa0JBQWtCLHVCQUFsQixrQkFBa0IsQ0FBRSxXQUFXLEVBQUUsQ0FBQztZQUNsQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQ2hCLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDbEIsZ0ZBQWdGO1lBQ2hGLHFDQUFxQztZQUNyQyxrQkFBa0IsR0FBRyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3RFLDZCQUE2QjtZQUM3QixTQUFTLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUNuRSxDQUFDLEVBQ0QsR0FBRyxFQUFFO1lBQ0gsb0JBQW9CO1lBQ3BCLGtEQUFrRDtZQUNsRCxJQUFJLEVBQUUsQ0FBQztZQUNQLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN4QixDQUFDO1FBQ0Qsc0NBQXNDO1FBQ3RDLFNBQVMsRUFDVCxHQUFHLEVBQUU7WUFDSCxnQkFBZ0I7WUFDaEIsU0FBUyxHQUFHLGtCQUFrQixHQUFHLElBQUksQ0FBQztRQUN4QyxDQUFDLENBQ0YsQ0FDRixDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVib3VuY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24sIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWwvbm9vcCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBpbm5lckZyb20gfSBmcm9tICcuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSc7XG5cbi8qKlxuICogRW1pdHMgYSBub3RpZmljYXRpb24gZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb25seSBhZnRlciBhIHBhcnRpY3VsYXIgdGltZSBzcGFuXG4gKiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZSBoYXMgcGFzc2VkIHdpdGhvdXQgYW5vdGhlciBzb3VyY2UgZW1pc3Npb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVib3VuY2VUaW1lfSwgYnV0IHRoZSB0aW1lIHNwYW4gb2ZcbiAqIGVtaXNzaW9uIHNpbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBhIHNlY29uZCBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiAhW10oZGVib3VuY2Uuc3ZnKVxuICpcbiAqIGBkZWJvdW5jZWAgZGVsYXlzIG5vdGlmaWNhdGlvbnMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBkcm9wcyBwcmV2aW91c1xuICogcGVuZGluZyBkZWxheWVkIGVtaXNzaW9ucyBpZiBhIG5ldyBub3RpZmljYXRpb24gYXJyaXZlcyBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBUaGlzIG9wZXJhdG9yIGtlZXBzIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCBub3RpZmljYXRpb24gZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCBhbmQgc3Bhd25zIGEgZHVyYXRpb24gT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZVxuICogYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uLiBUaGUgbm90aWZpY2F0aW9uIGlzIGVtaXR0ZWQgb25seSB3aGVuIHRoZSBkdXJhdGlvblxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIG5leHQgbm90aWZpY2F0aW9uLCBhbmQgaWYgbm8gb3RoZXIgbm90aWZpY2F0aW9uIHdhcyBlbWl0dGVkIG9uXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUgc2luY2UgdGhlIGR1cmF0aW9uIE9ic2VydmFibGUgd2FzIHNwYXduZWQuIElmIGEgbmV3XG4gKiBub3RpZmljYXRpb24gYXBwZWFycyBiZWZvcmUgdGhlIGR1cmF0aW9uIE9ic2VydmFibGUgZW1pdHMsIHRoZSBwcmV2aW91cyBub3RpZmljYXRpb24gd2lsbFxuICogbm90IGJlIGVtaXR0ZWQgYW5kIGEgbmV3IGR1cmF0aW9uIGlzIHNjaGVkdWxlZCBmcm9tIGBkdXJhdGlvblNlbGVjdG9yYCBpcyBzY2hlZHVsZWQuXG4gKiBJZiB0aGUgY29tcGxldGluZyBldmVudCBoYXBwZW5zIGR1cmluZyB0aGUgc2NoZWR1bGVkIGR1cmF0aW9uIHRoZSBsYXN0IGNhY2hlZCBub3RpZmljYXRpb25cbiAqIGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBjb21wbGV0aW9uIGV2ZW50IGlzIGZvcndhcmRlZCB0byB0aGUgb3V0cHV0IG9ic2VydmFibGUuXG4gKiBJZiB0aGUgZXJyb3IgZXZlbnQgaGFwcGVucyBkdXJpbmcgdGhlIHNjaGVkdWxlZCBkdXJhdGlvbiBvciBhZnRlciBpdCBvbmx5IHRoZSBlcnJvciBldmVudCBpc1xuICogZm9yd2FyZGVkIHRvIHRoZSBvdXRwdXQgb2JzZXJ2YWJsZS4gVGhlIGNhY2hlIG5vdGlmaWNhdGlvbiBpcyBub3QgZW1pdHRlZCBpbiB0aGlzIGNhc2UuXG4gKlxuICogTGlrZSB7QGxpbmsgZGVib3VuY2VUaW1lfSwgdGhpcyBpcyBhIHJhdGUtbGltaXRpbmcgb3BlcmF0b3IsIGFuZCBhbHNvIGFcbiAqIGRlbGF5LWxpa2Ugb3BlcmF0b3Igc2luY2Ugb3V0cHV0IGVtaXNzaW9ucyBkbyBub3QgbmVjZXNzYXJpbHkgb2NjdXIgYXQgdGhlXG4gKiBzYW1lIHRpbWUgYXMgdGhleSBkaWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBFbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhZnRlciBhIGJ1cnN0IG9mIGNsaWNrc1xuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQsIHNjYW4sIGRlYm91bmNlLCBpbnRlcnZhbCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IGNsaWNrcyA9IGZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiBjb25zdCByZXN1bHQgPSBjbGlja3MucGlwZShcbiAqICAgc2NhbihpID0+ICsraSwgMSksXG4gKiAgIGRlYm91bmNlKGkgPT4gaW50ZXJ2YWwoMjAwICogaSkpXG4gKiApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGV9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIGR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvblxuICogdGhhdCByZWNlaXZlcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBmb3IgY29tcHV0aW5nIHRoZSB0aW1lb3V0XG4gKiBkdXJhdGlvbiBmb3IgZWFjaCBzb3VyY2UgdmFsdWUsIHJldHVybmVkIGFzIGFuIE9ic2VydmFibGUgb3IgYSBQcm9taXNlLlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2ZcbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIE9ic2VydmFibGUgcmV0dXJuZWQgYnlcbiAqIGBkdXJhdGlvblNlbGVjdG9yYCwgYW5kIG1heSBkcm9wIHNvbWUgdmFsdWVzIGlmIHRoZXkgb2NjdXIgdG9vIGZyZXF1ZW50bHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZTxUPihkdXJhdGlvblNlbGVjdG9yOiAodmFsdWU6IFQpID0+IE9ic2VydmFibGVJbnB1dDxhbnk+KTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+IHtcbiAgcmV0dXJuIG9wZXJhdGUoKHNvdXJjZSwgc3Vic2NyaWJlcikgPT4ge1xuICAgIGxldCBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgIGxldCBsYXN0VmFsdWU6IFQgfCBudWxsID0gbnVsbDtcbiAgICAvLyBUaGUgc3Vic2NyaWJlci9zdWJzY3JpcHRpb24gZm9yIHRoZSBjdXJyZW50IGRlYm91bmNlLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgbGV0IGR1cmF0aW9uU3Vic2NyaWJlcjogU3Vic2NyaWJlcjxhbnk+IHwgbnVsbCA9IG51bGw7XG5cbiAgICBjb25zdCBlbWl0ID0gKCkgPT4ge1xuICAgICAgLy8gVW5zdWJzY3JpYmUgYW55IGN1cnJlbnQgZGVib3VuY2Ugc3Vic2NyaXB0aW9uIHdlIGhhdmUsXG4gICAgICAvLyB3ZSBvbmx5IGNhcmVkIGFib3V0IHRoZSBmaXJzdCBub3RpZmljYXRpb24gZnJvbSBpdCwgYW5kIHdlXG4gICAgICAvLyB3YW50IHRvIGNsZWFuIHRoYXQgc3Vic2NyaXB0aW9uIHVwIGFzIHNvb24gYXMgcG9zc2libGUuXG4gICAgICBkdXJhdGlvblN1YnNjcmliZXI/LnVuc3Vic2NyaWJlKCk7XG4gICAgICBkdXJhdGlvblN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgaWYgKGhhc1ZhbHVlKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYSB2YWx1ZSEgRnJlZSB1cCBtZW1vcnkgZmlyc3QsIHRoZW4gZW1pdCB0aGUgdmFsdWUuXG4gICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGFzdFZhbHVlITtcbiAgICAgICAgbGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc291cmNlLnN1YnNjcmliZShcbiAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgKHZhbHVlOiBUKSA9PiB7XG4gICAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIGRlYm91bmNlIGR1cmF0aW9uLiBXZSBkb24ndFxuICAgICAgICAgIC8vIG5lZWQgdG8gbnVsbCBpdCBvdXQgaGVyZSB5ZXQgdGhvLCBiZWNhdXNlIHdlJ3JlIGp1c3QgZ29pbmdcbiAgICAgICAgICAvLyB0byBjcmVhdGUgYW5vdGhlciBvbmUgaW4gYSBmZXcgbGluZXMuXG4gICAgICAgICAgZHVyYXRpb25TdWJzY3JpYmVyPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAvLyBDYXB0dXJlIG91ciBkdXJhdGlvbiBzdWJzY3JpYmVyLCBzbyB3ZSBjYW4gdW5zdWJzY3JpYmUgaXQgd2hlbiB3ZSdyZSBub3RpZmllZFxuICAgICAgICAgIC8vIGFuZCB3ZSdyZSBnb2luZyB0byBlbWl0IHRoZSB2YWx1ZS5cbiAgICAgICAgICBkdXJhdGlvblN1YnNjcmliZXIgPSBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZW1pdCwgbm9vcCk7XG4gICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBkdXJhdGlvbi5cbiAgICAgICAgICBpbm5lckZyb20oZHVyYXRpb25TZWxlY3Rvcih2YWx1ZSkpLnN1YnNjcmliZShkdXJhdGlvblN1YnNjcmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gU291cmNlIGNvbXBsZXRlZC5cbiAgICAgICAgICAvLyBFbWl0IGFueSBwZW5kaW5nIGRlYm91bmNlZCB2YWx1ZXMgdGhlbiBjb21wbGV0ZVxuICAgICAgICAgIGVtaXQoKTtcbiAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBhc3MgYWxsIGVycm9ycyB0aHJvdWdoIHRvIGNvbnN1bWVyXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIEZpbmFsaXphdGlvbi5cbiAgICAgICAgICBsYXN0VmFsdWUgPSBkdXJhdGlvblN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSk7XG59XG4iXX0=
