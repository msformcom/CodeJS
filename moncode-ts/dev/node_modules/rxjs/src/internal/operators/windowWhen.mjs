import { Subject } from '../Subject.mjs';
import { operate } from '../util/lift.mjs';
import { createOperatorSubscriber } from './OperatorSubscriber.mjs';
import { innerFrom } from '../observable/innerFrom.mjs';
/**
 * Branch out the source Observable values as a nested Observable using a
 * factory function of closing Observables to determine when to start a new
 * window.
 *
 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
 * Observable instead of an array.</span>
 *
 * ![](windowWhen.png)
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping windows.
 * It emits the current window and opens a new one whenever the Observable
 * produced by the specified `closingSelector` function emits an item. The first
 * window is opened immediately when subscribing to the output Observable.
 *
 * ## Example
 *
 * Emit only the first two clicks events in every window of [1-5] random seconds
 *
 * ```ts
 * import { fromEvent, windowWhen, interval, map, take, mergeAll } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(
 *   windowWhen(() => interval(1000 + Math.random() * 4000)),
 *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window
 *   mergeAll()                     // flatten the Observable-of-Observables
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link bufferWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals (on either `next` or
 * `complete`) when to close the previous window and start a new one.
 * @return A function that returns an Observable of windows, which in turn are
 * Observables.
 */
export function windowWhen(closingSelector) {
    return operate((source, subscriber) => {
        let window;
        let closingSubscriber;
        /**
         * When we get an error, we have to notify both the
         * destination subscriber and the window.
         */
        const handleError = (err) => {
            window.error(err);
            subscriber.error(err);
        };
        /**
         * Called every time we need to open a window.
         * Recursive, as it will start the closing notifier, which
         * inevitably *should* call openWindow -- but may not if
         * it is a "never" observable.
         */
        const openWindow = () => {
            // We need to clean up our closing subscription,
            // we only cared about the first next or complete notification.
            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
            // Close our window before starting a new one.
            window === null || window === void 0 ? void 0 : window.complete();
            // Start the new window.
            window = new Subject();
            subscriber.next(window.asObservable());
            // Get our closing notifier.
            let closingNotifier;
            try {
                closingNotifier = innerFrom(closingSelector());
            }
            catch (err) {
                handleError(err);
                return;
            }
            // Subscribe to the closing notifier, be sure
            // to capture the subscriber (aka Subscription)
            // so we can clean it up when we close the window
            // and open a new one.
            closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));
        };
        // Start the first window.
        openWindow();
        // Subscribe to the source
        source.subscribe(createOperatorSubscriber(subscriber, (value) => window.next(value), () => {
            // The source completed, close the window and complete.
            window.complete();
            subscriber.complete();
        }, handleError, () => {
            // Be sure to clean up our closing subscription
            // when this tears down.
            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
            window = null;
        }));
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93V2hlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBRXJDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDaEUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRXBEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkNHO0FBQ0gsTUFBTSxVQUFVLFVBQVUsQ0FBSSxlQUEyQztJQUN2RSxPQUFPLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsRUFBRTtRQUNwQyxJQUFJLE1BQXlCLENBQUM7UUFDOUIsSUFBSSxpQkFBOEMsQ0FBQztRQUVuRDs7O1dBR0c7UUFDSCxNQUFNLFdBQVcsR0FBRyxDQUFDLEdBQVEsRUFBRSxFQUFFO1lBQy9CLE1BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbkIsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4QixDQUFDLENBQUM7UUFFRjs7Ozs7V0FLRztRQUNILE1BQU0sVUFBVSxHQUFHLEdBQUcsRUFBRTtZQUN0QixnREFBZ0Q7WUFDaEQsK0RBQStEO1lBQy9ELGlCQUFpQixhQUFqQixpQkFBaUIsdUJBQWpCLGlCQUFpQixDQUFFLFdBQVcsRUFBRSxDQUFDO1lBRWpDLDhDQUE4QztZQUM5QyxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsUUFBUSxFQUFFLENBQUM7WUFFbkIsd0JBQXdCO1lBQ3hCLE1BQU0sR0FBRyxJQUFJLE9BQU8sRUFBSyxDQUFDO1lBQzFCLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7WUFFdkMsNEJBQTRCO1lBQzVCLElBQUksZUFBZ0MsQ0FBQztZQUNyQyxJQUFJLENBQUM7Z0JBQ0gsZUFBZSxHQUFHLFNBQVMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO1lBQ2pELENBQUM7WUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO2dCQUNiLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDakIsT0FBTztZQUNULENBQUM7WUFFRCw2Q0FBNkM7WUFDN0MsK0NBQStDO1lBQy9DLGlEQUFpRDtZQUNqRCxzQkFBc0I7WUFDdEIsZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDLGlCQUFpQixHQUFHLHdCQUF3QixDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3SCxDQUFDLENBQUM7UUFFRiwwQkFBMEI7UUFDMUIsVUFBVSxFQUFFLENBQUM7UUFFYiwwQkFBMEI7UUFDMUIsTUFBTSxDQUFDLFNBQVMsQ0FDZCx3QkFBd0IsQ0FDdEIsVUFBVSxFQUNWLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxNQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUM5QixHQUFHLEVBQUU7WUFDSCx1REFBdUQ7WUFDdkQsTUFBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ25CLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN4QixDQUFDLEVBQ0QsV0FBVyxFQUNYLEdBQUcsRUFBRTtZQUNILCtDQUErQztZQUMvQyx3QkFBd0I7WUFDeEIsaUJBQWlCLGFBQWpCLGlCQUFpQix1QkFBakIsaUJBQWlCLENBQUUsV0FBVyxFQUFFLENBQUM7WUFDakMsTUFBTSxHQUFHLElBQUssQ0FBQztRQUNqQixDQUFDLENBQ0YsQ0FDRixDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93V2hlbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGVJbnB1dCwgT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuXG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHVzaW5nIGFcbiAqIGZhY3RvcnkgZnVuY3Rpb24gb2YgY2xvc2luZyBPYnNlcnZhYmxlcyB0byBkZXRlcm1pbmUgd2hlbiB0byBzdGFydCBhIG5ld1xuICogd2luZG93LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGJ1ZmZlcldoZW59LCBidXQgZW1pdHMgYSBuZXN0ZWRcbiAqIE9ic2VydmFibGUgaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogIVtdKHdpbmRvd1doZW4ucG5nKVxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgY29ubmVjdGVkLCBub24tb3ZlcmxhcHBpbmcgd2luZG93cy5cbiAqIEl0IGVtaXRzIHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgb3BlbnMgYSBuZXcgb25lIHdoZW5ldmVyIHRoZSBPYnNlcnZhYmxlXG4gKiBwcm9kdWNlZCBieSB0aGUgc3BlY2lmaWVkIGBjbG9zaW5nU2VsZWN0b3JgIGZ1bmN0aW9uIGVtaXRzIGFuIGl0ZW0uIFRoZSBmaXJzdFxuICogd2luZG93IGlzIG9wZW5lZCBpbW1lZGlhdGVseSB3aGVuIHN1YnNjcmliaW5nIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogRW1pdCBvbmx5IHRoZSBmaXJzdCB0d28gY2xpY2tzIGV2ZW50cyBpbiBldmVyeSB3aW5kb3cgb2YgWzEtNV0gcmFuZG9tIHNlY29uZHNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50LCB3aW5kb3dXaGVuLCBpbnRlcnZhbCwgbWFwLCB0YWtlLCBtZXJnZUFsbCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IGNsaWNrcyA9IGZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiBjb25zdCByZXN1bHQgPSBjbGlja3MucGlwZShcbiAqICAgd2luZG93V2hlbigoKSA9PiBpbnRlcnZhbCgxMDAwICsgTWF0aC5yYW5kb20oKSAqIDQwMDApKSxcbiAqICAgbWFwKHdpbiA9PiB3aW4ucGlwZSh0YWtlKDIpKSksIC8vIHRha2UgYXQgbW9zdCAyIGVtaXNzaW9ucyBmcm9tIGVhY2ggd2luZG93XG4gKiAgIG1lcmdlQWxsKCkgICAgICAgICAgICAgICAgICAgICAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOiBPYnNlcnZhYmxlfSBjbG9zaW5nU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vXG4gKiBhcmd1bWVudHMgYW5kIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNpZ25hbHMgKG9uIGVpdGhlciBgbmV4dGAgb3JcbiAqIGBjb21wbGV0ZWApIHdoZW4gdG8gY2xvc2UgdGhlIHByZXZpb3VzIHdpbmRvdyBhbmQgc3RhcnQgYSBuZXcgb25lLlxuICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm4gYXJlXG4gKiBPYnNlcnZhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpbmRvd1doZW48VD4oY2xvc2luZ1NlbGVjdG9yOiAoKSA9PiBPYnNlcnZhYmxlSW5wdXQ8YW55Pik6IE9wZXJhdG9yRnVuY3Rpb248VCwgT2JzZXJ2YWJsZTxUPj4ge1xuICByZXR1cm4gb3BlcmF0ZSgoc291cmNlLCBzdWJzY3JpYmVyKSA9PiB7XG4gICAgbGV0IHdpbmRvdzogU3ViamVjdDxUPiB8IG51bGw7XG4gICAgbGV0IGNsb3NpbmdTdWJzY3JpYmVyOiBTdWJzY3JpYmVyPGFueT4gfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGdldCBhbiBlcnJvciwgd2UgaGF2ZSB0byBub3RpZnkgYm90aCB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBzdWJzY3JpYmVyIGFuZCB0aGUgd2luZG93LlxuICAgICAqL1xuICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKGVycjogYW55KSA9PiB7XG4gICAgICB3aW5kb3chLmVycm9yKGVycik7XG4gICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSB0aW1lIHdlIG5lZWQgdG8gb3BlbiBhIHdpbmRvdy5cbiAgICAgKiBSZWN1cnNpdmUsIGFzIGl0IHdpbGwgc3RhcnQgdGhlIGNsb3Npbmcgbm90aWZpZXIsIHdoaWNoXG4gICAgICogaW5ldml0YWJseSAqc2hvdWxkKiBjYWxsIG9wZW5XaW5kb3cgLS0gYnV0IG1heSBub3QgaWZcbiAgICAgKiBpdCBpcyBhIFwibmV2ZXJcIiBvYnNlcnZhYmxlLlxuICAgICAqL1xuICAgIGNvbnN0IG9wZW5XaW5kb3cgPSAoKSA9PiB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNsZWFuIHVwIG91ciBjbG9zaW5nIHN1YnNjcmlwdGlvbixcbiAgICAgIC8vIHdlIG9ubHkgY2FyZWQgYWJvdXQgdGhlIGZpcnN0IG5leHQgb3IgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAgY2xvc2luZ1N1YnNjcmliZXI/LnVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIC8vIENsb3NlIG91ciB3aW5kb3cgYmVmb3JlIHN0YXJ0aW5nIGEgbmV3IG9uZS5cbiAgICAgIHdpbmRvdz8uY29tcGxldGUoKTtcblxuICAgICAgLy8gU3RhcnQgdGhlIG5ldyB3aW5kb3cuXG4gICAgICB3aW5kb3cgPSBuZXcgU3ViamVjdDxUPigpO1xuICAgICAgc3Vic2NyaWJlci5uZXh0KHdpbmRvdy5hc09ic2VydmFibGUoKSk7XG5cbiAgICAgIC8vIEdldCBvdXIgY2xvc2luZyBub3RpZmllci5cbiAgICAgIGxldCBjbG9zaW5nTm90aWZpZXI6IE9ic2VydmFibGU8YW55PjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsb3NpbmdOb3RpZmllciA9IGlubmVyRnJvbShjbG9zaW5nU2VsZWN0b3IoKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGNsb3Npbmcgbm90aWZpZXIsIGJlIHN1cmVcbiAgICAgIC8vIHRvIGNhcHR1cmUgdGhlIHN1YnNjcmliZXIgKGFrYSBTdWJzY3JpcHRpb24pXG4gICAgICAvLyBzbyB3ZSBjYW4gY2xlYW4gaXQgdXAgd2hlbiB3ZSBjbG9zZSB0aGUgd2luZG93XG4gICAgICAvLyBhbmQgb3BlbiBhIG5ldyBvbmUuXG4gICAgICBjbG9zaW5nTm90aWZpZXIuc3Vic2NyaWJlKChjbG9zaW5nU3Vic2NyaWJlciA9IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBvcGVuV2luZG93LCBvcGVuV2luZG93LCBoYW5kbGVFcnJvcikpKTtcbiAgICB9O1xuXG4gICAgLy8gU3RhcnQgdGhlIGZpcnN0IHdpbmRvdy5cbiAgICBvcGVuV2luZG93KCk7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHNvdXJjZVxuICAgIHNvdXJjZS5zdWJzY3JpYmUoXG4gICAgICBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoXG4gICAgICAgIHN1YnNjcmliZXIsXG4gICAgICAgICh2YWx1ZSkgPT4gd2luZG93IS5uZXh0KHZhbHVlKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIFRoZSBzb3VyY2UgY29tcGxldGVkLCBjbG9zZSB0aGUgd2luZG93IGFuZCBjb21wbGV0ZS5cbiAgICAgICAgICB3aW5kb3chLmNvbXBsZXRlKCk7XG4gICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVFcnJvcixcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIEJlIHN1cmUgdG8gY2xlYW4gdXAgb3VyIGNsb3Npbmcgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgLy8gd2hlbiB0aGlzIHRlYXJzIGRvd24uXG4gICAgICAgICAgY2xvc2luZ1N1YnNjcmliZXI/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgd2luZG93ID0gbnVsbCE7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9KTtcbn1cbiJdfQ==
