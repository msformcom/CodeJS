import { AsyncAction } from './AsyncAction.mjs';
export class QueueAction extends AsyncAction {
    constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    schedule(state, delay = 0) {
        if (delay > 0) {
            return super.schedule(state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    }
    execute(state, delay) {
        return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);
    }
    requestAsyncId(scheduler, id, delay = 0) {
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
            return super.requestAsyncId(scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        scheduler.flush(this);
        // HACK: In the past, this was returning `void`. However, `void` isn't a valid
        // `TimerHandle`, and generally the return value here isn't really used. So the
        // compromise is to return `0` which is both "falsy" and a valid `TimerHandle`,
        // as opposed to refactoring every other instanceo of `requestAsyncId`.
        return 0;
    }
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9zY2hlZHVsZXIvUXVldWVBY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQU01QyxNQUFNLE9BQU8sV0FBZSxTQUFRLFdBQWM7SUFDaEQsWUFBc0IsU0FBeUIsRUFBWSxJQUFtRDtRQUM1RyxLQUFLLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBREgsY0FBUyxHQUFULFNBQVMsQ0FBZ0I7UUFBWSxTQUFJLEdBQUosSUFBSSxDQUErQztJQUU5RyxDQUFDO0lBRU0sUUFBUSxDQUFDLEtBQVMsRUFBRSxRQUFnQixDQUFDO1FBQzFDLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ2QsT0FBTyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN0QyxDQUFDO1FBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0IsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sT0FBTyxDQUFDLEtBQVEsRUFBRSxLQUFhO1FBQ3BDLE9BQU8sS0FBSyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDOUYsQ0FBQztJQUVTLGNBQWMsQ0FBQyxTQUF5QixFQUFFLEVBQWdCLEVBQUUsUUFBZ0IsQ0FBQztRQUNyRixzRUFBc0U7UUFDdEUsc0VBQXNFO1FBQ3RFLDJDQUEyQztRQUUzQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUN0RSxPQUFPLEtBQUssQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNwRCxDQUFDO1FBRUQsMkRBQTJEO1FBQzNELFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdEIsOEVBQThFO1FBQzlFLCtFQUErRTtRQUMvRSwrRUFBK0U7UUFDL0UsdUVBQXVFO1FBQ3ZFLE9BQU8sQ0FBQyxDQUFDO0lBQ1gsQ0FBQztDQUNGIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9zY2hlZHVsZXIvUXVldWVBY3Rpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0FjdGlvbiB9IGZyb20gJy4vQXN5bmNBY3Rpb24nO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFF1ZXVlU2NoZWR1bGVyIH0gZnJvbSAnLi9RdWV1ZVNjaGVkdWxlcic7XG5pbXBvcnQgeyBTY2hlZHVsZXJBY3Rpb24gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBUaW1lckhhbmRsZSB9IGZyb20gJy4vdGltZXJIYW5kbGUnO1xuXG5leHBvcnQgY2xhc3MgUXVldWVBY3Rpb248VD4gZXh0ZW5kcyBBc3luY0FjdGlvbjxUPiB7XG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzY2hlZHVsZXI6IFF1ZXVlU2NoZWR1bGVyLCBwcm90ZWN0ZWQgd29yazogKHRoaXM6IFNjaGVkdWxlckFjdGlvbjxUPiwgc3RhdGU/OiBUKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoc2NoZWR1bGVyLCB3b3JrKTtcbiAgfVxuXG4gIHB1YmxpYyBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uIHtcbiAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICByZXR1cm4gc3VwZXIuc2NoZWR1bGUoc3RhdGUsIGRlbGF5KTtcbiAgICB9XG4gICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLnNjaGVkdWxlci5mbHVzaCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBleGVjdXRlKHN0YXRlOiBULCBkZWxheTogbnVtYmVyKTogYW55IHtcbiAgICByZXR1cm4gZGVsYXkgPiAwIHx8IHRoaXMuY2xvc2VkID8gc3VwZXIuZXhlY3V0ZShzdGF0ZSwgZGVsYXkpIDogdGhpcy5fZXhlY3V0ZShzdGF0ZSwgZGVsYXkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlcXVlc3RBc3luY0lkKHNjaGVkdWxlcjogUXVldWVTY2hlZHVsZXIsIGlkPzogVGltZXJIYW5kbGUsIGRlbGF5OiBudW1iZXIgPSAwKTogVGltZXJIYW5kbGUge1xuICAgIC8vIElmIGRlbGF5IGV4aXN0cyBhbmQgaXMgZ3JlYXRlciB0aGFuIDAsIG9yIGlmIHRoZSBkZWxheSBpcyBudWxsICh0aGVcbiAgICAvLyBhY3Rpb24gd2Fzbid0IHJlc2NoZWR1bGVkKSBidXQgd2FzIG9yaWdpbmFsbHkgc2NoZWR1bGVkIGFzIGFuIGFzeW5jXG4gICAgLy8gYWN0aW9uLCB0aGVuIHJlY3ljbGUgYXMgYW4gYXN5bmMgYWN0aW9uLlxuXG4gICAgaWYgKChkZWxheSAhPSBudWxsICYmIGRlbGF5ID4gMCkgfHwgKGRlbGF5ID09IG51bGwgJiYgdGhpcy5kZWxheSA+IDApKSB7XG4gICAgICByZXR1cm4gc3VwZXIucmVxdWVzdEFzeW5jSWQoc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBmbHVzaCB0aGUgc2NoZWR1bGVyIHN0YXJ0aW5nIHdpdGggdGhpcyBhY3Rpb24uXG4gICAgc2NoZWR1bGVyLmZsdXNoKHRoaXMpO1xuXG4gICAgLy8gSEFDSzogSW4gdGhlIHBhc3QsIHRoaXMgd2FzIHJldHVybmluZyBgdm9pZGAuIEhvd2V2ZXIsIGB2b2lkYCBpc24ndCBhIHZhbGlkXG4gICAgLy8gYFRpbWVySGFuZGxlYCwgYW5kIGdlbmVyYWxseSB0aGUgcmV0dXJuIHZhbHVlIGhlcmUgaXNuJ3QgcmVhbGx5IHVzZWQuIFNvIHRoZVxuICAgIC8vIGNvbXByb21pc2UgaXMgdG8gcmV0dXJuIGAwYCB3aGljaCBpcyBib3RoIFwiZmFsc3lcIiBhbmQgYSB2YWxpZCBgVGltZXJIYW5kbGVgLFxuICAgIC8vIGFzIG9wcG9zZWQgdG8gcmVmYWN0b3JpbmcgZXZlcnkgb3RoZXIgaW5zdGFuY2VvIG9mIGByZXF1ZXN0QXN5bmNJZGAuXG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cbiJdfQ==
