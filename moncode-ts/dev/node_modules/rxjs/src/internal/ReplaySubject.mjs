import { Subject } from './Subject.mjs';
import { dateTimestampProvider } from './scheduler/dateTimestampProvider.mjs';
/**
 * A variant of {@link Subject} that "replays" old values to new subscribers by emitting them when they first subscribe.
 *
 * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,
 * `ReplaySubject` "observes" values by having them passed to its `next` method. When it observes a value, it will store that
 * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.
 *
 * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in
 * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will
 * error if it has observed an error.
 *
 * There are two main configuration items to be concerned with:
 *
 * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.
 * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.
 *
 * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values
 * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.
 *
 * ### Differences with BehaviorSubject
 *
 * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:
 *
 * 1. `BehaviorSubject` comes "primed" with a single value upon construction.
 * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 * @see {@link shareReplay}
 */
export class ReplaySubject extends Subject {
    /**
     * @param bufferSize The size of the buffer to replay on subscription
     * @param windowTime The amount of time the buffered items will stay buffered
     * @param timestampProvider An object with a `now()` method that provides the current timestamp. This is used to
     * calculate the amount of time something has been buffered.
     */
    constructor(_bufferSize = Infinity, _windowTime = Infinity, _timestampProvider = dateTimestampProvider) {
        super();
        this._bufferSize = _bufferSize;
        this._windowTime = _windowTime;
        this._timestampProvider = _timestampProvider;
        this._buffer = [];
        this._infiniteTimeWindow = true;
        this._infiniteTimeWindow = _windowTime === Infinity;
        this._bufferSize = Math.max(1, _bufferSize);
        this._windowTime = Math.max(1, _windowTime);
    }
    next(value) {
        const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;
        if (!isStopped) {
            _buffer.push(value);
            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        super.next(value);
    }
    /** @internal */
    _subscribe(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        const subscription = this._innerSubscribe(subscriber);
        const { _infiniteTimeWindow, _buffer } = this;
        // We use a copy here, so reentrant code does not mutate our array while we're
        // emitting it to a new subscriber.
        const copy = _buffer.slice();
        for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
            subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
    }
    _trimBuffer() {
        const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;
        // If we don't have an infinite buffer size, and we're over the length,
        // use splice to truncate the old buffer values off. Note that we have to
        // double the size for instances where we're not using an infinite time window
        // because we're storing the values and the timestamps in the same array.
        const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        // Now, if we're not in an infinite time window, remove all values where the time is
        // older than what is allowed.
        if (!_infiniteTimeWindow) {
            const now = _timestampProvider.now();
            let last = 0;
            // Search the array for the first timestamp that isn't expired and
            // truncate the buffer up to that point.
            for (let i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
                last = i;
            }
            last && _buffer.splice(0, last + 1);
        }
    }
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9SZXBsYXlTdWJqZWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFJcEMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFFMUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJHO0FBQ0gsTUFBTSxPQUFPLGFBQWlCLFNBQVEsT0FBVTtJQUk5Qzs7Ozs7T0FLRztJQUNILFlBQ1UsY0FBYyxRQUFRLEVBQ3RCLGNBQWMsUUFBUSxFQUN0QixxQkFBd0MscUJBQXFCO1FBRXJFLEtBQUssRUFBRSxDQUFDO1FBSkEsZ0JBQVcsR0FBWCxXQUFXLENBQVc7UUFDdEIsZ0JBQVcsR0FBWCxXQUFXLENBQVc7UUFDdEIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUEyQztRQVovRCxZQUFPLEdBQW1CLEVBQUUsQ0FBQztRQUM3Qix3QkFBbUIsR0FBRyxJQUFJLENBQUM7UUFjakMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLFdBQVcsS0FBSyxRQUFRLENBQUM7UUFDcEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRCxJQUFJLENBQUMsS0FBUTtRQUNYLE1BQU0sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQztRQUMxRixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3BCLENBQUMsbUJBQW1CLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQztRQUMvRSxDQUFDO1FBQ0QsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ25CLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUVELGdCQUFnQjtJQUNOLFVBQVUsQ0FBQyxVQUF5QjtRQUM1QyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRW5CLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFdEQsTUFBTSxFQUFFLG1CQUFtQixFQUFFLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQztRQUM5Qyw4RUFBOEU7UUFDOUUsbUNBQW1DO1FBQ25DLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUM3QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ3hGLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBTSxDQUFDLENBQUM7UUFDaEMsQ0FBQztRQUVELElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUV6QyxPQUFPLFlBQVksQ0FBQztJQUN0QixDQUFDO0lBRU8sV0FBVztRQUNqQixNQUFNLEVBQUUsV0FBVyxFQUFFLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxHQUFHLElBQUksQ0FBQztRQUMvRSx1RUFBdUU7UUFDdkUseUVBQXlFO1FBQ3pFLDhFQUE4RTtRQUM5RSx5RUFBeUU7UUFDekUsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQztRQUN2RSxXQUFXLEdBQUcsUUFBUSxJQUFJLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxNQUFNLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQyxDQUFDO1FBRXhILG9GQUFvRjtRQUNwRiw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7WUFDekIsTUFBTSxHQUFHLEdBQUcsa0JBQWtCLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDckMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1lBQ2Isa0VBQWtFO1lBQ2xFLHdDQUF3QztZQUN4QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sSUFBSyxPQUFPLENBQUMsQ0FBQyxDQUFZLElBQUksR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDNUUsSUFBSSxHQUFHLENBQUMsQ0FBQztZQUNYLENBQUM7WUFDRCxJQUFJLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLENBQUM7SUFDSCxDQUFDO0NBQ0YiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL1JlcGxheVN1YmplY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAnLi9TdWJqZWN0JztcbmltcG9ydCB7IFRpbWVzdGFtcFByb3ZpZGVyIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGRhdGVUaW1lc3RhbXBQcm92aWRlciB9IGZyb20gJy4vc2NoZWR1bGVyL2RhdGVUaW1lc3RhbXBQcm92aWRlcic7XG5cbi8qKlxuICogQSB2YXJpYW50IG9mIHtAbGluayBTdWJqZWN0fSB0aGF0IFwicmVwbGF5c1wiIG9sZCB2YWx1ZXMgdG8gbmV3IHN1YnNjcmliZXJzIGJ5IGVtaXR0aW5nIHRoZW0gd2hlbiB0aGV5IGZpcnN0IHN1YnNjcmliZS5cbiAqXG4gKiBgUmVwbGF5U3ViamVjdGAgaGFzIGFuIGludGVybmFsIGJ1ZmZlciB0aGF0IHdpbGwgc3RvcmUgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHZhbHVlcyB0aGF0IGl0IGhhcyBvYnNlcnZlZC4gTGlrZSBgU3ViamVjdGAsXG4gKiBgUmVwbGF5U3ViamVjdGAgXCJvYnNlcnZlc1wiIHZhbHVlcyBieSBoYXZpbmcgdGhlbSBwYXNzZWQgdG8gaXRzIGBuZXh0YCBtZXRob2QuIFdoZW4gaXQgb2JzZXJ2ZXMgYSB2YWx1ZSwgaXQgd2lsbCBzdG9yZSB0aGF0XG4gKiB2YWx1ZSBmb3IgYSB0aW1lIGRldGVybWluZWQgYnkgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGBSZXBsYXlTdWJqZWN0YCwgYXMgcGFzc2VkIHRvIGl0cyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBXaGVuIGEgbmV3IHN1YnNjcmliZXIgc3Vic2NyaWJlcyB0byB0aGUgYFJlcGxheVN1YmplY3RgIGluc3RhbmNlLCBpdCB3aWxsIHN5bmNocm9ub3VzbHkgZW1pdCBhbGwgdmFsdWVzIGluIGl0cyBidWZmZXIgaW5cbiAqIGEgRmlyc3QtSW4tRmlyc3QtT3V0IChGSUZPKSBtYW5uZXIuIFRoZSBgUmVwbGF5U3ViamVjdGAgd2lsbCBhbHNvIGNvbXBsZXRlLCBpZiBpdCBoYXMgb2JzZXJ2ZWQgY29tcGxldGlvbjsgYW5kIGl0IHdpbGxcbiAqIGVycm9yIGlmIGl0IGhhcyBvYnNlcnZlZCBhbiBlcnJvci5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIG1haW4gY29uZmlndXJhdGlvbiBpdGVtcyB0byBiZSBjb25jZXJuZWQgd2l0aDpcbiAqXG4gKiAxLiBgYnVmZmVyU2l6ZWAgLSBUaGlzIHdpbGwgZGV0ZXJtaW5lIGhvdyBtYW55IGl0ZW1zIGFyZSBzdG9yZWQgaW4gdGhlIGJ1ZmZlciwgZGVmYXVsdHMgdG8gaW5maW5pdGUuXG4gKiAyLiBgd2luZG93VGltZWAgLSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gaG9sZCBhIHZhbHVlIGluIHRoZSBidWZmZXIgYmVmb3JlIHJlbW92aW5nIGl0IGZyb20gdGhlIGJ1ZmZlci5cbiAqXG4gKiBCb3RoIGNvbmZpZ3VyYXRpb25zIG1heSBleGlzdCBzaW11bHRhbmVvdXNseS4gU28gaWYgeW91IHdvdWxkIGxpa2UgdG8gYnVmZmVyIGEgbWF4aW11bSBvZiAzIHZhbHVlcywgYXMgbG9uZyBhcyB0aGUgdmFsdWVzXG4gKiBhcmUgbGVzcyB0aGFuIDIgc2Vjb25kcyBvbGQsIHlvdSBjb3VsZCBkbyBzbyB3aXRoIGEgYG5ldyBSZXBsYXlTdWJqZWN0KDMsIDIwMDApYC5cbiAqXG4gKiAjIyMgRGlmZmVyZW5jZXMgd2l0aCBCZWhhdmlvclN1YmplY3RcbiAqXG4gKiBgQmVoYXZpb3JTdWJqZWN0YCBpcyBzaW1pbGFyIHRvIGBuZXcgUmVwbGF5U3ViamVjdCgxKWAsIHdpdGggYSBjb3VwbGUgb2YgZXhjZXB0aW9uczpcbiAqXG4gKiAxLiBgQmVoYXZpb3JTdWJqZWN0YCBjb21lcyBcInByaW1lZFwiIHdpdGggYSBzaW5nbGUgdmFsdWUgdXBvbiBjb25zdHJ1Y3Rpb24uXG4gKiAyLiBgUmVwbGF5U3ViamVjdGAgd2lsbCByZXBsYXkgdmFsdWVzLCBldmVuIGFmdGVyIG9ic2VydmluZyBhbiBlcnJvciwgd2hlcmUgYEJlaGF2aW9yU3ViamVjdGAgd2lsbCBub3QuXG4gKlxuICogQHNlZSB7QGxpbmsgU3ViamVjdH1cbiAqIEBzZWUge0BsaW5rIEJlaGF2aW9yU3ViamVjdH1cbiAqIEBzZWUge0BsaW5rIHNoYXJlUmVwbGF5fVxuICovXG5leHBvcnQgY2xhc3MgUmVwbGF5U3ViamVjdDxUPiBleHRlbmRzIFN1YmplY3Q8VD4ge1xuICBwcml2YXRlIF9idWZmZXI6IChUIHwgbnVtYmVyKVtdID0gW107XG4gIHByaXZhdGUgX2luZmluaXRlVGltZVdpbmRvdyA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBidWZmZXJTaXplIFRoZSBzaXplIG9mIHRoZSBidWZmZXIgdG8gcmVwbGF5IG9uIHN1YnNjcmlwdGlvblxuICAgKiBAcGFyYW0gd2luZG93VGltZSBUaGUgYW1vdW50IG9mIHRpbWUgdGhlIGJ1ZmZlcmVkIGl0ZW1zIHdpbGwgc3RheSBidWZmZXJlZFxuICAgKiBAcGFyYW0gdGltZXN0YW1wUHJvdmlkZXIgQW4gb2JqZWN0IHdpdGggYSBgbm93KClgIG1ldGhvZCB0aGF0IHByb3ZpZGVzIHRoZSBjdXJyZW50IHRpbWVzdGFtcC4gVGhpcyBpcyB1c2VkIHRvXG4gICAqIGNhbGN1bGF0ZSB0aGUgYW1vdW50IG9mIHRpbWUgc29tZXRoaW5nIGhhcyBiZWVuIGJ1ZmZlcmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfYnVmZmVyU2l6ZSA9IEluZmluaXR5LFxuICAgIHByaXZhdGUgX3dpbmRvd1RpbWUgPSBJbmZpbml0eSxcbiAgICBwcml2YXRlIF90aW1lc3RhbXBQcm92aWRlcjogVGltZXN0YW1wUHJvdmlkZXIgPSBkYXRlVGltZXN0YW1wUHJvdmlkZXJcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9pbmZpbml0ZVRpbWVXaW5kb3cgPSBfd2luZG93VGltZSA9PT0gSW5maW5pdHk7XG4gICAgdGhpcy5fYnVmZmVyU2l6ZSA9IE1hdGgubWF4KDEsIF9idWZmZXJTaXplKTtcbiAgICB0aGlzLl93aW5kb3dUaW1lID0gTWF0aC5tYXgoMSwgX3dpbmRvd1RpbWUpO1xuICB9XG5cbiAgbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGNvbnN0IHsgaXNTdG9wcGVkLCBfYnVmZmVyLCBfaW5maW5pdGVUaW1lV2luZG93LCBfdGltZXN0YW1wUHJvdmlkZXIsIF93aW5kb3dUaW1lIH0gPSB0aGlzO1xuICAgIGlmICghaXNTdG9wcGVkKSB7XG4gICAgICBfYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgIV9pbmZpbml0ZVRpbWVXaW5kb3cgJiYgX2J1ZmZlci5wdXNoKF90aW1lc3RhbXBQcm92aWRlci5ub3coKSArIF93aW5kb3dUaW1lKTtcbiAgICB9XG4gICAgdGhpcy5fdHJpbUJ1ZmZlcigpO1xuICAgIHN1cGVyLm5leHQodmFsdWUpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+KTogU3Vic2NyaXB0aW9uIHtcbiAgICB0aGlzLl90aHJvd0lmQ2xvc2VkKCk7XG4gICAgdGhpcy5fdHJpbUJ1ZmZlcigpO1xuXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5faW5uZXJTdWJzY3JpYmUoc3Vic2NyaWJlcik7XG5cbiAgICBjb25zdCB7IF9pbmZpbml0ZVRpbWVXaW5kb3csIF9idWZmZXIgfSA9IHRoaXM7XG4gICAgLy8gV2UgdXNlIGEgY29weSBoZXJlLCBzbyByZWVudHJhbnQgY29kZSBkb2VzIG5vdCBtdXRhdGUgb3VyIGFycmF5IHdoaWxlIHdlJ3JlXG4gICAgLy8gZW1pdHRpbmcgaXQgdG8gYSBuZXcgc3Vic2NyaWJlci5cbiAgICBjb25zdCBjb3B5ID0gX2J1ZmZlci5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29weS5sZW5ndGggJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpICs9IF9pbmZpbml0ZVRpbWVXaW5kb3cgPyAxIDogMikge1xuICAgICAgc3Vic2NyaWJlci5uZXh0KGNvcHlbaV0gYXMgVCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyhzdWJzY3JpYmVyKTtcblxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cblxuICBwcml2YXRlIF90cmltQnVmZmVyKCkge1xuICAgIGNvbnN0IHsgX2J1ZmZlclNpemUsIF90aW1lc3RhbXBQcm92aWRlciwgX2J1ZmZlciwgX2luZmluaXRlVGltZVdpbmRvdyB9ID0gdGhpcztcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIGluZmluaXRlIGJ1ZmZlciBzaXplLCBhbmQgd2UncmUgb3ZlciB0aGUgbGVuZ3RoLFxuICAgIC8vIHVzZSBzcGxpY2UgdG8gdHJ1bmNhdGUgdGhlIG9sZCBidWZmZXIgdmFsdWVzIG9mZi4gTm90ZSB0aGF0IHdlIGhhdmUgdG9cbiAgICAvLyBkb3VibGUgdGhlIHNpemUgZm9yIGluc3RhbmNlcyB3aGVyZSB3ZSdyZSBub3QgdXNpbmcgYW4gaW5maW5pdGUgdGltZSB3aW5kb3dcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHN0b3JpbmcgdGhlIHZhbHVlcyBhbmQgdGhlIHRpbWVzdGFtcHMgaW4gdGhlIHNhbWUgYXJyYXkuXG4gICAgY29uc3QgYWRqdXN0ZWRCdWZmZXJTaXplID0gKF9pbmZpbml0ZVRpbWVXaW5kb3cgPyAxIDogMikgKiBfYnVmZmVyU2l6ZTtcbiAgICBfYnVmZmVyU2l6ZSA8IEluZmluaXR5ICYmIGFkanVzdGVkQnVmZmVyU2l6ZSA8IF9idWZmZXIubGVuZ3RoICYmIF9idWZmZXIuc3BsaWNlKDAsIF9idWZmZXIubGVuZ3RoIC0gYWRqdXN0ZWRCdWZmZXJTaXplKTtcblxuICAgIC8vIE5vdywgaWYgd2UncmUgbm90IGluIGFuIGluZmluaXRlIHRpbWUgd2luZG93LCByZW1vdmUgYWxsIHZhbHVlcyB3aGVyZSB0aGUgdGltZSBpc1xuICAgIC8vIG9sZGVyIHRoYW4gd2hhdCBpcyBhbGxvd2VkLlxuICAgIGlmICghX2luZmluaXRlVGltZVdpbmRvdykge1xuICAgICAgY29uc3Qgbm93ID0gX3RpbWVzdGFtcFByb3ZpZGVyLm5vdygpO1xuICAgICAgbGV0IGxhc3QgPSAwO1xuICAgICAgLy8gU2VhcmNoIHRoZSBhcnJheSBmb3IgdGhlIGZpcnN0IHRpbWVzdGFtcCB0aGF0IGlzbid0IGV4cGlyZWQgYW5kXG4gICAgICAvLyB0cnVuY2F0ZSB0aGUgYnVmZmVyIHVwIHRvIHRoYXQgcG9pbnQuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IF9idWZmZXIubGVuZ3RoICYmIChfYnVmZmVyW2ldIGFzIG51bWJlcikgPD0gbm93OyBpICs9IDIpIHtcbiAgICAgICAgbGFzdCA9IGk7XG4gICAgICB9XG4gICAgICBsYXN0ICYmIF9idWZmZXIuc3BsaWNlKDAsIGxhc3QgKyAxKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==
