import { EmptyError } from './util/EmptyError.mjs';
/**
 * Converts an observable to a promise by subscribing to the observable,
 * waiting for it to complete, and resolving the returned promise with the
 * last value from the observed stream.
 *
 * If the observable stream completes before any values were emitted, the
 * returned promise will reject with {@link EmptyError} or will resolve
 * with the default value if a default was specified.
 *
 * If the observable stream emits an error, the returned promise will reject
 * with that error.
 *
 * **WARNING**: Only use this with observables you *know* will complete. If the source
 * observable does not complete, you will end up with a promise that is hung up, and
 * potentially all of the state of an async function hanging out in memory. To avoid
 * this situation, look into adding something like {@link timeout}, {@link take},
 * {@link takeWhile}, or {@link takeUntil} amongst others.
 *
 * ## Example
 *
 * Wait for the last value from a stream and emit it from a promise in
 * an async function
 *
 * ```ts
 * import { interval, take, lastValueFrom } from 'rxjs';
 *
 * async function execute() {
 *   const source$ = interval(2000).pipe(take(10));
 *   const finalNumber = await lastValueFrom(source$);
 *   console.log(`The final number is ${ finalNumber }`);
 * }
 *
 * execute();
 *
 * // Expected output:
 * // 'The final number is 9'
 * ```
 *
 * @see {@link firstValueFrom}
 *
 * @param source the observable to convert to a promise
 * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value
 */
export function lastValueFrom(source, config) {
    const hasConfig = typeof config === 'object';
    return new Promise((resolve, reject) => {
        let _hasValue = false;
        let _value;
        source.subscribe({
            next: (value) => {
                _value = value;
                _hasValue = true;
            },
            error: reject,
            complete: () => {
                if (_hasValue) {
                    resolve(_value);
                }
                else if (hasConfig) {
                    resolve(config.defaultValue);
                }
                else {
                    reject(new EmptyError());
                }
            },
        });
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9sYXN0VmFsdWVGcm9tLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQVMvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMENHO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBTyxNQUFxQixFQUFFLE1BQStCO0lBQ3hGLE1BQU0sU0FBUyxHQUFHLE9BQU8sTUFBTSxLQUFLLFFBQVEsQ0FBQztJQUM3QyxPQUFPLElBQUksT0FBTyxDQUFRLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1FBQzVDLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLE1BQVMsQ0FBQztRQUNkLE1BQU0sQ0FBQyxTQUFTLENBQUM7WUFDZixJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDZCxNQUFNLEdBQUcsS0FBSyxDQUFDO2dCQUNmLFNBQVMsR0FBRyxJQUFJLENBQUM7WUFDbkIsQ0FBQztZQUNELEtBQUssRUFBRSxNQUFNO1lBQ2IsUUFBUSxFQUFFLEdBQUcsRUFBRTtnQkFDYixJQUFJLFNBQVMsRUFBRSxDQUFDO29CQUNkLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDbEIsQ0FBQztxQkFBTSxJQUFJLFNBQVMsRUFBRSxDQUFDO29CQUNyQixPQUFPLENBQUMsTUFBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUNoQyxDQUFDO3FCQUFNLENBQUM7b0JBQ04sTUFBTSxDQUFDLElBQUksVUFBVSxFQUFFLENBQUMsQ0FBQztnQkFDM0IsQ0FBQztZQUNILENBQUM7U0FDRixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL2xhc3RWYWx1ZUZyb20uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IEVtcHR5RXJyb3IgfSBmcm9tICcuL3V0aWwvRW1wdHlFcnJvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGFzdFZhbHVlRnJvbUNvbmZpZzxUPiB7XG4gIGRlZmF1bHRWYWx1ZTogVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhc3RWYWx1ZUZyb208VCwgRD4oc291cmNlOiBPYnNlcnZhYmxlPFQ+LCBjb25maWc6IExhc3RWYWx1ZUZyb21Db25maWc8RD4pOiBQcm9taXNlPFQgfCBEPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0VmFsdWVGcm9tPFQ+KHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IFByb21pc2U8VD47XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JzZXJ2YWJsZSB0byBhIHByb21pc2UgYnkgc3Vic2NyaWJpbmcgdG8gdGhlIG9ic2VydmFibGUsXG4gKiB3YWl0aW5nIGZvciBpdCB0byBjb21wbGV0ZSwgYW5kIHJlc29sdmluZyB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aXRoIHRoZVxuICogbGFzdCB2YWx1ZSBmcm9tIHRoZSBvYnNlcnZlZCBzdHJlYW0uXG4gKlxuICogSWYgdGhlIG9ic2VydmFibGUgc3RyZWFtIGNvbXBsZXRlcyBiZWZvcmUgYW55IHZhbHVlcyB3ZXJlIGVtaXR0ZWQsIHRoZVxuICogcmV0dXJuZWQgcHJvbWlzZSB3aWxsIHJlamVjdCB3aXRoIHtAbGluayBFbXB0eUVycm9yfSBvciB3aWxsIHJlc29sdmVcbiAqIHdpdGggdGhlIGRlZmF1bHQgdmFsdWUgaWYgYSBkZWZhdWx0IHdhcyBzcGVjaWZpZWQuXG4gKlxuICogSWYgdGhlIG9ic2VydmFibGUgc3RyZWFtIGVtaXRzIGFuIGVycm9yLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIHJlamVjdFxuICogd2l0aCB0aGF0IGVycm9yLlxuICpcbiAqICoqV0FSTklORyoqOiBPbmx5IHVzZSB0aGlzIHdpdGggb2JzZXJ2YWJsZXMgeW91ICprbm93KiB3aWxsIGNvbXBsZXRlLiBJZiB0aGUgc291cmNlXG4gKiBvYnNlcnZhYmxlIGRvZXMgbm90IGNvbXBsZXRlLCB5b3Ugd2lsbCBlbmQgdXAgd2l0aCBhIHByb21pc2UgdGhhdCBpcyBodW5nIHVwLCBhbmRcbiAqIHBvdGVudGlhbGx5IGFsbCBvZiB0aGUgc3RhdGUgb2YgYW4gYXN5bmMgZnVuY3Rpb24gaGFuZ2luZyBvdXQgaW4gbWVtb3J5LiBUbyBhdm9pZFxuICogdGhpcyBzaXR1YXRpb24sIGxvb2sgaW50byBhZGRpbmcgc29tZXRoaW5nIGxpa2Uge0BsaW5rIHRpbWVvdXR9LCB7QGxpbmsgdGFrZX0sXG4gKiB7QGxpbmsgdGFrZVdoaWxlfSwgb3Ige0BsaW5rIHRha2VVbnRpbH0gYW1vbmdzdCBvdGhlcnMuXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIFdhaXQgZm9yIHRoZSBsYXN0IHZhbHVlIGZyb20gYSBzdHJlYW0gYW5kIGVtaXQgaXQgZnJvbSBhIHByb21pc2UgaW5cbiAqIGFuIGFzeW5jIGZ1bmN0aW9uXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGludGVydmFsLCB0YWtlLCBsYXN0VmFsdWVGcm9tIH0gZnJvbSAncnhqcyc7XG4gKlxuICogYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAqICAgY29uc3Qgc291cmNlJCA9IGludGVydmFsKDIwMDApLnBpcGUodGFrZSgxMCkpO1xuICogICBjb25zdCBmaW5hbE51bWJlciA9IGF3YWl0IGxhc3RWYWx1ZUZyb20oc291cmNlJCk7XG4gKiAgIGNvbnNvbGUubG9nKGBUaGUgZmluYWwgbnVtYmVyIGlzICR7IGZpbmFsTnVtYmVyIH1gKTtcbiAqIH1cbiAqXG4gKiBleGVjdXRlKCk7XG4gKlxuICogLy8gRXhwZWN0ZWQgb3V0cHV0OlxuICogLy8gJ1RoZSBmaW5hbCBudW1iZXIgaXMgOSdcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZpcnN0VmFsdWVGcm9tfVxuICpcbiAqIEBwYXJhbSBzb3VyY2UgdGhlIG9ic2VydmFibGUgdG8gY29udmVydCB0byBhIHByb21pc2VcbiAqIEBwYXJhbSBjb25maWcgYSBjb25maWd1cmF0aW9uIG9iamVjdCB0byBkZWZpbmUgdGhlIGBkZWZhdWx0VmFsdWVgIHRvIHVzZSBpZiB0aGUgc291cmNlIGNvbXBsZXRlcyB3aXRob3V0IGVtaXR0aW5nIGEgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3RWYWx1ZUZyb208VCwgRD4oc291cmNlOiBPYnNlcnZhYmxlPFQ+LCBjb25maWc/OiBMYXN0VmFsdWVGcm9tQ29uZmlnPEQ+KTogUHJvbWlzZTxUIHwgRD4ge1xuICBjb25zdCBoYXNDb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JztcbiAgcmV0dXJuIG5ldyBQcm9taXNlPFQgfCBEPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IF9oYXNWYWx1ZSA9IGZhbHNlO1xuICAgIGxldCBfdmFsdWU6IFQ7XG4gICAgc291cmNlLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAodmFsdWUpID0+IHtcbiAgICAgICAgX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIF9oYXNWYWx1ZSA9IHRydWU7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGlmIChfaGFzVmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKF92YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ29uZmlnKSB7XG4gICAgICAgICAgcmVzb2x2ZShjb25maWchLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFbXB0eUVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcbn1cbiJdfQ==
