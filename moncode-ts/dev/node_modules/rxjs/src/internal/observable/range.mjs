import { Observable } from '../Observable.mjs';
import { EMPTY } from './empty.mjs';
/**
 * Creates an Observable that emits a sequence of numbers within a specified
 * range.
 *
 * <span class="informal">Emits a sequence of numbers in a range.</span>
 *
 * ![](range.png)
 *
 * `range` operator emits a range of sequential integers, in order, where you
 * select the `start` of the range and its `length`. By default, uses no
 * {@link SchedulerLike} and just delivers the notifications synchronously, but may use
 * an optional {@link SchedulerLike} to regulate those deliveries.
 *
 * ## Example
 *
 * Produce a range of numbers
 *
 * ```ts
 * import { range } from 'rxjs';
 *
 * const numbers = range(1, 3);
 *
 * numbers.subscribe({
 *   next: value => console.log(value),
 *   complete: () => console.log('Complete!')
 * });
 *
 * // Logs:
 * // 1
 * // 2
 * // 3
 * // 'Complete!'
 * ```
 *
 * @see {@link timer}
 * @see {@link interval}
 *
 * @param {number} [start=0] The value of the first integer in the sequence.
 * @param {number} count The number of sequential integers to generate.
 * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling
 * the emissions of the notifications.
 * @return {Observable} An Observable of numbers that emits a finite range of
 * sequential integers.
 */
export function range(start, count, scheduler) {
    if (count == null) {
        // If one argument was passed, it's the count, not the start.
        count = start;
        start = 0;
    }
    if (count <= 0) {
        // No count? We're going nowhere. Return EMPTY.
        return EMPTY;
    }
    // Where the range should stop.
    const end = count + start;
    return new Observable(scheduler
        ? // The deprecated scheduled path.
            (subscriber) => {
                let n = start;
                return scheduler.schedule(function () {
                    if (n < end) {
                        subscriber.next(n++);
                        this.schedule();
                    }
                    else {
                        subscriber.complete();
                    }
                });
            }
        : // Standard synchronous range.
            (subscriber) => {
                let n = start;
                while (n < end && !subscriber.closed) {
                    subscriber.next(n++);
                }
                subscriber.complete();
            });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL3JhbmdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLFNBQVMsQ0FBQztBQVNoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJDRztBQUNILE1BQU0sVUFBVSxLQUFLLENBQUMsS0FBYSxFQUFFLEtBQWMsRUFBRSxTQUF5QjtJQUM1RSxJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUNsQiw2REFBNkQ7UUFDN0QsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNkLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDWixDQUFDO0lBRUQsSUFBSSxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDZiwrQ0FBK0M7UUFDL0MsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsK0JBQStCO0lBQy9CLE1BQU0sR0FBRyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUM7SUFFMUIsT0FBTyxJQUFJLFVBQVUsQ0FDbkIsU0FBUztRQUNQLENBQUMsQ0FBQyxpQ0FBaUM7WUFDakMsQ0FBQyxVQUFVLEVBQUUsRUFBRTtnQkFDYixJQUFJLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQ2QsT0FBTyxTQUFTLENBQUMsUUFBUSxDQUFDO29CQUN4QixJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQzt3QkFDWixVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7d0JBQ3JCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDbEIsQ0FBQzt5QkFBTSxDQUFDO3dCQUNOLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDeEIsQ0FBQztnQkFDSCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUM7UUFDSCxDQUFDLENBQUMsOEJBQThCO1lBQzlCLENBQUMsVUFBVSxFQUFFLEVBQUU7Z0JBQ2IsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO2dCQUNkLE9BQU8sQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztvQkFDckMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUN2QixDQUFDO2dCQUNELFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN4QixDQUFDLENBQ04sQ0FBQztBQUNKLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29ic2VydmFibGUvcmFuZ2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY2hlZHVsZXJMaWtlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgRU1QVFkgfSBmcm9tICcuL2VtcHR5JztcblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKHN0YXJ0OiBudW1iZXIsIGNvdW50PzogbnVtYmVyKTogT2JzZXJ2YWJsZTxudW1iZXI+O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFRoZSBgc2NoZWR1bGVyYCBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIHY4LiBVc2UgYHJhbmdlKHN0YXJ0LCBjb3VudCkucGlwZShvYnNlcnZlT24oc2NoZWR1bGVyKSlgIGluc3RlYWQuIERldGFpbHM6IERldGFpbHM6IGh0dHBzOi8vcnhqcy5kZXYvZGVwcmVjYXRpb25zL3NjaGVkdWxlci1hcmd1bWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQ6IG51bWJlciwgY291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCwgc2NoZWR1bGVyOiBTY2hlZHVsZXJMaWtlKTogT2JzZXJ2YWJsZTxudW1iZXI+O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgc2VxdWVuY2Ugb2YgbnVtYmVycyB3aXRoaW4gYSBzcGVjaWZpZWRcbiAqIHJhbmdlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FbWl0cyBhIHNlcXVlbmNlIG9mIG51bWJlcnMgaW4gYSByYW5nZS48L3NwYW4+XG4gKlxuICogIVtdKHJhbmdlLnBuZylcbiAqXG4gKiBgcmFuZ2VgIG9wZXJhdG9yIGVtaXRzIGEgcmFuZ2Ugb2Ygc2VxdWVudGlhbCBpbnRlZ2VycywgaW4gb3JkZXIsIHdoZXJlIHlvdVxuICogc2VsZWN0IHRoZSBgc3RhcnRgIG9mIHRoZSByYW5nZSBhbmQgaXRzIGBsZW5ndGhgLiBCeSBkZWZhdWx0LCB1c2VzIG5vXG4gKiB7QGxpbmsgU2NoZWR1bGVyTGlrZX0gYW5kIGp1c3QgZGVsaXZlcnMgdGhlIG5vdGlmaWNhdGlvbnMgc3luY2hyb25vdXNseSwgYnV0IG1heSB1c2VcbiAqIGFuIG9wdGlvbmFsIHtAbGluayBTY2hlZHVsZXJMaWtlfSB0byByZWd1bGF0ZSB0aG9zZSBkZWxpdmVyaWVzLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBQcm9kdWNlIGEgcmFuZ2Ugb2YgbnVtYmVyc1xuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyByYW5nZSB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IG51bWJlcnMgPSByYW5nZSgxLCAzKTtcbiAqXG4gKiBudW1iZXJzLnN1YnNjcmliZSh7XG4gKiAgIG5leHQ6IHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSxcbiAqICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKCdDb21wbGV0ZSEnKVxuICogfSk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIDFcbiAqIC8vIDJcbiAqIC8vIDNcbiAqIC8vICdDb21wbGV0ZSEnXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayB0aW1lcn1cbiAqIEBzZWUge0BsaW5rIGludGVydmFsfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnRlZ2VyIGluIHRoZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIHNlcXVlbnRpYWwgaW50ZWdlcnMgdG8gZ2VuZXJhdGUuXG4gKiBAcGFyYW0ge1NjaGVkdWxlckxpa2V9IFtzY2hlZHVsZXJdIEEge0BsaW5rIFNjaGVkdWxlckxpa2V9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICogdGhlIGVtaXNzaW9ucyBvZiB0aGUgbm90aWZpY2F0aW9ucy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgbnVtYmVycyB0aGF0IGVtaXRzIGEgZmluaXRlIHJhbmdlIG9mXG4gKiBzZXF1ZW50aWFsIGludGVnZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQ6IG51bWJlciwgY291bnQ/OiBudW1iZXIsIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2UpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICBpZiAoY291bnQgPT0gbnVsbCkge1xuICAgIC8vIElmIG9uZSBhcmd1bWVudCB3YXMgcGFzc2VkLCBpdCdzIHRoZSBjb3VudCwgbm90IHRoZSBzdGFydC5cbiAgICBjb3VudCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChjb3VudCA8PSAwKSB7XG4gICAgLy8gTm8gY291bnQ/IFdlJ3JlIGdvaW5nIG5vd2hlcmUuIFJldHVybiBFTVBUWS5cbiAgICByZXR1cm4gRU1QVFk7XG4gIH1cblxuICAvLyBXaGVyZSB0aGUgcmFuZ2Ugc2hvdWxkIHN0b3AuXG4gIGNvbnN0IGVuZCA9IGNvdW50ICsgc3RhcnQ7XG5cbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKFxuICAgIHNjaGVkdWxlclxuICAgICAgPyAvLyBUaGUgZGVwcmVjYXRlZCBzY2hlZHVsZWQgcGF0aC5cbiAgICAgICAgKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICBsZXQgbiA9IHN0YXJ0O1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG4gPCBlbmQpIHtcbiAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KG4rKyk7XG4gICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgOiAvLyBTdGFuZGFyZCBzeW5jaHJvbm91cyByYW5nZS5cbiAgICAgICAgKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICBsZXQgbiA9IHN0YXJ0O1xuICAgICAgICAgIHdoaWxlIChuIDwgZW5kICYmICFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KG4rKyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICApO1xufVxuIl19
