import { WebSocketSubject } from './WebSocketSubject.mjs';
/**
 * Wrapper around the w3c-compatible WebSocket object provided by the browser.
 *
 * <span class="informal">{@link Subject} that communicates with a server via WebSocket</span>
 *
 * `webSocket` is a factory function that produces a `WebSocketSubject`,
 * which can be used to make WebSocket connection with an arbitrary endpoint.
 * `webSocket` accepts as an argument either a string with url of WebSocket endpoint, or an
 * {@link WebSocketSubjectConfig} object for providing additional configuration, as
 * well as Observers for tracking lifecycle of WebSocket connection.
 *
 * When `WebSocketSubject` is subscribed, it attempts to make a socket connection,
 * unless there is one made already. This means that many subscribers will always listen
 * on the same socket, thus saving resources. If however, two instances are made of `WebSocketSubject`,
 * even if these two were provided with the same url, they will attempt to make separate
 * connections. When consumer of a `WebSocketSubject` unsubscribes, socket connection is closed,
 * only if there are no more subscribers still listening. If after some time a consumer starts
 * subscribing again, connection is reestablished.
 *
 * Once connection is made, whenever a new message comes from the server, `WebSocketSubject` will emit that
 * message as a value in the stream. By default, a message from the socket is parsed via `JSON.parse`. If you
 * want to customize how deserialization is handled (if at all), you can provide custom `resultSelector`
 * function in {@link WebSocketSubject}. When connection closes, stream will complete, provided it happened without
 * any errors. If at any point (starting, maintaining or closing a connection) there is an error,
 * stream will also error with whatever WebSocket API has thrown.
 *
 * By virtue of being a {@link Subject}, `WebSocketSubject` allows for receiving and sending messages from the server. In order
 * to communicate with a connected endpoint, use `next`, `error` and `complete` methods. `next` sends a value to the server, so bear in mind
 * that this value will not be serialized beforehand. Because of This, `JSON.stringify` will have to be called on a value by hand,
 * before calling `next` with a result. Note also that if at the moment of nexting value
 * there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection
 * is finally established. `complete` method closes socket connection. `error` does the same,
 * as well as notifying the server that something went wrong via status code and string with details of what happened.
 * Since status code is required in WebSocket API, `WebSocketSubject` does not allow, like regular `Subject`,
 * arbitrary values being passed to the `error` method. It needs to be called with an object that has `code`
 * property with status code number and optional `reason` property with string describing details
 * of an error.
 *
 * Calling `next` does not affect subscribers of `WebSocketSubject` - they have no
 * information that something was sent to the server (unless of course the server
 * responds somehow to a message). On the other hand, since calling `complete` triggers
 * an attempt to close socket connection. If that connection is closed without any errors, stream will
 * complete, thus notifying all subscribers. And since calling `error` closes
 * socket connection as well, just with a different status code for the server, if closing itself proceeds
 * without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases
 * (calling `complete` or `error`), if process of closing socket connection results in some errors, *then* stream
 * will error.
 *
 * **Multiplexing**
 *
 * `WebSocketSubject` has an additional operator, not found in other Subjects. It is called `multiplex` and it is
 * used to simulate opening several socket connections, while in reality maintaining only one.
 * For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions,
 * it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket
 * endpoints, running on separate machines with only GUI combining them together. Having a socket connection
 * for each functionality could become too resource expensive. It is a common pattern to have single
 * WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services).
 * Even though there is a single connection in a client app, having the ability to manipulate streams as if it
 * were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for
 * given service and filter out messages of interest. This is exactly what `multiplex` method is for.
 *
 * Method accepts three parameters. First two are functions returning subscription and unsubscription messages
 * respectively. These are messages that will be sent to the server, whenever consumer of resulting Observable
 * subscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop
 * being forwarded to the client. In case of the above example application, after getting subscription message with proper identifier,
 * gateway server can decide that it should connect to real sport news service and start forwarding messages from it.
 * Note that both messages will be sent as returned by the functions, they are by default serialized using JSON.stringify, just
 * as messages pushed via `next`. Also bear in mind that these messages will be sent on *every* subscription and
 * unsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server
 * might stop sending messages, since it got unsubscription message. This needs to be handled
 * on the server or using {@link publish} on a Observable returned from 'multiplex'.
 *
 * Last argument to `multiplex` is a `messageFilter` function which should return a boolean. It is used to filter out messages
 * sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these
 * messages with some kind of string identifier on a message object and `messageFilter` would return `true`
 * if there is such identifier on an object emitted by the socket. Messages which returns `false` in `messageFilter` are simply skipped,
 * and are not passed down the stream.
 *
 * Return value of `multiplex` is an Observable with messages incoming from emulated socket connection. Note that this
 * is not a `WebSocketSubject`, so calling `next` or `multiplex` again will fail. For pushing values to the
 * server, use root `WebSocketSubject`.
 *
 * ## Examples
 *
 * Listening for messages from the server
 *
 * ```ts
 * import { webSocket } from 'rxjs/webSocket';
 *
 * const subject = webSocket('ws://localhost:8081');
 *
 * subject.subscribe({
 *   next: msg => console.log('message received: ' + msg), // Called whenever there is a message from the server.
 *   error: err => console.log(err), // Called if at any point WebSocket API signals some kind of error.
 *   complete: () => console.log('complete') // Called when connection is closed (for whatever reason).
 *  });
 * ```
 *
 * Pushing messages to the server
 *
 * ```ts
 * import { webSocket } from 'rxjs/webSocket';
 *
 * const subject = webSocket('ws://localhost:8081');
 *
 * subject.subscribe();
 * // Note that at least one consumer has to subscribe to the created subject - otherwise "nexted" values will be just buffered and not sent,
 * // since no connection was established!
 *
 * subject.next({ message: 'some message' });
 * // This will send a message to the server once a connection is made. Remember value is serialized with JSON.stringify by default!
 *
 * subject.complete(); // Closes the connection.
 *
 * subject.error({ code: 4000, reason: 'I think our app just broke!' });
 * // Also closes the connection, but let's the server know that this closing is caused by some error.
 * ```
 *
 * Multiplexing WebSocket
 *
 * ```ts
 * import { webSocket } from 'rxjs/webSocket';
 *
 * const subject = webSocket('ws://localhost:8081');
 *
 * const observableA = subject.multiplex(
 *   () => ({ subscribe: 'A' }), // When server gets this message, it will start sending messages for 'A'...
 *   () => ({ unsubscribe: 'A' }), // ...and when gets this one, it will stop.
 *   message => message.type === 'A' // If the function returns `true` message is passed down the stream. Skipped if the function returns false.
 * );
 *
 * const observableB = subject.multiplex( // And the same goes for 'B'.
 *   () => ({ subscribe: 'B' }),
 *   () => ({ unsubscribe: 'B' }),
 *   message => message.type === 'B'
 * );
 *
 * const subA = observableA.subscribe(messageForA => console.log(messageForA));
 * // At this moment WebSocket connection is established. Server gets '{"subscribe": "A"}' message and starts sending messages for 'A',
 * // which we log here.
 *
 * const subB = observableB.subscribe(messageForB => console.log(messageForB));
 * // Since we already have a connection, we just send '{"subscribe": "B"}' message to the server. It starts sending messages for 'B',
 * // which we log here.
 *
 * subB.unsubscribe();
 * // Message '{"unsubscribe": "B"}' is sent to the server, which stops sending 'B' messages.
 *
 * subA.unsubscribe();
 * // Message '{"unsubscribe": "A"}' makes the server stop sending messages for 'A'. Since there is no more subscribers to root Subject,
 * // socket connection closes.
 * ```
 *
 * @param {string|WebSocketSubjectConfig} urlConfigOrSource The WebSocket endpoint as an url or an object with
 * configuration and additional Observers.
 * @return {WebSocketSubject} Subject which allows to both send and receive messages via WebSocket connection.
 */
export function webSocket(urlConfigOrSource) {
    return new WebSocketSubject(urlConfigOrSource);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGdCQUFnQixFQUEwQixNQUFNLG9CQUFvQixDQUFDO0FBRTlFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Skc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFJLGlCQUFxRDtJQUNoRixPQUFPLElBQUksZ0JBQWdCLENBQUksaUJBQWlCLENBQUMsQ0FBQztBQUNwRCxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXZWJTb2NrZXRTdWJqZWN0LCBXZWJTb2NrZXRTdWJqZWN0Q29uZmlnIH0gZnJvbSAnLi9XZWJTb2NrZXRTdWJqZWN0JztcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCB0aGUgdzNjLWNvbXBhdGlibGUgV2ViU29ja2V0IG9iamVjdCBwcm92aWRlZCBieSB0aGUgYnJvd3Nlci5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+e0BsaW5rIFN1YmplY3R9IHRoYXQgY29tbXVuaWNhdGVzIHdpdGggYSBzZXJ2ZXIgdmlhIFdlYlNvY2tldDwvc3Bhbj5cbiAqXG4gKiBgd2ViU29ja2V0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhIGBXZWJTb2NrZXRTdWJqZWN0YCxcbiAqIHdoaWNoIGNhbiBiZSB1c2VkIHRvIG1ha2UgV2ViU29ja2V0IGNvbm5lY3Rpb24gd2l0aCBhbiBhcmJpdHJhcnkgZW5kcG9pbnQuXG4gKiBgd2ViU29ja2V0YCBhY2NlcHRzIGFzIGFuIGFyZ3VtZW50IGVpdGhlciBhIHN0cmluZyB3aXRoIHVybCBvZiBXZWJTb2NrZXQgZW5kcG9pbnQsIG9yIGFuXG4gKiB7QGxpbmsgV2ViU29ja2V0U3ViamVjdENvbmZpZ30gb2JqZWN0IGZvciBwcm92aWRpbmcgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uLCBhc1xuICogd2VsbCBhcyBPYnNlcnZlcnMgZm9yIHRyYWNraW5nIGxpZmVjeWNsZSBvZiBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAqXG4gKiBXaGVuIGBXZWJTb2NrZXRTdWJqZWN0YCBpcyBzdWJzY3JpYmVkLCBpdCBhdHRlbXB0cyB0byBtYWtlIGEgc29ja2V0IGNvbm5lY3Rpb24sXG4gKiB1bmxlc3MgdGhlcmUgaXMgb25lIG1hZGUgYWxyZWFkeS4gVGhpcyBtZWFucyB0aGF0IG1hbnkgc3Vic2NyaWJlcnMgd2lsbCBhbHdheXMgbGlzdGVuXG4gKiBvbiB0aGUgc2FtZSBzb2NrZXQsIHRodXMgc2F2aW5nIHJlc291cmNlcy4gSWYgaG93ZXZlciwgdHdvIGluc3RhbmNlcyBhcmUgbWFkZSBvZiBgV2ViU29ja2V0U3ViamVjdGAsXG4gKiBldmVuIGlmIHRoZXNlIHR3byB3ZXJlIHByb3ZpZGVkIHdpdGggdGhlIHNhbWUgdXJsLCB0aGV5IHdpbGwgYXR0ZW1wdCB0byBtYWtlIHNlcGFyYXRlXG4gKiBjb25uZWN0aW9ucy4gV2hlbiBjb25zdW1lciBvZiBhIGBXZWJTb2NrZXRTdWJqZWN0YCB1bnN1YnNjcmliZXMsIHNvY2tldCBjb25uZWN0aW9uIGlzIGNsb3NlZCxcbiAqIG9ubHkgaWYgdGhlcmUgYXJlIG5vIG1vcmUgc3Vic2NyaWJlcnMgc3RpbGwgbGlzdGVuaW5nLiBJZiBhZnRlciBzb21lIHRpbWUgYSBjb25zdW1lciBzdGFydHNcbiAqIHN1YnNjcmliaW5nIGFnYWluLCBjb25uZWN0aW9uIGlzIHJlZXN0YWJsaXNoZWQuXG4gKlxuICogT25jZSBjb25uZWN0aW9uIGlzIG1hZGUsIHdoZW5ldmVyIGEgbmV3IG1lc3NhZ2UgY29tZXMgZnJvbSB0aGUgc2VydmVyLCBgV2ViU29ja2V0U3ViamVjdGAgd2lsbCBlbWl0IHRoYXRcbiAqIG1lc3NhZ2UgYXMgYSB2YWx1ZSBpbiB0aGUgc3RyZWFtLiBCeSBkZWZhdWx0LCBhIG1lc3NhZ2UgZnJvbSB0aGUgc29ja2V0IGlzIHBhcnNlZCB2aWEgYEpTT04ucGFyc2VgLiBJZiB5b3VcbiAqIHdhbnQgdG8gY3VzdG9taXplIGhvdyBkZXNlcmlhbGl6YXRpb24gaXMgaGFuZGxlZCAoaWYgYXQgYWxsKSwgeW91IGNhbiBwcm92aWRlIGN1c3RvbSBgcmVzdWx0U2VsZWN0b3JgXG4gKiBmdW5jdGlvbiBpbiB7QGxpbmsgV2ViU29ja2V0U3ViamVjdH0uIFdoZW4gY29ubmVjdGlvbiBjbG9zZXMsIHN0cmVhbSB3aWxsIGNvbXBsZXRlLCBwcm92aWRlZCBpdCBoYXBwZW5lZCB3aXRob3V0XG4gKiBhbnkgZXJyb3JzLiBJZiBhdCBhbnkgcG9pbnQgKHN0YXJ0aW5nLCBtYWludGFpbmluZyBvciBjbG9zaW5nIGEgY29ubmVjdGlvbikgdGhlcmUgaXMgYW4gZXJyb3IsXG4gKiBzdHJlYW0gd2lsbCBhbHNvIGVycm9yIHdpdGggd2hhdGV2ZXIgV2ViU29ja2V0IEFQSSBoYXMgdGhyb3duLlxuICpcbiAqIEJ5IHZpcnR1ZSBvZiBiZWluZyBhIHtAbGluayBTdWJqZWN0fSwgYFdlYlNvY2tldFN1YmplY3RgIGFsbG93cyBmb3IgcmVjZWl2aW5nIGFuZCBzZW5kaW5nIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci4gSW4gb3JkZXJcbiAqIHRvIGNvbW11bmljYXRlIHdpdGggYSBjb25uZWN0ZWQgZW5kcG9pbnQsIHVzZSBgbmV4dGAsIGBlcnJvcmAgYW5kIGBjb21wbGV0ZWAgbWV0aG9kcy4gYG5leHRgIHNlbmRzIGEgdmFsdWUgdG8gdGhlIHNlcnZlciwgc28gYmVhciBpbiBtaW5kXG4gKiB0aGF0IHRoaXMgdmFsdWUgd2lsbCBub3QgYmUgc2VyaWFsaXplZCBiZWZvcmVoYW5kLiBCZWNhdXNlIG9mIFRoaXMsIGBKU09OLnN0cmluZ2lmeWAgd2lsbCBoYXZlIHRvIGJlIGNhbGxlZCBvbiBhIHZhbHVlIGJ5IGhhbmQsXG4gKiBiZWZvcmUgY2FsbGluZyBgbmV4dGAgd2l0aCBhIHJlc3VsdC4gTm90ZSBhbHNvIHRoYXQgaWYgYXQgdGhlIG1vbWVudCBvZiBuZXh0aW5nIHZhbHVlXG4gKiB0aGVyZSBpcyBubyBzb2NrZXQgY29ubmVjdGlvbiAoZm9yIGV4YW1wbGUgbm8gb25lIGlzIHN1YnNjcmliaW5nKSwgdGhvc2UgdmFsdWVzIHdpbGwgYmUgYnVmZmVyZWQsIGFuZCBzZW50IHdoZW4gY29ubmVjdGlvblxuICogaXMgZmluYWxseSBlc3RhYmxpc2hlZC4gYGNvbXBsZXRlYCBtZXRob2QgY2xvc2VzIHNvY2tldCBjb25uZWN0aW9uLiBgZXJyb3JgIGRvZXMgdGhlIHNhbWUsXG4gKiBhcyB3ZWxsIGFzIG5vdGlmeWluZyB0aGUgc2VydmVyIHRoYXQgc29tZXRoaW5nIHdlbnQgd3JvbmcgdmlhIHN0YXR1cyBjb2RlIGFuZCBzdHJpbmcgd2l0aCBkZXRhaWxzIG9mIHdoYXQgaGFwcGVuZWQuXG4gKiBTaW5jZSBzdGF0dXMgY29kZSBpcyByZXF1aXJlZCBpbiBXZWJTb2NrZXQgQVBJLCBgV2ViU29ja2V0U3ViamVjdGAgZG9lcyBub3QgYWxsb3csIGxpa2UgcmVndWxhciBgU3ViamVjdGAsXG4gKiBhcmJpdHJhcnkgdmFsdWVzIGJlaW5nIHBhc3NlZCB0byB0aGUgYGVycm9yYCBtZXRob2QuIEl0IG5lZWRzIHRvIGJlIGNhbGxlZCB3aXRoIGFuIG9iamVjdCB0aGF0IGhhcyBgY29kZWBcbiAqIHByb3BlcnR5IHdpdGggc3RhdHVzIGNvZGUgbnVtYmVyIGFuZCBvcHRpb25hbCBgcmVhc29uYCBwcm9wZXJ0eSB3aXRoIHN0cmluZyBkZXNjcmliaW5nIGRldGFpbHNcbiAqIG9mIGFuIGVycm9yLlxuICpcbiAqIENhbGxpbmcgYG5leHRgIGRvZXMgbm90IGFmZmVjdCBzdWJzY3JpYmVycyBvZiBgV2ViU29ja2V0U3ViamVjdGAgLSB0aGV5IGhhdmUgbm9cbiAqIGluZm9ybWF0aW9uIHRoYXQgc29tZXRoaW5nIHdhcyBzZW50IHRvIHRoZSBzZXJ2ZXIgKHVubGVzcyBvZiBjb3Vyc2UgdGhlIHNlcnZlclxuICogcmVzcG9uZHMgc29tZWhvdyB0byBhIG1lc3NhZ2UpLiBPbiB0aGUgb3RoZXIgaGFuZCwgc2luY2UgY2FsbGluZyBgY29tcGxldGVgIHRyaWdnZXJzXG4gKiBhbiBhdHRlbXB0IHRvIGNsb3NlIHNvY2tldCBjb25uZWN0aW9uLiBJZiB0aGF0IGNvbm5lY3Rpb24gaXMgY2xvc2VkIHdpdGhvdXQgYW55IGVycm9ycywgc3RyZWFtIHdpbGxcbiAqIGNvbXBsZXRlLCB0aHVzIG5vdGlmeWluZyBhbGwgc3Vic2NyaWJlcnMuIEFuZCBzaW5jZSBjYWxsaW5nIGBlcnJvcmAgY2xvc2VzXG4gKiBzb2NrZXQgY29ubmVjdGlvbiBhcyB3ZWxsLCBqdXN0IHdpdGggYSBkaWZmZXJlbnQgc3RhdHVzIGNvZGUgZm9yIHRoZSBzZXJ2ZXIsIGlmIGNsb3NpbmcgaXRzZWxmIHByb2NlZWRzXG4gKiB3aXRob3V0IGVycm9ycywgc3Vic2NyaWJlZCBPYnNlcnZhYmxlIHdpbGwgbm90IGVycm9yLCBhcyBvbmUgbWlnaHQgZXhwZWN0LCBidXQgY29tcGxldGUgYXMgdXN1YWwuIEluIGJvdGggY2FzZXNcbiAqIChjYWxsaW5nIGBjb21wbGV0ZWAgb3IgYGVycm9yYCksIGlmIHByb2Nlc3Mgb2YgY2xvc2luZyBzb2NrZXQgY29ubmVjdGlvbiByZXN1bHRzIGluIHNvbWUgZXJyb3JzLCAqdGhlbiogc3RyZWFtXG4gKiB3aWxsIGVycm9yLlxuICpcbiAqICoqTXVsdGlwbGV4aW5nKipcbiAqXG4gKiBgV2ViU29ja2V0U3ViamVjdGAgaGFzIGFuIGFkZGl0aW9uYWwgb3BlcmF0b3IsIG5vdCBmb3VuZCBpbiBvdGhlciBTdWJqZWN0cy4gSXQgaXMgY2FsbGVkIGBtdWx0aXBsZXhgIGFuZCBpdCBpc1xuICogdXNlZCB0byBzaW11bGF0ZSBvcGVuaW5nIHNldmVyYWwgc29ja2V0IGNvbm5lY3Rpb25zLCB3aGlsZSBpbiByZWFsaXR5IG1haW50YWluaW5nIG9ubHkgb25lLlxuICogRm9yIGV4YW1wbGUsIGFuIGFwcGxpY2F0aW9uIGhhcyBib3RoIGNoYXQgcGFuZWwgYW5kIHJlYWwtdGltZSBub3RpZmljYXRpb25zIGFib3V0IHNwb3J0IG5ld3MuIFNpbmNlIHRoZXNlIGFyZSB0d28gZGlzdGluY3QgZnVuY3Rpb25zLFxuICogaXQgd291bGQgbWFrZSBzZW5zZSB0byBoYXZlIHR3byBzZXBhcmF0ZSBjb25uZWN0aW9ucyBmb3IgZWFjaC4gUGVyaGFwcyB0aGVyZSBjb3VsZCBldmVuIGJlIHR3byBzZXBhcmF0ZSBzZXJ2aWNlcyB3aXRoIFdlYlNvY2tldFxuICogZW5kcG9pbnRzLCBydW5uaW5nIG9uIHNlcGFyYXRlIG1hY2hpbmVzIHdpdGggb25seSBHVUkgY29tYmluaW5nIHRoZW0gdG9nZXRoZXIuIEhhdmluZyBhIHNvY2tldCBjb25uZWN0aW9uXG4gKiBmb3IgZWFjaCBmdW5jdGlvbmFsaXR5IGNvdWxkIGJlY29tZSB0b28gcmVzb3VyY2UgZXhwZW5zaXZlLiBJdCBpcyBhIGNvbW1vbiBwYXR0ZXJuIHRvIGhhdmUgc2luZ2xlXG4gKiBXZWJTb2NrZXQgZW5kcG9pbnQgdGhhdCBhY3RzIGFzIGEgZ2F0ZXdheSBmb3IgdGhlIG90aGVyIHNlcnZpY2VzIChpbiB0aGlzIGNhc2UgY2hhdCBhbmQgc3BvcnQgbmV3cyBzZXJ2aWNlcykuXG4gKiBFdmVuIHRob3VnaCB0aGVyZSBpcyBhIHNpbmdsZSBjb25uZWN0aW9uIGluIGEgY2xpZW50IGFwcCwgaGF2aW5nIHRoZSBhYmlsaXR5IHRvIG1hbmlwdWxhdGUgc3RyZWFtcyBhcyBpZiBpdFxuICogd2VyZSB0d28gc2VwYXJhdGUgc29ja2V0cyBpcyBkZXNpcmFibGUuIFRoaXMgZWxpbWluYXRlcyBtYW51YWxseSByZWdpc3RlcmluZyBhbmQgdW5yZWdpc3RlcmluZyBpbiBhIGdhdGV3YXkgZm9yXG4gKiBnaXZlbiBzZXJ2aWNlIGFuZCBmaWx0ZXIgb3V0IG1lc3NhZ2VzIG9mIGludGVyZXN0LiBUaGlzIGlzIGV4YWN0bHkgd2hhdCBgbXVsdGlwbGV4YCBtZXRob2QgaXMgZm9yLlxuICpcbiAqIE1ldGhvZCBhY2NlcHRzIHRocmVlIHBhcmFtZXRlcnMuIEZpcnN0IHR3byBhcmUgZnVuY3Rpb25zIHJldHVybmluZyBzdWJzY3JpcHRpb24gYW5kIHVuc3Vic2NyaXB0aW9uIG1lc3NhZ2VzXG4gKiByZXNwZWN0aXZlbHkuIFRoZXNlIGFyZSBtZXNzYWdlcyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc2VydmVyLCB3aGVuZXZlciBjb25zdW1lciBvZiByZXN1bHRpbmcgT2JzZXJ2YWJsZVxuICogc3Vic2NyaWJlcyBhbmQgdW5zdWJzY3JpYmVzLiBTZXJ2ZXIgY2FuIHVzZSB0aGVtIHRvIHZlcmlmeSB0aGF0IHNvbWUga2luZCBvZiBtZXNzYWdlcyBzaG91bGQgc3RhcnQgb3Igc3RvcFxuICogYmVpbmcgZm9yd2FyZGVkIHRvIHRoZSBjbGllbnQuIEluIGNhc2Ugb2YgdGhlIGFib3ZlIGV4YW1wbGUgYXBwbGljYXRpb24sIGFmdGVyIGdldHRpbmcgc3Vic2NyaXB0aW9uIG1lc3NhZ2Ugd2l0aCBwcm9wZXIgaWRlbnRpZmllcixcbiAqIGdhdGV3YXkgc2VydmVyIGNhbiBkZWNpZGUgdGhhdCBpdCBzaG91bGQgY29ubmVjdCB0byByZWFsIHNwb3J0IG5ld3Mgc2VydmljZSBhbmQgc3RhcnQgZm9yd2FyZGluZyBtZXNzYWdlcyBmcm9tIGl0LlxuICogTm90ZSB0aGF0IGJvdGggbWVzc2FnZXMgd2lsbCBiZSBzZW50IGFzIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbnMsIHRoZXkgYXJlIGJ5IGRlZmF1bHQgc2VyaWFsaXplZCB1c2luZyBKU09OLnN0cmluZ2lmeSwganVzdFxuICogYXMgbWVzc2FnZXMgcHVzaGVkIHZpYSBgbmV4dGAuIEFsc28gYmVhciBpbiBtaW5kIHRoYXQgdGhlc2UgbWVzc2FnZXMgd2lsbCBiZSBzZW50IG9uICpldmVyeSogc3Vic2NyaXB0aW9uIGFuZFxuICogdW5zdWJzY3JpcHRpb24uIFRoaXMgaXMgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzLCBiZWNhdXNlIG9uZSBjb25zdW1lciBvZiBhbiBPYnNlcnZhYmxlIG1heSB1bnN1YnNjcmliZSBhbmQgdGhlIHNlcnZlclxuICogbWlnaHQgc3RvcCBzZW5kaW5nIG1lc3NhZ2VzLCBzaW5jZSBpdCBnb3QgdW5zdWJzY3JpcHRpb24gbWVzc2FnZS4gVGhpcyBuZWVkcyB0byBiZSBoYW5kbGVkXG4gKiBvbiB0aGUgc2VydmVyIG9yIHVzaW5nIHtAbGluayBwdWJsaXNofSBvbiBhIE9ic2VydmFibGUgcmV0dXJuZWQgZnJvbSAnbXVsdGlwbGV4Jy5cbiAqXG4gKiBMYXN0IGFyZ3VtZW50IHRvIGBtdWx0aXBsZXhgIGlzIGEgYG1lc3NhZ2VGaWx0ZXJgIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCByZXR1cm4gYSBib29sZWFuLiBJdCBpcyB1c2VkIHRvIGZpbHRlciBvdXQgbWVzc2FnZXNcbiAqIHNlbnQgYnkgdGhlIHNlcnZlciB0byBvbmx5IHRob3NlIHRoYXQgYmVsb25nIHRvIHNpbXVsYXRlZCBXZWJTb2NrZXQgc3RyZWFtLiBGb3IgZXhhbXBsZSwgc2VydmVyIG1pZ2h0IG1hcmsgdGhlc2VcbiAqIG1lc3NhZ2VzIHdpdGggc29tZSBraW5kIG9mIHN0cmluZyBpZGVudGlmaWVyIG9uIGEgbWVzc2FnZSBvYmplY3QgYW5kIGBtZXNzYWdlRmlsdGVyYCB3b3VsZCByZXR1cm4gYHRydWVgXG4gKiBpZiB0aGVyZSBpcyBzdWNoIGlkZW50aWZpZXIgb24gYW4gb2JqZWN0IGVtaXR0ZWQgYnkgdGhlIHNvY2tldC4gTWVzc2FnZXMgd2hpY2ggcmV0dXJucyBgZmFsc2VgIGluIGBtZXNzYWdlRmlsdGVyYCBhcmUgc2ltcGx5IHNraXBwZWQsXG4gKiBhbmQgYXJlIG5vdCBwYXNzZWQgZG93biB0aGUgc3RyZWFtLlxuICpcbiAqIFJldHVybiB2YWx1ZSBvZiBgbXVsdGlwbGV4YCBpcyBhbiBPYnNlcnZhYmxlIHdpdGggbWVzc2FnZXMgaW5jb21pbmcgZnJvbSBlbXVsYXRlZCBzb2NrZXQgY29ubmVjdGlvbi4gTm90ZSB0aGF0IHRoaXNcbiAqIGlzIG5vdCBhIGBXZWJTb2NrZXRTdWJqZWN0YCwgc28gY2FsbGluZyBgbmV4dGAgb3IgYG11bHRpcGxleGAgYWdhaW4gd2lsbCBmYWlsLiBGb3IgcHVzaGluZyB2YWx1ZXMgdG8gdGhlXG4gKiBzZXJ2ZXIsIHVzZSByb290IGBXZWJTb2NrZXRTdWJqZWN0YC5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIExpc3RlbmluZyBmb3IgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHdlYlNvY2tldCB9IGZyb20gJ3J4anMvd2ViU29ja2V0JztcbiAqXG4gKiBjb25zdCBzdWJqZWN0ID0gd2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDo4MDgxJyk7XG4gKlxuICogc3ViamVjdC5zdWJzY3JpYmUoe1xuICogICBuZXh0OiBtc2cgPT4gY29uc29sZS5sb2coJ21lc3NhZ2UgcmVjZWl2ZWQ6ICcgKyBtc2cpLCAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlcmUgaXMgYSBtZXNzYWdlIGZyb20gdGhlIHNlcnZlci5cbiAqICAgZXJyb3I6IGVyciA9PiBjb25zb2xlLmxvZyhlcnIpLCAvLyBDYWxsZWQgaWYgYXQgYW55IHBvaW50IFdlYlNvY2tldCBBUEkgc2lnbmFscyBzb21lIGtpbmQgb2YgZXJyb3IuXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGUnKSAvLyBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGNsb3NlZCAoZm9yIHdoYXRldmVyIHJlYXNvbikuXG4gKiAgfSk7XG4gKiBgYGBcbiAqXG4gKiBQdXNoaW5nIG1lc3NhZ2VzIHRvIHRoZSBzZXJ2ZXJcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgd2ViU29ja2V0IH0gZnJvbSAncnhqcy93ZWJTb2NrZXQnO1xuICpcbiAqIGNvbnN0IHN1YmplY3QgPSB3ZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjgwODEnKTtcbiAqXG4gKiBzdWJqZWN0LnN1YnNjcmliZSgpO1xuICogLy8gTm90ZSB0aGF0IGF0IGxlYXN0IG9uZSBjb25zdW1lciBoYXMgdG8gc3Vic2NyaWJlIHRvIHRoZSBjcmVhdGVkIHN1YmplY3QgLSBvdGhlcndpc2UgXCJuZXh0ZWRcIiB2YWx1ZXMgd2lsbCBiZSBqdXN0IGJ1ZmZlcmVkIGFuZCBub3Qgc2VudCxcbiAqIC8vIHNpbmNlIG5vIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkIVxuICpcbiAqIHN1YmplY3QubmV4dCh7IG1lc3NhZ2U6ICdzb21lIG1lc3NhZ2UnIH0pO1xuICogLy8gVGhpcyB3aWxsIHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXIgb25jZSBhIGNvbm5lY3Rpb24gaXMgbWFkZS4gUmVtZW1iZXIgdmFsdWUgaXMgc2VyaWFsaXplZCB3aXRoIEpTT04uc3RyaW5naWZ5IGJ5IGRlZmF1bHQhXG4gKlxuICogc3ViamVjdC5jb21wbGV0ZSgpOyAvLyBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogc3ViamVjdC5lcnJvcih7IGNvZGU6IDQwMDAsIHJlYXNvbjogJ0kgdGhpbmsgb3VyIGFwcCBqdXN0IGJyb2tlIScgfSk7XG4gKiAvLyBBbHNvIGNsb3NlcyB0aGUgY29ubmVjdGlvbiwgYnV0IGxldCdzIHRoZSBzZXJ2ZXIga25vdyB0aGF0IHRoaXMgY2xvc2luZyBpcyBjYXVzZWQgYnkgc29tZSBlcnJvci5cbiAqIGBgYFxuICpcbiAqIE11bHRpcGxleGluZyBXZWJTb2NrZXRcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgd2ViU29ja2V0IH0gZnJvbSAncnhqcy93ZWJTb2NrZXQnO1xuICpcbiAqIGNvbnN0IHN1YmplY3QgPSB3ZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjgwODEnKTtcbiAqXG4gKiBjb25zdCBvYnNlcnZhYmxlQSA9IHN1YmplY3QubXVsdGlwbGV4KFxuICogICAoKSA9PiAoeyBzdWJzY3JpYmU6ICdBJyB9KSwgLy8gV2hlbiBzZXJ2ZXIgZ2V0cyB0aGlzIG1lc3NhZ2UsIGl0IHdpbGwgc3RhcnQgc2VuZGluZyBtZXNzYWdlcyBmb3IgJ0EnLi4uXG4gKiAgICgpID0+ICh7IHVuc3Vic2NyaWJlOiAnQScgfSksIC8vIC4uLmFuZCB3aGVuIGdldHMgdGhpcyBvbmUsIGl0IHdpbGwgc3RvcC5cbiAqICAgbWVzc2FnZSA9PiBtZXNzYWdlLnR5cGUgPT09ICdBJyAvLyBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgbWVzc2FnZSBpcyBwYXNzZWQgZG93biB0aGUgc3RyZWFtLiBTa2lwcGVkIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLlxuICogKTtcbiAqXG4gKiBjb25zdCBvYnNlcnZhYmxlQiA9IHN1YmplY3QubXVsdGlwbGV4KCAvLyBBbmQgdGhlIHNhbWUgZ29lcyBmb3IgJ0InLlxuICogICAoKSA9PiAoeyBzdWJzY3JpYmU6ICdCJyB9KSxcbiAqICAgKCkgPT4gKHsgdW5zdWJzY3JpYmU6ICdCJyB9KSxcbiAqICAgbWVzc2FnZSA9PiBtZXNzYWdlLnR5cGUgPT09ICdCJ1xuICogKTtcbiAqXG4gKiBjb25zdCBzdWJBID0gb2JzZXJ2YWJsZUEuc3Vic2NyaWJlKG1lc3NhZ2VGb3JBID0+IGNvbnNvbGUubG9nKG1lc3NhZ2VGb3JBKSk7XG4gKiAvLyBBdCB0aGlzIG1vbWVudCBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZC4gU2VydmVyIGdldHMgJ3tcInN1YnNjcmliZVwiOiBcIkFcIn0nIG1lc3NhZ2UgYW5kIHN0YXJ0cyBzZW5kaW5nIG1lc3NhZ2VzIGZvciAnQScsXG4gKiAvLyB3aGljaCB3ZSBsb2cgaGVyZS5cbiAqXG4gKiBjb25zdCBzdWJCID0gb2JzZXJ2YWJsZUIuc3Vic2NyaWJlKG1lc3NhZ2VGb3JCID0+IGNvbnNvbGUubG9nKG1lc3NhZ2VGb3JCKSk7XG4gKiAvLyBTaW5jZSB3ZSBhbHJlYWR5IGhhdmUgYSBjb25uZWN0aW9uLCB3ZSBqdXN0IHNlbmQgJ3tcInN1YnNjcmliZVwiOiBcIkJcIn0nIG1lc3NhZ2UgdG8gdGhlIHNlcnZlci4gSXQgc3RhcnRzIHNlbmRpbmcgbWVzc2FnZXMgZm9yICdCJyxcbiAqIC8vIHdoaWNoIHdlIGxvZyBoZXJlLlxuICpcbiAqIHN1YkIudW5zdWJzY3JpYmUoKTtcbiAqIC8vIE1lc3NhZ2UgJ3tcInVuc3Vic2NyaWJlXCI6IFwiQlwifScgaXMgc2VudCB0byB0aGUgc2VydmVyLCB3aGljaCBzdG9wcyBzZW5kaW5nICdCJyBtZXNzYWdlcy5cbiAqXG4gKiBzdWJBLnVuc3Vic2NyaWJlKCk7XG4gKiAvLyBNZXNzYWdlICd7XCJ1bnN1YnNjcmliZVwiOiBcIkFcIn0nIG1ha2VzIHRoZSBzZXJ2ZXIgc3RvcCBzZW5kaW5nIG1lc3NhZ2VzIGZvciAnQScuIFNpbmNlIHRoZXJlIGlzIG5vIG1vcmUgc3Vic2NyaWJlcnMgdG8gcm9vdCBTdWJqZWN0LFxuICogLy8gc29ja2V0IGNvbm5lY3Rpb24gY2xvc2VzLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8V2ViU29ja2V0U3ViamVjdENvbmZpZ30gdXJsQ29uZmlnT3JTb3VyY2UgVGhlIFdlYlNvY2tldCBlbmRwb2ludCBhcyBhbiB1cmwgb3IgYW4gb2JqZWN0IHdpdGhcbiAqIGNvbmZpZ3VyYXRpb24gYW5kIGFkZGl0aW9uYWwgT2JzZXJ2ZXJzLlxuICogQHJldHVybiB7V2ViU29ja2V0U3ViamVjdH0gU3ViamVjdCB3aGljaCBhbGxvd3MgdG8gYm90aCBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzIHZpYSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdlYlNvY2tldDxUPih1cmxDb25maWdPclNvdXJjZTogc3RyaW5nIHwgV2ViU29ja2V0U3ViamVjdENvbmZpZzxUPik6IFdlYlNvY2tldFN1YmplY3Q8VD4ge1xuICByZXR1cm4gbmV3IFdlYlNvY2tldFN1YmplY3Q8VD4odXJsQ29uZmlnT3JTb3VyY2UpO1xufVxuIl19
