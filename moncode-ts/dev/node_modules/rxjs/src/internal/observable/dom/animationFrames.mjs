import { Observable } from '../../Observable.mjs';
import { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider.mjs';
import { animationFrameProvider } from '../../scheduler/animationFrameProvider.mjs';
/**
 * An observable of animation frames
 *
 * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.
 * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.
 *
 * Every subscription will start a separate animation loop. Since animation frames are always scheduled
 * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously
 * should not be much different or have more overhead than looping over an array of events during
 * a single animation frame. However, if for some reason the developer would like to ensure the
 * execution of animation-related handlers are all executed during the same task by the engine,
 * the `share` operator can be used.
 *
 * This is useful for setting up animations with RxJS.
 *
 * ## Examples
 *
 * Tweening a div to move it on the screen
 *
 * ```ts
 * import { animationFrames, map, takeWhile, endWith } from 'rxjs';
 *
 * function tween(start: number, end: number, duration: number) {
 *   const diff = end - start;
 *   return animationFrames().pipe(
 *     // Figure out what percentage of time has passed
 *     map(({ elapsed }) => elapsed / duration),
 *     // Take the vector while less than 100%
 *     takeWhile(v => v < 1),
 *     // Finish with 100%
 *     endWith(1),
 *     // Calculate the distance traveled between start and end
 *     map(v => v * diff + start)
 *   );
 * }
 *
 * // Setup a div for us to move around
 * const div = document.createElement('div');
 * document.body.appendChild(div);
 * div.style.position = 'absolute';
 * div.style.width = '40px';
 * div.style.height = '40px';
 * div.style.backgroundColor = 'lime';
 * div.style.transform = 'translate3d(10px, 0, 0)';
 *
 * tween(10, 200, 4000).subscribe(x => {
 *   div.style.transform = `translate3d(${ x }px, 0, 0)`;
 * });
 * ```
 *
 * Providing a custom timestamp provider
 *
 * ```ts
 * import { animationFrames, TimestampProvider } from 'rxjs';
 *
 * // A custom timestamp provider
 * let now = 0;
 * const customTSProvider: TimestampProvider = {
 *   now() { return now++; }
 * };
 *
 * const source$ = animationFrames(customTSProvider);
 *
 * // Log increasing numbers 0...1...2... on every animation frame.
 * source$.subscribe(({ elapsed }) => console.log(elapsed));
 * ```
 *
 * @param timestampProvider An object with a `now` method that provides a numeric timestamp
 */
export function animationFrames(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
}
/**
 * Does the work of creating the observable for `animationFrames`.
 * @param timestampProvider The timestamp provider to use to create the observable
 */
function animationFramesFactory(timestampProvider) {
    return new Observable((subscriber) => {
        // If no timestamp provider is specified, use performance.now() - as it
        // will return timestamps 'compatible' with those passed to the run
        // callback and won't be affected by NTP adjustments, etc.
        const provider = timestampProvider || performanceTimestampProvider;
        // Capture the start time upon subscription, as the run callback can remain
        // queued for a considerable period of time and the elapsed time should
        // represent the time elapsed since subscription - not the time since the
        // first rendered animation frame.
        const start = provider.now();
        let id = 0;
        const run = () => {
            if (!subscriber.closed) {
                id = animationFrameProvider.requestAnimationFrame((timestamp) => {
                    id = 0;
                    // Use the provider's timestamp to calculate the elapsed time. Note that
                    // this means - if the caller hasn't passed a provider - that
                    // performance.now() will be used instead of the timestamp that was
                    // passed to the run callback. The reason for this is that the timestamp
                    // passed to the callback can be earlier than the start time, as it
                    // represents the time at which the browser decided it would render any
                    // queued frames - and that time can be earlier the captured start time.
                    const now = provider.now();
                    subscriber.next({
                        timestamp: timestampProvider ? now : timestamp,
                        elapsed: now - start,
                    });
                    run();
                });
            }
        };
        run();
        return () => {
            if (id) {
                animationFrameProvider.cancelAnimationFrame(id);
            }
        };
    });
}
/**
 * In the common case, where the timestamp provided by the rAF API is used,
 * we use this shared observable to reduce overhead.
 */
const DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS9hbmltYXRpb25GcmFtZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTlDLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBQzVGLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBRWhGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9FRztBQUNILE1BQU0sVUFBVSxlQUFlLENBQUMsaUJBQXFDO0lBQ25FLE9BQU8saUJBQWlCLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLHdCQUF3QixDQUFDO0FBQ2xHLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLHNCQUFzQixDQUFDLGlCQUFxQztJQUNuRSxPQUFPLElBQUksVUFBVSxDQUF5QyxDQUFDLFVBQVUsRUFBRSxFQUFFO1FBQzNFLHVFQUF1RTtRQUN2RSxtRUFBbUU7UUFDbkUsMERBQTBEO1FBQzFELE1BQU0sUUFBUSxHQUFHLGlCQUFpQixJQUFJLDRCQUE0QixDQUFDO1FBRW5FLDJFQUEyRTtRQUMzRSx1RUFBdUU7UUFDdkUseUVBQXlFO1FBQ3pFLGtDQUFrQztRQUNsQyxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFN0IsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsTUFBTSxHQUFHLEdBQUcsR0FBRyxFQUFFO1lBQ2YsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDdkIsRUFBRSxHQUFHLHNCQUFzQixDQUFDLHFCQUFxQixDQUFDLENBQUMsU0FBdUMsRUFBRSxFQUFFO29CQUM1RixFQUFFLEdBQUcsQ0FBQyxDQUFDO29CQUNQLHdFQUF3RTtvQkFDeEUsNkRBQTZEO29CQUM3RCxtRUFBbUU7b0JBQ25FLHdFQUF3RTtvQkFDeEUsbUVBQW1FO29CQUNuRSx1RUFBdUU7b0JBQ3ZFLHdFQUF3RTtvQkFDeEUsTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUMzQixVQUFVLENBQUMsSUFBSSxDQUFDO3dCQUNkLFNBQVMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTO3dCQUM5QyxPQUFPLEVBQUUsR0FBRyxHQUFHLEtBQUs7cUJBQ3JCLENBQUMsQ0FBQztvQkFDSCxHQUFHLEVBQUUsQ0FBQztnQkFDUixDQUFDLENBQUMsQ0FBQztZQUNMLENBQUM7UUFDSCxDQUFDLENBQUM7UUFFRixHQUFHLEVBQUUsQ0FBQztRQUVOLE9BQU8sR0FBRyxFQUFFO1lBQ1YsSUFBSSxFQUFFLEVBQUUsQ0FBQztnQkFDUCxzQkFBc0IsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNsRCxDQUFDO1FBQ0gsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSx3QkFBd0IsR0FBRyxzQkFBc0IsRUFBRSxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS9hbmltYXRpb25GcmFtZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBUaW1lc3RhbXBQcm92aWRlciB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IHBlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9zY2hlZHVsZXIvcGVyZm9ybWFuY2VUaW1lc3RhbXBQcm92aWRlcic7XG5pbXBvcnQgeyBhbmltYXRpb25GcmFtZVByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lUHJvdmlkZXInO1xuXG4vKipcbiAqIEFuIG9ic2VydmFibGUgb2YgYW5pbWF0aW9uIGZyYW1lc1xuICpcbiAqIEVtaXRzIHRoZSBhbW91bnQgb2YgdGltZSBlbGFwc2VkIHNpbmNlIHN1YnNjcmlwdGlvbiBhbmQgdGhlIHRpbWVzdGFtcCBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZS5cbiAqIERlZmF1bHRzIHRvIG1pbGxpc2Vjb25kcyBwcm92aWRlZCB0byB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJ3MgY2FsbGJhY2suIERvZXMgbm90IGVuZCBvbiBpdHMgb3duLlxuICpcbiAqIEV2ZXJ5IHN1YnNjcmlwdGlvbiB3aWxsIHN0YXJ0IGEgc2VwYXJhdGUgYW5pbWF0aW9uIGxvb3AuIFNpbmNlIGFuaW1hdGlvbiBmcmFtZXMgYXJlIGFsd2F5cyBzY2hlZHVsZWRcbiAqIGJ5IHRoZSBicm93c2VyIHRvIG9jY3VyIGRpcmVjdGx5IGJlZm9yZSBhIHJlcGFpbnQsIHNjaGVkdWxpbmcgbW9yZSB0aGFuIG9uZSBhbmltYXRpb24gZnJhbWUgc3luY2hyb25vdXNseVxuICogc2hvdWxkIG5vdCBiZSBtdWNoIGRpZmZlcmVudCBvciBoYXZlIG1vcmUgb3ZlcmhlYWQgdGhhbiBsb29waW5nIG92ZXIgYW4gYXJyYXkgb2YgZXZlbnRzIGR1cmluZ1xuICogYSBzaW5nbGUgYW5pbWF0aW9uIGZyYW1lLiBIb3dldmVyLCBpZiBmb3Igc29tZSByZWFzb24gdGhlIGRldmVsb3BlciB3b3VsZCBsaWtlIHRvIGVuc3VyZSB0aGVcbiAqIGV4ZWN1dGlvbiBvZiBhbmltYXRpb24tcmVsYXRlZCBoYW5kbGVycyBhcmUgYWxsIGV4ZWN1dGVkIGR1cmluZyB0aGUgc2FtZSB0YXNrIGJ5IHRoZSBlbmdpbmUsXG4gKiB0aGUgYHNoYXJlYCBvcGVyYXRvciBjYW4gYmUgdXNlZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3Igc2V0dGluZyB1cCBhbmltYXRpb25zIHdpdGggUnhKUy5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIFR3ZWVuaW5nIGEgZGl2IHRvIG1vdmUgaXQgb24gdGhlIHNjcmVlblxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBhbmltYXRpb25GcmFtZXMsIG1hcCwgdGFrZVdoaWxlLCBlbmRXaXRoIH0gZnJvbSAncnhqcyc7XG4gKlxuICogZnVuY3Rpb24gdHdlZW4oc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXIpIHtcbiAqICAgY29uc3QgZGlmZiA9IGVuZCAtIHN0YXJ0O1xuICogICByZXR1cm4gYW5pbWF0aW9uRnJhbWVzKCkucGlwZShcbiAqICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgcGVyY2VudGFnZSBvZiB0aW1lIGhhcyBwYXNzZWRcbiAqICAgICBtYXAoKHsgZWxhcHNlZCB9KSA9PiBlbGFwc2VkIC8gZHVyYXRpb24pLFxuICogICAgIC8vIFRha2UgdGhlIHZlY3RvciB3aGlsZSBsZXNzIHRoYW4gMTAwJVxuICogICAgIHRha2VXaGlsZSh2ID0+IHYgPCAxKSxcbiAqICAgICAvLyBGaW5pc2ggd2l0aCAxMDAlXG4gKiAgICAgZW5kV2l0aCgxKSxcbiAqICAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRyYXZlbGVkIGJldHdlZW4gc3RhcnQgYW5kIGVuZFxuICogICAgIG1hcCh2ID0+IHYgKiBkaWZmICsgc3RhcnQpXG4gKiAgICk7XG4gKiB9XG4gKlxuICogLy8gU2V0dXAgYSBkaXYgZm9yIHVzIHRvIG1vdmUgYXJvdW5kXG4gKiBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAqIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gKiBkaXYuc3R5bGUud2lkdGggPSAnNDBweCc7XG4gKiBkaXYuc3R5bGUuaGVpZ2h0ID0gJzQwcHgnO1xuICogZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdsaW1lJztcbiAqIGRpdi5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMTBweCwgMCwgMCknO1xuICpcbiAqIHR3ZWVuKDEwLCAyMDAsIDQwMDApLnN1YnNjcmliZSh4ID0+IHtcbiAqICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgkeyB4IH1weCwgMCwgMClgO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBQcm92aWRpbmcgYSBjdXN0b20gdGltZXN0YW1wIHByb3ZpZGVyXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGFuaW1hdGlvbkZyYW1lcywgVGltZXN0YW1wUHJvdmlkZXIgfSBmcm9tICdyeGpzJztcbiAqXG4gKiAvLyBBIGN1c3RvbSB0aW1lc3RhbXAgcHJvdmlkZXJcbiAqIGxldCBub3cgPSAwO1xuICogY29uc3QgY3VzdG9tVFNQcm92aWRlcjogVGltZXN0YW1wUHJvdmlkZXIgPSB7XG4gKiAgIG5vdygpIHsgcmV0dXJuIG5vdysrOyB9XG4gKiB9O1xuICpcbiAqIGNvbnN0IHNvdXJjZSQgPSBhbmltYXRpb25GcmFtZXMoY3VzdG9tVFNQcm92aWRlcik7XG4gKlxuICogLy8gTG9nIGluY3JlYXNpbmcgbnVtYmVycyAwLi4uMS4uLjIuLi4gb24gZXZlcnkgYW5pbWF0aW9uIGZyYW1lLlxuICogc291cmNlJC5zdWJzY3JpYmUoKHsgZWxhcHNlZCB9KSA9PiBjb25zb2xlLmxvZyhlbGFwc2VkKSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdGltZXN0YW1wUHJvdmlkZXIgQW4gb2JqZWN0IHdpdGggYSBgbm93YCBtZXRob2QgdGhhdCBwcm92aWRlcyBhIG51bWVyaWMgdGltZXN0YW1wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmltYXRpb25GcmFtZXModGltZXN0YW1wUHJvdmlkZXI/OiBUaW1lc3RhbXBQcm92aWRlcikge1xuICByZXR1cm4gdGltZXN0YW1wUHJvdmlkZXIgPyBhbmltYXRpb25GcmFtZXNGYWN0b3J5KHRpbWVzdGFtcFByb3ZpZGVyKSA6IERFRkFVTFRfQU5JTUFUSU9OX0ZSQU1FUztcbn1cblxuLyoqXG4gKiBEb2VzIHRoZSB3b3JrIG9mIGNyZWF0aW5nIHRoZSBvYnNlcnZhYmxlIGZvciBgYW5pbWF0aW9uRnJhbWVzYC5cbiAqIEBwYXJhbSB0aW1lc3RhbXBQcm92aWRlciBUaGUgdGltZXN0YW1wIHByb3ZpZGVyIHRvIHVzZSB0byBjcmVhdGUgdGhlIG9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYW5pbWF0aW9uRnJhbWVzRmFjdG9yeSh0aW1lc3RhbXBQcm92aWRlcj86IFRpbWVzdGFtcFByb3ZpZGVyKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2YWJsZTx7IHRpbWVzdGFtcDogbnVtYmVyOyBlbGFwc2VkOiBudW1iZXIgfT4oKHN1YnNjcmliZXIpID0+IHtcbiAgICAvLyBJZiBubyB0aW1lc3RhbXAgcHJvdmlkZXIgaXMgc3BlY2lmaWVkLCB1c2UgcGVyZm9ybWFuY2Uubm93KCkgLSBhcyBpdFxuICAgIC8vIHdpbGwgcmV0dXJuIHRpbWVzdGFtcHMgJ2NvbXBhdGlibGUnIHdpdGggdGhvc2UgcGFzc2VkIHRvIHRoZSBydW5cbiAgICAvLyBjYWxsYmFjayBhbmQgd29uJ3QgYmUgYWZmZWN0ZWQgYnkgTlRQIGFkanVzdG1lbnRzLCBldGMuXG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aW1lc3RhbXBQcm92aWRlciB8fCBwZXJmb3JtYW5jZVRpbWVzdGFtcFByb3ZpZGVyO1xuXG4gICAgLy8gQ2FwdHVyZSB0aGUgc3RhcnQgdGltZSB1cG9uIHN1YnNjcmlwdGlvbiwgYXMgdGhlIHJ1biBjYWxsYmFjayBjYW4gcmVtYWluXG4gICAgLy8gcXVldWVkIGZvciBhIGNvbnNpZGVyYWJsZSBwZXJpb2Qgb2YgdGltZSBhbmQgdGhlIGVsYXBzZWQgdGltZSBzaG91bGRcbiAgICAvLyByZXByZXNlbnQgdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSBzdWJzY3JpcHRpb24gLSBub3QgdGhlIHRpbWUgc2luY2UgdGhlXG4gICAgLy8gZmlyc3QgcmVuZGVyZWQgYW5pbWF0aW9uIGZyYW1lLlxuICAgIGNvbnN0IHN0YXJ0ID0gcHJvdmlkZXIubm93KCk7XG5cbiAgICBsZXQgaWQgPSAwO1xuICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgaWQgPSBhbmltYXRpb25GcmFtZVByb3ZpZGVyLnJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wOiBET01IaWdoUmVzVGltZVN0YW1wIHwgbnVtYmVyKSA9PiB7XG4gICAgICAgICAgaWQgPSAwO1xuICAgICAgICAgIC8vIFVzZSB0aGUgcHJvdmlkZXIncyB0aW1lc3RhbXAgdG8gY2FsY3VsYXRlIHRoZSBlbGFwc2VkIHRpbWUuIE5vdGUgdGhhdFxuICAgICAgICAgIC8vIHRoaXMgbWVhbnMgLSBpZiB0aGUgY2FsbGVyIGhhc24ndCBwYXNzZWQgYSBwcm92aWRlciAtIHRoYXRcbiAgICAgICAgICAvLyBwZXJmb3JtYW5jZS5ub3coKSB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgdGltZXN0YW1wIHRoYXQgd2FzXG4gICAgICAgICAgLy8gcGFzc2VkIHRvIHRoZSBydW4gY2FsbGJhY2suIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCB0aGUgdGltZXN0YW1wXG4gICAgICAgICAgLy8gcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBjYW4gYmUgZWFybGllciB0aGFuIHRoZSBzdGFydCB0aW1lLCBhcyBpdFxuICAgICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIHRpbWUgYXQgd2hpY2ggdGhlIGJyb3dzZXIgZGVjaWRlZCBpdCB3b3VsZCByZW5kZXIgYW55XG4gICAgICAgICAgLy8gcXVldWVkIGZyYW1lcyAtIGFuZCB0aGF0IHRpbWUgY2FuIGJlIGVhcmxpZXIgdGhlIGNhcHR1cmVkIHN0YXJ0IHRpbWUuXG4gICAgICAgICAgY29uc3Qgbm93ID0gcHJvdmlkZXIubm93KCk7XG4gICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wUHJvdmlkZXIgPyBub3cgOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICBlbGFwc2VkOiBub3cgLSBzdGFydCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBydW4oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJ1bigpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChpZCkge1xuICAgICAgICBhbmltYXRpb25GcmFtZVByb3ZpZGVyLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbiB0aGUgY29tbW9uIGNhc2UsIHdoZXJlIHRoZSB0aW1lc3RhbXAgcHJvdmlkZWQgYnkgdGhlIHJBRiBBUEkgaXMgdXNlZCxcbiAqIHdlIHVzZSB0aGlzIHNoYXJlZCBvYnNlcnZhYmxlIHRvIHJlZHVjZSBvdmVyaGVhZC5cbiAqL1xuY29uc3QgREVGQVVMVF9BTklNQVRJT05fRlJBTUVTID0gYW5pbWF0aW9uRnJhbWVzRmFjdG9yeSgpO1xuIl19
