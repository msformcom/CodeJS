var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { createOperatorSubscriber } from '../../operators/OperatorSubscriber.mjs';
import { Observable } from '../../Observable.mjs';
import { innerFrom } from '../../observable/innerFrom.mjs';
/**
 * Uses [the Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) to
 * make an HTTP request.
 *
 * **WARNING** Parts of the fetch API are still experimental. `AbortController` is
 * required for this implementation to work and use cancellation appropriately.
 *
 * Will automatically set up an internal [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)
 * in order to finalize the internal `fetch` when the subscription tears down.
 *
 * If a `signal` is provided via the `init` argument, it will behave like it usually does with
 * `fetch`. If the provided `signal` aborts, the error that `fetch` normally rejects with
 * in that scenario will be emitted as an error from the observable.
 *
 * ## Examples
 *
 * Basic use
 *
 * ```ts
 * import { fromFetch } from 'rxjs/fetch';
 * import { switchMap, of, catchError } from 'rxjs';
 *
 * const data$ = fromFetch('https://api.github.com/users?per_page=5').pipe(
 *   switchMap(response => {
 *     if (response.ok) {
 *       // OK return data
 *       return response.json();
 *     } else {
 *       // Server is returning a status requiring the client to try something else.
 *       return of({ error: true, message: `Error ${ response.status }` });
 *     }
 *   }),
 *   catchError(err => {
 *     // Network or other error, handle appropriately
 *     console.error(err);
 *     return of({ error: true, message: err.message })
 *   })
 * );
 *
 * data$.subscribe({
 *   next: result => console.log(result),
 *   complete: () => console.log('done')
 * });
 * ```
 *
 * ### Use with Chunked Transfer Encoding
 *
 * With HTTP responses that use [chunked transfer encoding](https://tools.ietf.org/html/rfc7230#section-3.3.1),
 * the promise returned by `fetch` will resolve as soon as the response's headers are
 * received.
 *
 * That means the `fromFetch` observable will emit a `Response` - and will
 * then complete - before the body is received. When one of the methods on the
 * `Response` - like `text()` or `json()` - is called, the returned promise will not
 * resolve until the entire body has been received. Unsubscribing from any observable
 * that uses the promise as an observable input will not abort the request.
 *
 * To facilitate aborting the retrieval of responses that use chunked transfer encoding,
 * a `selector` can be specified via the `init` parameter:
 *
 * ```ts
 * import { of } from 'rxjs';
 * import { fromFetch } from 'rxjs/fetch';
 *
 * const data$ = fromFetch('https://api.github.com/users?per_page=5', {
 *   selector: response => response.json()
 * });
 *
 * data$.subscribe({
 *   next: result => console.log(result),
 *   complete: () => console.log('done')
 * });
 * ```
 *
 * @param input The resource you would like to fetch. Can be a url or a request object.
 * @param initWithSelector A configuration object for the fetch.
 * [See MDN for more details](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
 * @returns An Observable, that when subscribed to, performs an HTTP request using the native `fetch`
 * function. The {@link Subscription} is tied to an `AbortController` for the fetch.
 */
export function fromFetch(input, initWithSelector = {}) {
    const { selector } = initWithSelector, init = __rest(initWithSelector, ["selector"]);
    return new Observable((subscriber) => {
        // Our controller for aborting this fetch.
        // Any externally provided AbortSignal will have to call
        // abort on this controller when signaled, because the
        // signal from this controller is what is being passed to `fetch`.
        const controller = new AbortController();
        const { signal } = controller;
        // This flag exists to make sure we don't `abort()` the fetch upon tearing down
        // this observable after emitting a Response. Aborting in such circumstances
        // would also abort subsequent methods - like `json()` - that could be called
        // on the Response. Consider: `fromFetch().pipe(take(1), mergeMap(res => res.json()))`
        let abortable = true;
        // If the user provided an init configuration object,
        // let's process it and chain our abort signals, if necessary.
        // If a signal is provided, just have it finalized. It's a cancellation token, basically.
        const { signal: outerSignal } = init;
        if (outerSignal) {
            if (outerSignal.aborted) {
                controller.abort();
            }
            else {
                // We got an AbortSignal from the arguments passed into `fromFetch`.
                // We need to wire up our AbortController to abort when this signal aborts.
                const outerSignalHandler = () => {
                    if (!signal.aborted) {
                        controller.abort();
                    }
                };
                outerSignal.addEventListener('abort', outerSignalHandler);
                subscriber.add(() => outerSignal.removeEventListener('abort', outerSignalHandler));
            }
        }
        // The initialization object passed to `fetch` as the second
        // argument. This ferries in important information, including our
        // AbortSignal. Create a new init, so we don't accidentally mutate the
        // passed init, or reassign it. This is because the init passed in
        // is shared between each subscription to the result.
        const perSubscriberInit = Object.assign(Object.assign({}, init), { signal });
        const handleError = (err) => {
            abortable = false;
            subscriber.error(err);
        };
        fetch(input, perSubscriberInit)
            .then((response) => {
            if (selector) {
                // If we have a selector function, use it to project our response.
                // Note that any error that comes from our selector will be
                // sent to the promise `catch` below and handled.
                innerFrom(selector(response)).subscribe(createOperatorSubscriber(subscriber, 
                // Values are passed through to the subscriber
                undefined, 
                // The projected response is complete.
                () => {
                    abortable = false;
                    subscriber.complete();
                }, handleError));
            }
            else {
                abortable = false;
                subscriber.next(response);
                subscriber.complete();
            }
        })
            .catch(handleError);
        return () => {
            if (abortable) {
                controller.abort();
            }
        };
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS9mZXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQzlFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFZdkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErRUc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUN2QixLQUF1QixFQUN2QixtQkFFSSxFQUFFO0lBRU4sTUFBTSxFQUFFLFFBQVEsS0FBYyxnQkFBZ0IsRUFBekIsSUFBSSxVQUFLLGdCQUFnQixFQUF4QyxZQUFxQixDQUFtQixDQUFDO0lBQy9DLE9BQU8sSUFBSSxVQUFVLENBQWUsQ0FBQyxVQUFVLEVBQUUsRUFBRTtRQUNqRCwwQ0FBMEM7UUFDMUMsd0RBQXdEO1FBQ3hELHNEQUFzRDtRQUN0RCxrRUFBa0U7UUFDbEUsTUFBTSxVQUFVLEdBQUcsSUFBSSxlQUFlLEVBQUUsQ0FBQztRQUN6QyxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsVUFBVSxDQUFDO1FBQzlCLCtFQUErRTtRQUMvRSw0RUFBNEU7UUFDNUUsNkVBQTZFO1FBQzdFLHNGQUFzRjtRQUN0RixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUM7UUFFckIscURBQXFEO1FBQ3JELDhEQUE4RDtRQUM5RCx5RkFBeUY7UUFDekYsTUFBTSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDckMsSUFBSSxXQUFXLEVBQUUsQ0FBQztZQUNoQixJQUFJLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDeEIsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3JCLENBQUM7aUJBQU0sQ0FBQztnQkFDTixvRUFBb0U7Z0JBQ3BFLDJFQUEyRTtnQkFDM0UsTUFBTSxrQkFBa0IsR0FBRyxHQUFHLEVBQUU7b0JBQzlCLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7d0JBQ3BCLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDckIsQ0FBQztnQkFDSCxDQUFDLENBQUM7Z0JBQ0YsV0FBVyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO2dCQUMxRCxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO1lBQ3JGLENBQUM7UUFDSCxDQUFDO1FBRUQsNERBQTREO1FBQzVELGlFQUFpRTtRQUNqRSxzRUFBc0U7UUFDdEUsa0VBQWtFO1FBQ2xFLHFEQUFxRDtRQUNyRCxNQUFNLGlCQUFpQixtQ0FBcUIsSUFBSSxLQUFFLE1BQU0sR0FBRSxDQUFDO1FBRTNELE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBUSxFQUFFLEVBQUU7WUFDL0IsU0FBUyxHQUFHLEtBQUssQ0FBQztZQUNsQixVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLENBQUMsQ0FBQztRQUVGLEtBQUssQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUM7YUFDNUIsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDakIsSUFBSSxRQUFRLEVBQUUsQ0FBQztnQkFDYixrRUFBa0U7Z0JBQ2xFLDJEQUEyRDtnQkFDM0QsaURBQWlEO2dCQUNqRCxTQUFTLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUNyQyx3QkFBd0IsQ0FDdEIsVUFBVTtnQkFDViw4Q0FBOEM7Z0JBQzlDLFNBQVM7Z0JBQ1Qsc0NBQXNDO2dCQUN0QyxHQUFHLEVBQUU7b0JBQ0gsU0FBUyxHQUFHLEtBQUssQ0FBQztvQkFDbEIsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUN4QixDQUFDLEVBQ0QsV0FBVyxDQUNaLENBQ0YsQ0FBQztZQUNKLENBQUM7aUJBQU0sQ0FBQztnQkFDTixTQUFTLEdBQUcsS0FBSyxDQUFDO2dCQUNsQixVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUMxQixVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDeEIsQ0FBQztRQUNILENBQUMsQ0FBQzthQUNELEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUV0QixPQUFPLEdBQUcsRUFBRTtZQUNWLElBQUksU0FBUyxFQUFFLENBQUM7Z0JBQ2QsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3JCLENBQUM7UUFDSCxDQUFDLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29ic2VydmFibGUvZG9tL2ZldGNoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpbm5lckZyb20gfSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlL2lubmVyRnJvbSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRmV0Y2g8VD4oXG4gIGlucHV0OiBzdHJpbmcgfCBSZXF1ZXN0LFxuICBpbml0OiBSZXF1ZXN0SW5pdCAmIHtcbiAgICBzZWxlY3RvcjogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gT2JzZXJ2YWJsZUlucHV0PFQ+O1xuICB9XG4pOiBPYnNlcnZhYmxlPFQ+O1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUZldGNoKGlucHV0OiBzdHJpbmcgfCBSZXF1ZXN0LCBpbml0PzogUmVxdWVzdEluaXQpOiBPYnNlcnZhYmxlPFJlc3BvbnNlPjtcblxuLyoqXG4gKiBVc2VzIFt0aGUgRmV0Y2ggQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJKSB0b1xuICogbWFrZSBhbiBIVFRQIHJlcXVlc3QuXG4gKlxuICogKipXQVJOSU5HKiogUGFydHMgb2YgdGhlIGZldGNoIEFQSSBhcmUgc3RpbGwgZXhwZXJpbWVudGFsLiBgQWJvcnRDb250cm9sbGVyYCBpc1xuICogcmVxdWlyZWQgZm9yIHRoaXMgaW1wbGVtZW50YXRpb24gdG8gd29yayBhbmQgdXNlIGNhbmNlbGxhdGlvbiBhcHByb3ByaWF0ZWx5LlxuICpcbiAqIFdpbGwgYXV0b21hdGljYWxseSBzZXQgdXAgYW4gaW50ZXJuYWwgW0Fib3J0Q29udHJvbGxlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0Q29udHJvbGxlcilcbiAqIGluIG9yZGVyIHRvIGZpbmFsaXplIHRoZSBpbnRlcm5hbCBgZmV0Y2hgIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiB0ZWFycyBkb3duLlxuICpcbiAqIElmIGEgYHNpZ25hbGAgaXMgcHJvdmlkZWQgdmlhIHRoZSBgaW5pdGAgYXJndW1lbnQsIGl0IHdpbGwgYmVoYXZlIGxpa2UgaXQgdXN1YWxseSBkb2VzIHdpdGhcbiAqIGBmZXRjaGAuIElmIHRoZSBwcm92aWRlZCBgc2lnbmFsYCBhYm9ydHMsIHRoZSBlcnJvciB0aGF0IGBmZXRjaGAgbm9ybWFsbHkgcmVqZWN0cyB3aXRoXG4gKiBpbiB0aGF0IHNjZW5hcmlvIHdpbGwgYmUgZW1pdHRlZCBhcyBhbiBlcnJvciBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICpcbiAqICMjIEV4YW1wbGVzXG4gKlxuICogQmFzaWMgdXNlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21GZXRjaCB9IGZyb20gJ3J4anMvZmV0Y2gnO1xuICogaW1wb3J0IHsgc3dpdGNoTWFwLCBvZiwgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IGRhdGEkID0gZnJvbUZldGNoKCdodHRwczovL2FwaS5naXRodWIuY29tL3VzZXJzP3Blcl9wYWdlPTUnKS5waXBlKFxuICogICBzd2l0Y2hNYXAocmVzcG9uc2UgPT4ge1xuICogICAgIGlmIChyZXNwb25zZS5vaykge1xuICogICAgICAgLy8gT0sgcmV0dXJuIGRhdGFcbiAqICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIC8vIFNlcnZlciBpcyByZXR1cm5pbmcgYSBzdGF0dXMgcmVxdWlyaW5nIHRoZSBjbGllbnQgdG8gdHJ5IHNvbWV0aGluZyBlbHNlLlxuICogICAgICAgcmV0dXJuIG9mKHsgZXJyb3I6IHRydWUsIG1lc3NhZ2U6IGBFcnJvciAkeyByZXNwb25zZS5zdGF0dXMgfWAgfSk7XG4gKiAgICAgfVxuICogICB9KSxcbiAqICAgY2F0Y2hFcnJvcihlcnIgPT4ge1xuICogICAgIC8vIE5ldHdvcmsgb3Igb3RoZXIgZXJyb3IsIGhhbmRsZSBhcHByb3ByaWF0ZWx5XG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICogICAgIHJldHVybiBvZih7IGVycm9yOiB0cnVlLCBtZXNzYWdlOiBlcnIubWVzc2FnZSB9KVxuICogICB9KVxuICogKTtcbiAqXG4gKiBkYXRhJC5zdWJzY3JpYmUoe1xuICogICBuZXh0OiByZXN1bHQgPT4gY29uc29sZS5sb2cocmVzdWx0KSxcbiAqICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKCdkb25lJylcbiAqIH0pO1xuICogYGBgXG4gKlxuICogIyMjIFVzZSB3aXRoIENodW5rZWQgVHJhbnNmZXIgRW5jb2RpbmdcbiAqXG4gKiBXaXRoIEhUVFAgcmVzcG9uc2VzIHRoYXQgdXNlIFtjaHVua2VkIHRyYW5zZmVyIGVuY29kaW5nXShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4xKSxcbiAqIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IGBmZXRjaGAgd2lsbCByZXNvbHZlIGFzIHNvb24gYXMgdGhlIHJlc3BvbnNlJ3MgaGVhZGVycyBhcmVcbiAqIHJlY2VpdmVkLlxuICpcbiAqIFRoYXQgbWVhbnMgdGhlIGBmcm9tRmV0Y2hgIG9ic2VydmFibGUgd2lsbCBlbWl0IGEgYFJlc3BvbnNlYCAtIGFuZCB3aWxsXG4gKiB0aGVuIGNvbXBsZXRlIC0gYmVmb3JlIHRoZSBib2R5IGlzIHJlY2VpdmVkLiBXaGVuIG9uZSBvZiB0aGUgbWV0aG9kcyBvbiB0aGVcbiAqIGBSZXNwb25zZWAgLSBsaWtlIGB0ZXh0KClgIG9yIGBqc29uKClgIC0gaXMgY2FsbGVkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIG5vdFxuICogcmVzb2x2ZSB1bnRpbCB0aGUgZW50aXJlIGJvZHkgaGFzIGJlZW4gcmVjZWl2ZWQuIFVuc3Vic2NyaWJpbmcgZnJvbSBhbnkgb2JzZXJ2YWJsZVxuICogdGhhdCB1c2VzIHRoZSBwcm9taXNlIGFzIGFuIG9ic2VydmFibGUgaW5wdXQgd2lsbCBub3QgYWJvcnQgdGhlIHJlcXVlc3QuXG4gKlxuICogVG8gZmFjaWxpdGF0ZSBhYm9ydGluZyB0aGUgcmV0cmlldmFsIG9mIHJlc3BvbnNlcyB0aGF0IHVzZSBjaHVua2VkIHRyYW5zZmVyIGVuY29kaW5nLFxuICogYSBgc2VsZWN0b3JgIGNhbiBiZSBzcGVjaWZpZWQgdmlhIHRoZSBgaW5pdGAgcGFyYW1ldGVyOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMnO1xuICogaW1wb3J0IHsgZnJvbUZldGNoIH0gZnJvbSAncnhqcy9mZXRjaCc7XG4gKlxuICogY29uc3QgZGF0YSQgPSBmcm9tRmV0Y2goJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vdXNlcnM/cGVyX3BhZ2U9NScsIHtcbiAqICAgc2VsZWN0b3I6IHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKVxuICogfSk7XG4gKlxuICogZGF0YSQuc3Vic2NyaWJlKHtcbiAqICAgbmV4dDogcmVzdWx0ID0+IGNvbnNvbGUubG9nKHJlc3VsdCksXG4gKiAgIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnZG9uZScpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBpbnB1dCBUaGUgcmVzb3VyY2UgeW91IHdvdWxkIGxpa2UgdG8gZmV0Y2guIENhbiBiZSBhIHVybCBvciBhIHJlcXVlc3Qgb2JqZWN0LlxuICogQHBhcmFtIGluaXRXaXRoU2VsZWN0b3IgQSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIGZldGNoLlxuICogW1NlZSBNRE4gZm9yIG1vcmUgZGV0YWlsc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd09yV29ya2VyR2xvYmFsU2NvcGUvZmV0Y2gjUGFyYW1ldGVycylcbiAqIEByZXR1cm5zIEFuIE9ic2VydmFibGUsIHRoYXQgd2hlbiBzdWJzY3JpYmVkIHRvLCBwZXJmb3JtcyBhbiBIVFRQIHJlcXVlc3QgdXNpbmcgdGhlIG5hdGl2ZSBgZmV0Y2hgXG4gKiBmdW5jdGlvbi4gVGhlIHtAbGluayBTdWJzY3JpcHRpb259IGlzIHRpZWQgdG8gYW4gYEFib3J0Q29udHJvbGxlcmAgZm9yIHRoZSBmZXRjaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21GZXRjaDxUPihcbiAgaW5wdXQ6IHN0cmluZyB8IFJlcXVlc3QsXG4gIGluaXRXaXRoU2VsZWN0b3I6IFJlcXVlc3RJbml0ICYge1xuICAgIHNlbGVjdG9yPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gT2JzZXJ2YWJsZUlucHV0PFQ+O1xuICB9ID0ge31cbik6IE9ic2VydmFibGU8UmVzcG9uc2UgfCBUPiB7XG4gIGNvbnN0IHsgc2VsZWN0b3IsIC4uLmluaXQgfSA9IGluaXRXaXRoU2VsZWN0b3I7XG4gIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxSZXNwb25zZSB8IFQ+KChzdWJzY3JpYmVyKSA9PiB7XG4gICAgLy8gT3VyIGNvbnRyb2xsZXIgZm9yIGFib3J0aW5nIHRoaXMgZmV0Y2guXG4gICAgLy8gQW55IGV4dGVybmFsbHkgcHJvdmlkZWQgQWJvcnRTaWduYWwgd2lsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyBhYm9ydCBvbiB0aGlzIGNvbnRyb2xsZXIgd2hlbiBzaWduYWxlZCwgYmVjYXVzZSB0aGVcbiAgICAvLyBzaWduYWwgZnJvbSB0aGlzIGNvbnRyb2xsZXIgaXMgd2hhdCBpcyBiZWluZyBwYXNzZWQgdG8gYGZldGNoYC5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBjb250cm9sbGVyO1xuICAgIC8vIFRoaXMgZmxhZyBleGlzdHMgdG8gbWFrZSBzdXJlIHdlIGRvbid0IGBhYm9ydCgpYCB0aGUgZmV0Y2ggdXBvbiB0ZWFyaW5nIGRvd25cbiAgICAvLyB0aGlzIG9ic2VydmFibGUgYWZ0ZXIgZW1pdHRpbmcgYSBSZXNwb25zZS4gQWJvcnRpbmcgaW4gc3VjaCBjaXJjdW1zdGFuY2VzXG4gICAgLy8gd291bGQgYWxzbyBhYm9ydCBzdWJzZXF1ZW50IG1ldGhvZHMgLSBsaWtlIGBqc29uKClgIC0gdGhhdCBjb3VsZCBiZSBjYWxsZWRcbiAgICAvLyBvbiB0aGUgUmVzcG9uc2UuIENvbnNpZGVyOiBgZnJvbUZldGNoKCkucGlwZSh0YWtlKDEpLCBtZXJnZU1hcChyZXMgPT4gcmVzLmpzb24oKSkpYFxuICAgIGxldCBhYm9ydGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYW4gaW5pdCBjb25maWd1cmF0aW9uIG9iamVjdCxcbiAgICAvLyBsZXQncyBwcm9jZXNzIGl0IGFuZCBjaGFpbiBvdXIgYWJvcnQgc2lnbmFscywgaWYgbmVjZXNzYXJ5LlxuICAgIC8vIElmIGEgc2lnbmFsIGlzIHByb3ZpZGVkLCBqdXN0IGhhdmUgaXQgZmluYWxpemVkLiBJdCdzIGEgY2FuY2VsbGF0aW9uIHRva2VuLCBiYXNpY2FsbHkuXG4gICAgY29uc3QgeyBzaWduYWw6IG91dGVyU2lnbmFsIH0gPSBpbml0O1xuICAgIGlmIChvdXRlclNpZ25hbCkge1xuICAgICAgaWYgKG91dGVyU2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgZ290IGFuIEFib3J0U2lnbmFsIGZyb20gdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byBgZnJvbUZldGNoYC5cbiAgICAgICAgLy8gV2UgbmVlZCB0byB3aXJlIHVwIG91ciBBYm9ydENvbnRyb2xsZXIgdG8gYWJvcnQgd2hlbiB0aGlzIHNpZ25hbCBhYm9ydHMuXG4gICAgICAgIGNvbnN0IG91dGVyU2lnbmFsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBvdXRlclNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG91dGVyU2lnbmFsSGFuZGxlcik7XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKCgpID0+IG91dGVyU2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb3V0ZXJTaWduYWxIYW5kbGVyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGluaXRpYWxpemF0aW9uIG9iamVjdCBwYXNzZWQgdG8gYGZldGNoYCBhcyB0aGUgc2Vjb25kXG4gICAgLy8gYXJndW1lbnQuIFRoaXMgZmVycmllcyBpbiBpbXBvcnRhbnQgaW5mb3JtYXRpb24sIGluY2x1ZGluZyBvdXJcbiAgICAvLyBBYm9ydFNpZ25hbC4gQ3JlYXRlIGEgbmV3IGluaXQsIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBtdXRhdGUgdGhlXG4gICAgLy8gcGFzc2VkIGluaXQsIG9yIHJlYXNzaWduIGl0LiBUaGlzIGlzIGJlY2F1c2UgdGhlIGluaXQgcGFzc2VkIGluXG4gICAgLy8gaXMgc2hhcmVkIGJldHdlZW4gZWFjaCBzdWJzY3JpcHRpb24gdG8gdGhlIHJlc3VsdC5cbiAgICBjb25zdCBwZXJTdWJzY3JpYmVySW5pdDogUmVxdWVzdEluaXQgPSB7IC4uLmluaXQsIHNpZ25hbCB9O1xuXG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyOiBhbnkpID0+IHtcbiAgICAgIGFib3J0YWJsZSA9IGZhbHNlO1xuICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgIH07XG5cbiAgICBmZXRjaChpbnB1dCwgcGVyU3Vic2NyaWJlckluaXQpXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHNlbGVjdG9yIGZ1bmN0aW9uLCB1c2UgaXQgdG8gcHJvamVjdCBvdXIgcmVzcG9uc2UuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IGFueSBlcnJvciB0aGF0IGNvbWVzIGZyb20gb3VyIHNlbGVjdG9yIHdpbGwgYmVcbiAgICAgICAgICAvLyBzZW50IHRvIHRoZSBwcm9taXNlIGBjYXRjaGAgYmVsb3cgYW5kIGhhbmRsZWQuXG4gICAgICAgICAgaW5uZXJGcm9tKHNlbGVjdG9yKHJlc3BvbnNlKSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICAgICAgICBzdWJzY3JpYmVyLFxuICAgICAgICAgICAgICAvLyBWYWx1ZXMgYXJlIHBhc3NlZCB0aHJvdWdoIHRvIHRoZSBzdWJzY3JpYmVyXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgLy8gVGhlIHByb2plY3RlZCByZXNwb25zZSBpcyBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFib3J0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaGFuZGxlRXJyb3JcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFib3J0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXNwb25zZSk7XG4gICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGhhbmRsZUVycm9yKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoYWJvcnRhYmxlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cbiJdfQ==
