import { isScheduler } from '../util/isScheduler.mjs';
import { Observable } from '../Observable.mjs';
import { subscribeOn } from '../operators/subscribeOn.mjs';
import { mapOneOrManyArgs } from '../util/mapOneOrManyArgs.mjs';
import { observeOn } from '../operators/observeOn.mjs';
import { AsyncSubject } from '../AsyncSubject.mjs';
export function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            // The user provided a result selector.
            return function (...args) {
                return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler)
                    .apply(this, args)
                    .pipe(mapOneOrManyArgs(resultSelector));
            };
        }
    }
    // If a scheduler was passed, use our `subscribeOn` and `observeOn` operators
    // to compose that behavior for the user.
    if (scheduler) {
        return function (...args) {
            return bindCallbackInternals(isNodeStyle, callbackFunc)
                .apply(this, args)
                .pipe(subscribeOn(scheduler), observeOn(scheduler));
        };
    }
    return function (...args) {
        // We're using AsyncSubject, because it emits when it completes,
        // and it will play the value to all late-arriving subscribers.
        const subject = new AsyncSubject();
        // If this is true, then we haven't called our function yet.
        let uninitialized = true;
        return new Observable((subscriber) => {
            // Add our subscriber to the subject.
            const subs = subject.subscribe(subscriber);
            if (uninitialized) {
                uninitialized = false;
                // We're going to execute the bound function
                // This bit is to signal that we are hitting the callback asynchronously.
                // Because we don't have any anti-"Zalgo" guarantees with whatever
                // function we are handed, we use this bit to figure out whether or not
                // we are getting hit in a callback synchronously during our call.
                let isAsync = false;
                // This is used to signal that the callback completed synchronously.
                let isComplete = false;
                // Call our function that has a callback. If at any time during this
                // call, an error is thrown, it will be caught by the Observable
                // subscription process and sent to the consumer.
                callbackFunc.apply(
                // Pass the appropriate `this` context.
                this, [
                    // Pass the arguments.
                    ...args,
                    // And our callback handler.
                    (...results) => {
                        if (isNodeStyle) {
                            // If this is a node callback, shift the first value off of the
                            // results and check it, as it is the error argument. By shifting,
                            // we leave only the argument(s) we want to pass to the consumer.
                            const err = results.shift();
                            if (err != null) {
                                subject.error(err);
                                // If we've errored, we can stop processing this function
                                // as there's nothing else to do. Just return to escape.
                                return;
                            }
                        }
                        // If we have one argument, notify the consumer
                        // of it as a single value, otherwise, if there's more than one, pass
                        // them as an array. Note that if there are no arguments, `undefined`
                        // will be emitted.
                        subject.next(1 < results.length ? results : results[0]);
                        // Flip this flag, so we know we can complete it in the synchronous
                        // case below.
                        isComplete = true;
                        // If we're not asynchronous, we need to defer the `complete` call
                        // until after the call to the function is over. This is because an
                        // error could be thrown in the function after it calls our callback,
                        // and if that is the case, if we complete here, we are unable to notify
                        // the consumer than an error occurred.
                        if (isAsync) {
                            subject.complete();
                        }
                    },
                ]);
                // If we flipped `isComplete` during the call, we resolved synchronously,
                // notify complete, because we skipped it in the callback to wait
                // to make sure there were no errors during the call.
                if (isComplete) {
                    subject.complete();
                }
                // We're no longer synchronous. If the callback is called at this point
                // we can notify complete on the spot.
                isAsync = true;
            }
            // Return the subscription from adding our subscriber to the subject.
            return subs;
        });
    };
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFja0ludGVybmFscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDbEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDdkQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDNUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ25ELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUvQyxNQUFNLFVBQVUscUJBQXFCLENBQ25DLFdBQW9CLEVBQ3BCLFlBQWlCLEVBQ2pCLGNBQW9CLEVBQ3BCLFNBQXlCO0lBRXpCLElBQUksY0FBYyxFQUFFLENBQUM7UUFDbkIsSUFBSSxXQUFXLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQztZQUNoQyxTQUFTLEdBQUcsY0FBYyxDQUFDO1FBQzdCLENBQUM7YUFBTSxDQUFDO1lBQ04sdUNBQXVDO1lBQ3ZDLE9BQU8sVUFBcUIsR0FBRyxJQUFXO2dCQUN4QyxPQUFRLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFTO3FCQUN4RSxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztxQkFDakIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGNBQXFCLENBQUMsQ0FBQyxDQUFDO1lBQ25ELENBQUMsQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0lBRUQsNkVBQTZFO0lBQzdFLHlDQUF5QztJQUN6QyxJQUFJLFNBQVMsRUFBRSxDQUFDO1FBQ2QsT0FBTyxVQUFxQixHQUFHLElBQVc7WUFDeEMsT0FBUSxxQkFBcUIsQ0FBQyxXQUFXLEVBQUUsWUFBWSxDQUFTO2lCQUM3RCxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztpQkFDakIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFVLENBQUMsRUFBRSxTQUFTLENBQUMsU0FBVSxDQUFDLENBQUMsQ0FBQztRQUMxRCxDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsT0FBTyxVQUFxQixHQUFHLElBQVc7UUFDeEMsZ0VBQWdFO1FBQ2hFLCtEQUErRDtRQUMvRCxNQUFNLE9BQU8sR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDO1FBRXhDLDREQUE0RDtRQUM1RCxJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUM7UUFDekIsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQ25DLHFDQUFxQztZQUNyQyxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBRTNDLElBQUksYUFBYSxFQUFFLENBQUM7Z0JBQ2xCLGFBQWEsR0FBRyxLQUFLLENBQUM7Z0JBQ3RCLDRDQUE0QztnQkFDNUMseUVBQXlFO2dCQUN6RSxrRUFBa0U7Z0JBQ2xFLHVFQUF1RTtnQkFDdkUsa0VBQWtFO2dCQUNsRSxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7Z0JBRXBCLG9FQUFvRTtnQkFDcEUsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO2dCQUV2QixvRUFBb0U7Z0JBQ3BFLGdFQUFnRTtnQkFDaEUsaURBQWlEO2dCQUNqRCxZQUFZLENBQUMsS0FBSztnQkFDaEIsdUNBQXVDO2dCQUN2QyxJQUFJLEVBQ0o7b0JBQ0Usc0JBQXNCO29CQUN0QixHQUFHLElBQUk7b0JBQ1AsNEJBQTRCO29CQUM1QixDQUFDLEdBQUcsT0FBYyxFQUFFLEVBQUU7d0JBQ3BCLElBQUksV0FBVyxFQUFFLENBQUM7NEJBQ2hCLCtEQUErRDs0QkFDL0Qsa0VBQWtFOzRCQUNsRSxpRUFBaUU7NEJBQ2pFLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQzs0QkFDNUIsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7Z0NBQ2hCLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7Z0NBQ25CLHlEQUF5RDtnQ0FDekQsd0RBQXdEO2dDQUN4RCxPQUFPOzRCQUNULENBQUM7d0JBQ0gsQ0FBQzt3QkFDRCwrQ0FBK0M7d0JBQy9DLHFFQUFxRTt3QkFDckUscUVBQXFFO3dCQUNyRSxtQkFBbUI7d0JBQ25CLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3hELG1FQUFtRTt3QkFDbkUsY0FBYzt3QkFDZCxVQUFVLEdBQUcsSUFBSSxDQUFDO3dCQUNsQixrRUFBa0U7d0JBQ2xFLG1FQUFtRTt3QkFDbkUscUVBQXFFO3dCQUNyRSx3RUFBd0U7d0JBQ3hFLHVDQUF1Qzt3QkFDdkMsSUFBSSxPQUFPLEVBQUUsQ0FBQzs0QkFDWixPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7d0JBQ3JCLENBQUM7b0JBQ0gsQ0FBQztpQkFDRixDQUNGLENBQUM7Z0JBQ0YseUVBQXlFO2dCQUN6RSxpRUFBaUU7Z0JBQ2pFLHFEQUFxRDtnQkFDckQsSUFBSSxVQUFVLEVBQUUsQ0FBQztvQkFDZixPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ3JCLENBQUM7Z0JBRUQsdUVBQXVFO2dCQUN2RSxzQ0FBc0M7Z0JBQ3RDLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDakIsQ0FBQztZQUVELHFFQUFxRTtZQUNyRSxPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2tJbnRlcm5hbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY2hlZHVsZXJMaWtlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2lzU2NoZWR1bGVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHN1YnNjcmliZU9uIH0gZnJvbSAnLi4vb3BlcmF0b3JzL3N1YnNjcmliZU9uJztcbmltcG9ydCB7IG1hcE9uZU9yTWFueUFyZ3MgfSBmcm9tICcuLi91dGlsL21hcE9uZU9yTWFueUFyZ3MnO1xuaW1wb3J0IHsgb2JzZXJ2ZU9uIH0gZnJvbSAnLi4vb3BlcmF0b3JzL29ic2VydmVPbic7XG5pbXBvcnQgeyBBc3luY1N1YmplY3QgfSBmcm9tICcuLi9Bc3luY1N1YmplY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gYmluZENhbGxiYWNrSW50ZXJuYWxzKFxuICBpc05vZGVTdHlsZTogYm9vbGVhbixcbiAgY2FsbGJhY2tGdW5jOiBhbnksXG4gIHJlc3VsdFNlbGVjdG9yPzogYW55LFxuICBzY2hlZHVsZXI/OiBTY2hlZHVsZXJMaWtlXG4pOiAoLi4uYXJnczogYW55W10pID0+IE9ic2VydmFibGU8dW5rbm93bj4ge1xuICBpZiAocmVzdWx0U2VsZWN0b3IpIHtcbiAgICBpZiAoaXNTY2hlZHVsZXIocmVzdWx0U2VsZWN0b3IpKSB7XG4gICAgICBzY2hlZHVsZXIgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHVzZXIgcHJvdmlkZWQgYSByZXN1bHQgc2VsZWN0b3IuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXM6IGFueSwgLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgcmV0dXJuIChiaW5kQ2FsbGJhY2tJbnRlcm5hbHMoaXNOb2RlU3R5bGUsIGNhbGxiYWNrRnVuYywgc2NoZWR1bGVyKSBhcyBhbnkpXG4gICAgICAgICAgLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgLnBpcGUobWFwT25lT3JNYW55QXJncyhyZXN1bHRTZWxlY3RvciBhcyBhbnkpKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSBzY2hlZHVsZXIgd2FzIHBhc3NlZCwgdXNlIG91ciBgc3Vic2NyaWJlT25gIGFuZCBgb2JzZXJ2ZU9uYCBvcGVyYXRvcnNcbiAgLy8gdG8gY29tcG9zZSB0aGF0IGJlaGF2aW9yIGZvciB0aGUgdXNlci5cbiAgaWYgKHNjaGVkdWxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSkge1xuICAgICAgcmV0dXJuIChiaW5kQ2FsbGJhY2tJbnRlcm5hbHMoaXNOb2RlU3R5bGUsIGNhbGxiYWNrRnVuYykgYXMgYW55KVxuICAgICAgICAuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgLnBpcGUoc3Vic2NyaWJlT24oc2NoZWR1bGVyISksIG9ic2VydmVPbihzY2hlZHVsZXIhKSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAodGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgLy8gV2UncmUgdXNpbmcgQXN5bmNTdWJqZWN0LCBiZWNhdXNlIGl0IGVtaXRzIHdoZW4gaXQgY29tcGxldGVzLFxuICAgIC8vIGFuZCBpdCB3aWxsIHBsYXkgdGhlIHZhbHVlIHRvIGFsbCBsYXRlLWFycml2aW5nIHN1YnNjcmliZXJzLlxuICAgIGNvbnN0IHN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0PGFueT4oKTtcblxuICAgIC8vIElmIHRoaXMgaXMgdHJ1ZSwgdGhlbiB3ZSBoYXZlbid0IGNhbGxlZCBvdXIgZnVuY3Rpb24geWV0LlxuICAgIGxldCB1bmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcbiAgICAgIC8vIEFkZCBvdXIgc3Vic2NyaWJlciB0byB0aGUgc3ViamVjdC5cbiAgICAgIGNvbnN0IHN1YnMgPSBzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcblxuICAgICAgaWYgKHVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdW5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBleGVjdXRlIHRoZSBib3VuZCBmdW5jdGlvblxuICAgICAgICAvLyBUaGlzIGJpdCBpcyB0byBzaWduYWwgdGhhdCB3ZSBhcmUgaGl0dGluZyB0aGUgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgYW50aS1cIlphbGdvXCIgZ3VhcmFudGVlcyB3aXRoIHdoYXRldmVyXG4gICAgICAgIC8vIGZ1bmN0aW9uIHdlIGFyZSBoYW5kZWQsIHdlIHVzZSB0aGlzIGJpdCB0byBmaWd1cmUgb3V0IHdoZXRoZXIgb3Igbm90XG4gICAgICAgIC8vIHdlIGFyZSBnZXR0aW5nIGhpdCBpbiBhIGNhbGxiYWNrIHN5bmNocm9ub3VzbHkgZHVyaW5nIG91ciBjYWxsLlxuICAgICAgICBsZXQgaXNBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzaWduYWwgdGhhdCB0aGUgY2FsbGJhY2sgY29tcGxldGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICAgIGxldCBpc0NvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ2FsbCBvdXIgZnVuY3Rpb24gdGhhdCBoYXMgYSBjYWxsYmFjay4gSWYgYXQgYW55IHRpbWUgZHVyaW5nIHRoaXNcbiAgICAgICAgLy8gY2FsbCwgYW4gZXJyb3IgaXMgdGhyb3duLCBpdCB3aWxsIGJlIGNhdWdodCBieSB0aGUgT2JzZXJ2YWJsZVxuICAgICAgICAvLyBzdWJzY3JpcHRpb24gcHJvY2VzcyBhbmQgc2VudCB0byB0aGUgY29uc3VtZXIuXG4gICAgICAgIGNhbGxiYWNrRnVuYy5hcHBseShcbiAgICAgICAgICAvLyBQYXNzIHRoZSBhcHByb3ByaWF0ZSBgdGhpc2AgY29udGV4dC5cbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIC8vIFBhc3MgdGhlIGFyZ3VtZW50cy5cbiAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAvLyBBbmQgb3VyIGNhbGxiYWNrIGhhbmRsZXIuXG4gICAgICAgICAgICAoLi4ucmVzdWx0czogYW55W10pID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlzTm9kZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5vZGUgY2FsbGJhY2ssIHNoaWZ0IHRoZSBmaXJzdCB2YWx1ZSBvZmYgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0cyBhbmQgY2hlY2sgaXQsIGFzIGl0IGlzIHRoZSBlcnJvciBhcmd1bWVudC4gQnkgc2hpZnRpbmcsXG4gICAgICAgICAgICAgICAgLy8gd2UgbGVhdmUgb25seSB0aGUgYXJndW1lbnQocykgd2Ugd2FudCB0byBwYXNzIHRvIHRoZSBjb25zdW1lci5cbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSByZXN1bHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBlcnJvcmVkLCB3ZSBjYW4gc3RvcCBwcm9jZXNzaW5nIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZXJlJ3Mgbm90aGluZyBlbHNlIHRvIGRvLiBKdXN0IHJldHVybiB0byBlc2NhcGUuXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgb25lIGFyZ3VtZW50LCBub3RpZnkgdGhlIGNvbnN1bWVyXG4gICAgICAgICAgICAgIC8vIG9mIGl0IGFzIGEgc2luZ2xlIHZhbHVlLCBvdGhlcndpc2UsIGlmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSwgcGFzc1xuICAgICAgICAgICAgICAvLyB0aGVtIGFzIGFuIGFycmF5LiBOb3RlIHRoYXQgaWYgdGhlcmUgYXJlIG5vIGFyZ3VtZW50cywgYHVuZGVmaW5lZGBcbiAgICAgICAgICAgICAgLy8gd2lsbCBiZSBlbWl0dGVkLlxuICAgICAgICAgICAgICBzdWJqZWN0Lm5leHQoMSA8IHJlc3VsdHMubGVuZ3RoID8gcmVzdWx0cyA6IHJlc3VsdHNbMF0pO1xuICAgICAgICAgICAgICAvLyBGbGlwIHRoaXMgZmxhZywgc28gd2Uga25vdyB3ZSBjYW4gY29tcGxldGUgaXQgaW4gdGhlIHN5bmNocm9ub3VzXG4gICAgICAgICAgICAgIC8vIGNhc2UgYmVsb3cuXG4gICAgICAgICAgICAgIGlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgYXN5bmNocm9ub3VzLCB3ZSBuZWVkIHRvIGRlZmVyIHRoZSBgY29tcGxldGVgIGNhbGxcbiAgICAgICAgICAgICAgLy8gdW50aWwgYWZ0ZXIgdGhlIGNhbGwgdG8gdGhlIGZ1bmN0aW9uIGlzIG92ZXIuIFRoaXMgaXMgYmVjYXVzZSBhblxuICAgICAgICAgICAgICAvLyBlcnJvciBjb3VsZCBiZSB0aHJvd24gaW4gdGhlIGZ1bmN0aW9uIGFmdGVyIGl0IGNhbGxzIG91ciBjYWxsYmFjayxcbiAgICAgICAgICAgICAgLy8gYW5kIGlmIHRoYXQgaXMgdGhlIGNhc2UsIGlmIHdlIGNvbXBsZXRlIGhlcmUsIHdlIGFyZSB1bmFibGUgdG8gbm90aWZ5XG4gICAgICAgICAgICAgIC8vIHRoZSBjb25zdW1lciB0aGFuIGFuIGVycm9yIG9jY3VycmVkLlxuICAgICAgICAgICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICAgICAgICAgIHN1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdXG4gICAgICAgICk7XG4gICAgICAgIC8vIElmIHdlIGZsaXBwZWQgYGlzQ29tcGxldGVgIGR1cmluZyB0aGUgY2FsbCwgd2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseSxcbiAgICAgICAgLy8gbm90aWZ5IGNvbXBsZXRlLCBiZWNhdXNlIHdlIHNraXBwZWQgaXQgaW4gdGhlIGNhbGxiYWNrIHRvIHdhaXRcbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIHRoZXJlIHdlcmUgbm8gZXJyb3JzIGR1cmluZyB0aGUgY2FsbC5cbiAgICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSdyZSBubyBsb25nZXIgc3luY2hyb25vdXMuIElmIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICAvLyB3ZSBjYW4gbm90aWZ5IGNvbXBsZXRlIG9uIHRoZSBzcG90LlxuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRoZSBzdWJzY3JpcHRpb24gZnJvbSBhZGRpbmcgb3VyIHN1YnNjcmliZXIgdG8gdGhlIHN1YmplY3QuXG4gICAgICByZXR1cm4gc3VicztcbiAgICB9KTtcbiAgfTtcbn1cbiJdfQ==
