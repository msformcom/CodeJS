import { innerFrom } from '../observable/innerFrom.mjs';
import { Observable } from '../Observable.mjs';
import { mergeMap } from '../operators/mergeMap.mjs';
import { isArrayLike } from '../util/isArrayLike.mjs';
import { isFunction } from '../util/isFunction.mjs';
import { mapOneOrManyArgs } from '../util/mapOneOrManyArgs.mjs';
// These constants are used to create handler registry functions using array mapping below.
const nodeEventEmitterMethods = ['addListener', 'removeListener'];
const eventTargetMethods = ['addEventListener', 'removeEventListener'];
const jqueryMethods = ['on', 'off'];
/**
 * Creates an Observable that emits events of a specific type coming from the
 * given event target.
 *
 * <span class="informal">Creates an Observable from DOM events, or Node.js
 * EventEmitter events or others.</span>
 *
 * ![](fromEvent.png)
 *
 * `fromEvent` accepts as a first argument event target, which is an object with methods
 * for registering event handler functions. As a second argument it takes string that indicates
 * type of event we want to listen for. `fromEvent` supports selected types of event targets,
 * which are described in detail below. If your event target does not match any of the ones listed,
 * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
 * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
 * handler functions have different names, but they all accept a string describing event type
 * and function itself, which will be called whenever said event happens.
 *
 * Every time resulting Observable is subscribed, event handler function will be registered
 * to event target on given event type. When that event fires, value
 * passed as a first argument to registered function will be emitted by output Observable.
 * When Observable is unsubscribed, function will be unregistered from event target.
 *
 * Note that if event target calls registered function with more than one argument, second
 * and following arguments will not appear in resulting stream. In order to get access to them,
 * you can pass to `fromEvent` optional project function, which will be called with all arguments
 * passed to event handler. Output Observable will then emit value returned by project function,
 * instead of the usual value.
 *
 * Remember that event targets listed below are checked via duck typing. It means that
 * no matter what kind of object you have and no matter what environment you work in,
 * you can safely use `fromEvent` on that object if it exposes described methods (provided
 * of course they behave as was described above). So for example if Node.js library exposes
 * event target which has the same method names as DOM EventTarget, `fromEvent` is still
 * a good choice.
 *
 * If the API you use is more callback then event handler oriented (subscribed
 * callback function fires only once and thus there is no need to manually
 * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
 * instead.
 *
 * `fromEvent` supports following types of event targets:
 *
 * **DOM EventTarget**
 *
 * This is an object with `addEventListener` and `removeEventListener` methods.
 *
 * In the browser, `addEventListener` accepts - apart from event type string and event
 * handler function arguments - optional third parameter, which is either an object or boolean,
 * both used for additional configuration how and when passed function will be called. When
 * `fromEvent` is used with event target of that type, you can provide this values
 * as third parameter as well.
 *
 * **Node.js EventEmitter**
 *
 * An object with `addListener` and `removeListener` methods.
 *
 * **JQuery-style event target**
 *
 * An object with `on` and `off` methods
 *
 * **DOM NodeList**
 *
 * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
 *
 * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
 * it contains and install event handler function in every of them. When returned Observable
 * is unsubscribed, function will be removed from all Nodes.
 *
 * **DOM HtmlCollection**
 *
 * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
 * installed and removed in each of elements.
 *
 *
 * ## Examples
 *
 * Emit clicks happening on the DOM document
 *
 * ```ts
 * import { fromEvent } from 'rxjs';
 *
 * const clicks = fromEvent(document, 'click');
 * clicks.subscribe(x => console.log(x));
 *
 * // Results in:
 * // MouseEvent object logged to console every time a click
 * // occurs on the document.
 * ```
 *
 * Use `addEventListener` with capture option
 *
 * ```ts
 * import { fromEvent } from 'rxjs';
 *
 * const div = document.createElement('div');
 * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';
 * document.body.appendChild(div);
 *
 * // note optional configuration parameter which will be passed to addEventListener
 * const clicksInDocument = fromEvent(document, 'click', { capture: true });
 * const clicksInDiv = fromEvent(div, 'click');
 *
 * clicksInDocument.subscribe(() => console.log('document'));
 * clicksInDiv.subscribe(() => console.log('div'));
 *
 * // By default events bubble UP in DOM tree, so normally
 * // when we would click on div in document
 * // "div" would be logged first and then "document".
 * // Since we specified optional `capture` option, document
 * // will catch event when it goes DOWN DOM tree, so console
 * // will log "document" and then "div".
 * ```
 *
 * @see {@link bindCallback}
 * @see {@link bindNodeCallback}
 * @see {@link fromEventPattern}
 *
 * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js
 * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
 * @param {string} eventName The event name of interest, being emitted by the
 * `target`.
 * @param {EventListenerOptions} [options] Options to pass through to addEventListener
 * @return {Observable<T>}
 */
export function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }
    // Figure out our add and remove methods. In order to do this,
    // we are going to analyze the target in a preferred order, if
    // the target matches a given signature, we take the two "add" and "remove"
    // method names and apply them to a map to create opposite versions of the
    // same function. This is because they all operate in duplicate pairs,
    // `addListener(name, handler)`, `removeListener(name, handler)`, for example.
    // The call only differs by method name, as to whether or not you're adding or removing.
    const [add, remove] = 
    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.
    isEventTarget(target)
        ? eventTargetMethods.map((methodName) => (handler) => target[methodName](eventName, handler, options))
        : // In all other cases, the call pattern is identical with the exception of the method names.
            isNodeStyleEventEmitter(target)
                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
                : isJQueryStyleEventEmitter(target)
                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
                    : [];
    // If add is falsy, it's because we didn't match a pattern above.
    // Check to see if it is an ArrayLike, because if it is, we want to
    // try to apply fromEvent to all of it's items. We do this check last,
    // because there are may be some types that are both ArrayLike *and* implement
    // event registry points, and we'd rather delegate to that when possible.
    if (!add) {
        if (isArrayLike(target)) {
            return mergeMap((subTarget) => fromEvent(subTarget, eventName, options))(innerFrom(target));
        }
    }
    // If add is falsy and we made it here, it's because we didn't
    // match any valid target objects above.
    if (!add) {
        throw new TypeError('Invalid event target');
    }
    return new Observable((subscriber) => {
        // The handler we are going to register. Forwards the event object, by itself, or
        // an array of arguments to the event handler, if there is more than one argument,
        // to the consumer.
        const handler = (...args) => subscriber.next(1 < args.length ? args : args[0]);
        // Do the work of adding the handler to the target.
        add(handler);
        // When we finalize, we want to remove the handler and free up memory.
        return () => remove(handler);
    });
}
/**
 * Used to create `add` and `remove` functions to register and unregister event handlers
 * from a target in the most common handler pattern, where there are only two arguments.
 * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)
 * @param target The target we're calling methods on
 * @param eventName The event name for the event we're creating register or unregister functions for
 */
function toCommonHandlerRegistry(target, eventName) {
    return (methodName) => (handler) => target[methodName](eventName, handler);
}
/**
 * Checks to see if the target implements the required node-style EventEmitter methods
 * for adding and removing event handlers.
 * @param target the object to check
 */
function isNodeStyleEventEmitter(target) {
    return isFunction(target.addListener) && isFunction(target.removeListener);
}
/**
 * Checks to see if the target implements the required jQuery-style EventEmitter methods
 * for adding and removing event handlers.
 * @param target the object to check
 */
function isJQueryStyleEventEmitter(target) {
    return isFunction(target.on) && isFunction(target.off);
}
/**
 * Checks to see if the target implements the required EventTarget methods
 * for adding and removing event handlers.
 * @param target the object to check
 */
function isEventTarget(target) {
    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21FdmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDakQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNoRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUU1RCwyRkFBMkY7QUFDM0YsTUFBTSx1QkFBdUIsR0FBRyxDQUFDLGFBQWEsRUFBRSxnQkFBZ0IsQ0FBVSxDQUFDO0FBQzNFLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxrQkFBa0IsRUFBRSxxQkFBcUIsQ0FBVSxDQUFDO0FBQ2hGLE1BQU0sYUFBYSxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBVSxDQUFDO0FBcUc3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTRIRztBQUNILE1BQU0sVUFBVSxTQUFTLENBQ3ZCLE1BQVcsRUFDWCxTQUFpQixFQUNqQixPQUF3RCxFQUN4RCxjQUFzQztJQUV0QyxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1FBQ3hCLGNBQWMsR0FBRyxPQUFPLENBQUM7UUFDekIsT0FBTyxHQUFHLFNBQVMsQ0FBQztJQUN0QixDQUFDO0lBQ0QsSUFBSSxjQUFjLEVBQUUsQ0FBQztRQUNuQixPQUFPLFNBQVMsQ0FBSSxNQUFNLEVBQUUs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Q0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN6RCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsYUFBYSxDQUFDLE1BQVc7SUFDaEMsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3ZGLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29ic2VydmFibGUvZnJvbUV2ZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWVyZ2VNYXAgfSBmcm9tICcuLi9vcGVyYXRvcnMvbWVyZ2VNYXAnO1xuaW1wb3J0IHsgaXNBcnJheUxpa2UgfSBmcm9tICcuLi91dGlsL2lzQXJyYXlMaWtlJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgbWFwT25lT3JNYW55QXJncyB9IGZyb20gJy4uL3V0aWwvbWFwT25lT3JNYW55QXJncyc7XG5cbi8vIFRoZXNlIGNvbnN0YW50cyBhcmUgdXNlZCB0byBjcmVhdGUgaGFuZGxlciByZWdpc3RyeSBmdW5jdGlvbnMgdXNpbmcgYXJyYXkgbWFwcGluZyBiZWxvdy5cbmNvbnN0IG5vZGVFdmVudEVtaXR0ZXJNZXRob2RzID0gWydhZGRMaXN0ZW5lcicsICdyZW1vdmVMaXN0ZW5lciddIGFzIGNvbnN0O1xuY29uc3QgZXZlbnRUYXJnZXRNZXRob2RzID0gWydhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInXSBhcyBjb25zdDtcbmNvbnN0IGpxdWVyeU1ldGhvZHMgPSBbJ29uJywgJ29mZiddIGFzIGNvbnN0O1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVTdHlsZUV2ZW50RW1pdHRlciB7XG4gIGFkZExpc3RlbmVyKGV2ZW50TmFtZTogc3RyaW5nIHwgc3ltYm9sLCBoYW5kbGVyOiBOb2RlRXZlbnRIYW5kbGVyKTogdGhpcztcbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lOiBzdHJpbmcgfCBzeW1ib2wsIGhhbmRsZXI6IE5vZGVFdmVudEhhbmRsZXIpOiB0aGlzO1xufVxuXG5leHBvcnQgdHlwZSBOb2RlRXZlbnRIYW5kbGVyID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkO1xuXG4vLyBGb3IgQVBJcyB0aGF0IGltcGxlbWVudCBgYWRkTGlzdGVuZXJgIGFuZCBgcmVtb3ZlTGlzdGVuZXJgIG1ldGhvZHMgdGhhdCBtYXlcbi8vIG5vdCB1c2UgdGhlIHNhbWUgYXJndW1lbnRzIG9yIHJldHVybiBFdmVudEVtaXR0ZXIgdmFsdWVzXG4vLyBzdWNoIGFzIFJlYWN0IE5hdGl2ZVxuZXhwb3J0IGludGVyZmFjZSBOb2RlQ29tcGF0aWJsZUV2ZW50RW1pdHRlciB7XG4gIGFkZExpc3RlbmVyKGV2ZW50TmFtZTogc3RyaW5nLCBoYW5kbGVyOiBOb2RlRXZlbnRIYW5kbGVyKTogdm9pZCB8IHt9O1xuICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogTm9kZUV2ZW50SGFuZGxlcik6IHZvaWQgfCB7fTtcbn1cblxuLy8gVXNlIGhhbmRsZXIgdHlwZXMgbGlrZSB0aG9zZSBpbiBAdHlwZXMvanF1ZXJ5LiBTZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZC9ibG9iLzg0NzczMWJhMWQ3ZmE2ZGI2YjkxMWMwZTQzYWEwYWZlNTk2ZTc3MjMvdHlwZXMvanF1ZXJ5L21pc2MuZC50cyNMNjM5NVxuZXhwb3J0IGludGVyZmFjZSBKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcjxUQ29udGV4dCwgVD4ge1xuICBvbihldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogKHRoaXM6IFRDb250ZXh0LCB0OiBULCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KTogdm9pZDtcbiAgb2ZmKGV2ZW50TmFtZTogc3RyaW5nLCBoYW5kbGVyOiAodGhpczogVENvbnRleHQsIHQ6IFQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50TGlzdGVuZXJPYmplY3Q8RT4ge1xuICBoYW5kbGVFdmVudChldnQ6IEUpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhc0V2ZW50VGFyZ2V0QWRkUmVtb3ZlPEU+IHtcbiAgYWRkRXZlbnRMaXN0ZW5lcihcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgbGlzdGVuZXI6ICgoZXZ0OiBFKSA9PiB2b2lkKSB8IEV2ZW50TGlzdGVuZXJPYmplY3Q8RT4gfCBudWxsLFxuICAgIG9wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgKTogdm9pZDtcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgbGlzdGVuZXI6ICgoZXZ0OiBFKSA9PiB2b2lkKSB8IEV2ZW50TGlzdGVuZXJPYmplY3Q8RT4gfCBudWxsLFxuICAgIG9wdGlvbnM/OiBFdmVudExpc3RlbmVyT3B0aW9ucyB8IGJvb2xlYW5cbiAgKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFdmVudExpc3RlbmVyT3B0aW9ucyB7XG4gIGNhcHR1cmU/OiBib29sZWFuO1xuICBwYXNzaXZlPzogYm9vbGVhbjtcbiAgb25jZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgZXh0ZW5kcyBFdmVudExpc3RlbmVyT3B0aW9ucyB7XG4gIG9uY2U/OiBib29sZWFuO1xuICBwYXNzaXZlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdmVudDxUPih0YXJnZXQ6IEhhc0V2ZW50VGFyZ2V0QWRkUmVtb3ZlPFQ+IHwgQXJyYXlMaWtlPEhhc0V2ZW50VGFyZ2V0QWRkUmVtb3ZlPFQ+PiwgZXZlbnROYW1lOiBzdHJpbmcpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdmVudDxULCBSPihcbiAgdGFyZ2V0OiBIYXNFdmVudFRhcmdldEFkZFJlbW92ZTxUPiB8IEFycmF5TGlrZTxIYXNFdmVudFRhcmdldEFkZFJlbW92ZTxUPj4sXG4gIGV2ZW50TmFtZTogc3RyaW5nLFxuICByZXN1bHRTZWxlY3RvcjogKGV2ZW50OiBUKSA9PiBSXG4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdmVudDxUPihcbiAgdGFyZ2V0OiBIYXNFdmVudFRhcmdldEFkZFJlbW92ZTxUPiB8IEFycmF5TGlrZTxIYXNFdmVudFRhcmdldEFkZFJlbW92ZTxUPj4sXG4gIGV2ZW50TmFtZTogc3RyaW5nLFxuICBvcHRpb25zOiBFdmVudExpc3RlbmVyT3B0aW9uc1xuKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXZlbnQ8VCwgUj4oXG4gIHRhcmdldDogSGFzRXZlbnRUYXJnZXRBZGRSZW1vdmU8VD4gfCBBcnJheUxpa2U8SGFzRXZlbnRUYXJnZXRBZGRSZW1vdmU8VD4+LFxuICBldmVudE5hbWU6IHN0cmluZyxcbiAgb3B0aW9uczogRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG4gIHJlc3VsdFNlbGVjdG9yOiAoZXZlbnQ6IFQpID0+IFJcbik6IE9ic2VydmFibGU8Uj47XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXZlbnQodGFyZ2V0OiBOb2RlU3R5bGVFdmVudEVtaXR0ZXIgfCBBcnJheUxpa2U8Tm9kZVN0eWxlRXZlbnRFbWl0dGVyPiwgZXZlbnROYW1lOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVua25vd24+O1xuLyoqIEBkZXByZWNhdGVkIERvIG5vdCBzcGVjaWZ5IGV4cGxpY2l0IHR5cGUgcGFyYW1ldGVycy4gU2lnbmF0dXJlcyB3aXRoIHR5cGUgcGFyYW1ldGVycyB0aGF0IGNhbm5vdCBiZSBpbmZlcnJlZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjguICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV2ZW50PFQ+KHRhcmdldDogTm9kZVN0eWxlRXZlbnRFbWl0dGVyIHwgQXJyYXlMaWtlPE5vZGVTdHlsZUV2ZW50RW1pdHRlcj4sIGV2ZW50TmFtZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXZlbnQ8Uj4oXG4gIHRhcmdldDogTm9kZVN0eWxlRXZlbnRFbWl0dGVyIHwgQXJyYXlMaWtlPE5vZGVTdHlsZUV2ZW50RW1pdHRlcj4sXG4gIGV2ZW50TmFtZTogc3RyaW5nLFxuICByZXN1bHRTZWxlY3RvcjogKC4uLmFyZ3M6IGFueVtdKSA9PiBSXG4pOiBPYnNlcnZhYmxlPFI+O1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV2ZW50KFxuICB0YXJnZXQ6IE5vZGVDb21wYXRpYmxlRXZlbnRFbWl0dGVyIHwgQXJyYXlMaWtlPE5vZGVDb21wYXRpYmxlRXZlbnRFbWl0dGVyPixcbiAgZXZlbnROYW1lOiBzdHJpbmdcbik6IE9ic2VydmFibGU8dW5rbm93bj47XG4vKiogQGRlcHJlY2F0ZWQgRG8gbm90IHNwZWNpZnkgZXhwbGljaXQgdHlwZSBwYXJhbWV0ZXJzLiBTaWduYXR1cmVzIHdpdGggdHlwZSBwYXJhbWV0ZXJzIHRoYXQgY2Fubm90IGJlIGluZmVycmVkIHdpbGwgYmUgcmVtb3ZlZCBpbiB2OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXZlbnQ8VD4odGFyZ2V0OiBOb2RlQ29tcGF0aWJsZUV2ZW50RW1pdHRlciB8IEFycmF5TGlrZTxOb2RlQ29tcGF0aWJsZUV2ZW50RW1pdHRlcj4sIGV2ZW50TmFtZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXZlbnQ8Uj4oXG4gIHRhcmdldDogTm9kZUNvbXBhdGlibGVFdmVudEVtaXR0ZXIgfCBBcnJheUxpa2U8Tm9kZUNvbXBhdGlibGVFdmVudEVtaXR0ZXI+LFxuICBldmVudE5hbWU6IHN0cmluZyxcbiAgcmVzdWx0U2VsZWN0b3I6ICguLi5hcmdzOiBhbnlbXSkgPT4gUlxuKTogT2JzZXJ2YWJsZTxSPjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdmVudDxUPihcbiAgdGFyZ2V0OiBKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcjxhbnksIFQ+IHwgQXJyYXlMaWtlPEpRdWVyeVN0eWxlRXZlbnRFbWl0dGVyPGFueSwgVD4+LFxuICBldmVudE5hbWU6IHN0cmluZ1xuKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXZlbnQ8VCwgUj4oXG4gIHRhcmdldDogSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXI8YW55LCBUPiB8IEFycmF5TGlrZTxKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcjxhbnksIFQ+PixcbiAgZXZlbnROYW1lOiBzdHJpbmcsXG4gIHJlc3VsdFNlbGVjdG9yOiAodmFsdWU6IFQsIC4uLmFyZ3M6IGFueVtdKSA9PiBSXG4pOiBPYnNlcnZhYmxlPFI+O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGV2ZW50cyBvZiBhIHNwZWNpZmljIHR5cGUgY29taW5nIGZyb20gdGhlXG4gKiBnaXZlbiBldmVudCB0YXJnZXQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBmcm9tIERPTSBldmVudHMsIG9yIE5vZGUuanNcbiAqIEV2ZW50RW1pdHRlciBldmVudHMgb3Igb3RoZXJzLjwvc3Bhbj5cbiAqXG4gKiAhW10oZnJvbUV2ZW50LnBuZylcbiAqXG4gKiBgZnJvbUV2ZW50YCBhY2NlcHRzIGFzIGEgZmlyc3QgYXJndW1lbnQgZXZlbnQgdGFyZ2V0LCB3aGljaCBpcyBhbiBvYmplY3Qgd2l0aCBtZXRob2RzXG4gKiBmb3IgcmVnaXN0ZXJpbmcgZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMuIEFzIGEgc2Vjb25kIGFyZ3VtZW50IGl0IHRha2VzIHN0cmluZyB0aGF0IGluZGljYXRlc1xuICogdHlwZSBvZiBldmVudCB3ZSB3YW50IHRvIGxpc3RlbiBmb3IuIGBmcm9tRXZlbnRgIHN1cHBvcnRzIHNlbGVjdGVkIHR5cGVzIG9mIGV2ZW50IHRhcmdldHMsXG4gKiB3aGljaCBhcmUgZGVzY3JpYmVkIGluIGRldGFpbCBiZWxvdy4gSWYgeW91ciBldmVudCB0YXJnZXQgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBvbmVzIGxpc3RlZCxcbiAqIHlvdSBzaG91bGQgdXNlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufSwgd2hpY2ggY2FuIGJlIHVzZWQgb24gYXJiaXRyYXJ5IEFQSXMuXG4gKiBXaGVuIGl0IGNvbWVzIHRvIEFQSXMgc3VwcG9ydGVkIGJ5IGBmcm9tRXZlbnRgLCB0aGVpciBtZXRob2RzIGZvciBhZGRpbmcgYW5kIHJlbW92aW5nIGV2ZW50XG4gKiBoYW5kbGVyIGZ1bmN0aW9ucyBoYXZlIGRpZmZlcmVudCBuYW1lcywgYnV0IHRoZXkgYWxsIGFjY2VwdCBhIHN0cmluZyBkZXNjcmliaW5nIGV2ZW50IHR5cGVcbiAqIGFuZCBmdW5jdGlvbiBpdHNlbGYsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHNhaWQgZXZlbnQgaGFwcGVucy5cbiAqXG4gKiBFdmVyeSB0aW1lIHJlc3VsdGluZyBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQsIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gd2lsbCBiZSByZWdpc3RlcmVkXG4gKiB0byBldmVudCB0YXJnZXQgb24gZ2l2ZW4gZXZlbnQgdHlwZS4gV2hlbiB0aGF0IGV2ZW50IGZpcmVzLCB2YWx1ZVxuICogcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnQgdG8gcmVnaXN0ZXJlZCBmdW5jdGlvbiB3aWxsIGJlIGVtaXR0ZWQgYnkgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBXaGVuIE9ic2VydmFibGUgaXMgdW5zdWJzY3JpYmVkLCBmdW5jdGlvbiB3aWxsIGJlIHVucmVnaXN0ZXJlZCBmcm9tIGV2ZW50IHRhcmdldC5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgZXZlbnQgdGFyZ2V0IGNhbGxzIHJlZ2lzdGVyZWQgZnVuY3Rpb24gd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBzZWNvbmRcbiAqIGFuZCBmb2xsb3dpbmcgYXJndW1lbnRzIHdpbGwgbm90IGFwcGVhciBpbiByZXN1bHRpbmcgc3RyZWFtLiBJbiBvcmRlciB0byBnZXQgYWNjZXNzIHRvIHRoZW0sXG4gKiB5b3UgY2FuIHBhc3MgdG8gYGZyb21FdmVudGAgb3B0aW9uYWwgcHJvamVjdCBmdW5jdGlvbiwgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgYXJndW1lbnRzXG4gKiBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlci4gT3V0cHV0IE9ic2VydmFibGUgd2lsbCB0aGVuIGVtaXQgdmFsdWUgcmV0dXJuZWQgYnkgcHJvamVjdCBmdW5jdGlvbixcbiAqIGluc3RlYWQgb2YgdGhlIHVzdWFsIHZhbHVlLlxuICpcbiAqIFJlbWVtYmVyIHRoYXQgZXZlbnQgdGFyZ2V0cyBsaXN0ZWQgYmVsb3cgYXJlIGNoZWNrZWQgdmlhIGR1Y2sgdHlwaW5nLiBJdCBtZWFucyB0aGF0XG4gKiBubyBtYXR0ZXIgd2hhdCBraW5kIG9mIG9iamVjdCB5b3UgaGF2ZSBhbmQgbm8gbWF0dGVyIHdoYXQgZW52aXJvbm1lbnQgeW91IHdvcmsgaW4sXG4gKiB5b3UgY2FuIHNhZmVseSB1c2UgYGZyb21FdmVudGAgb24gdGhhdCBvYmplY3QgaWYgaXQgZXhwb3NlcyBkZXNjcmliZWQgbWV0aG9kcyAocHJvdmlkZWRcbiAqIG9mIGNvdXJzZSB0aGV5IGJlaGF2ZSBhcyB3YXMgZGVzY3JpYmVkIGFib3ZlKS4gU28gZm9yIGV4YW1wbGUgaWYgTm9kZS5qcyBsaWJyYXJ5IGV4cG9zZXNcbiAqIGV2ZW50IHRhcmdldCB3aGljaCBoYXMgdGhlIHNhbWUgbWV0aG9kIG5hbWVzIGFzIERPTSBFdmVudFRhcmdldCwgYGZyb21FdmVudGAgaXMgc3RpbGxcbiAqIGEgZ29vZCBjaG9pY2UuXG4gKlxuICogSWYgdGhlIEFQSSB5b3UgdXNlIGlzIG1vcmUgY2FsbGJhY2sgdGhlbiBldmVudCBoYW5kbGVyIG9yaWVudGVkIChzdWJzY3JpYmVkXG4gKiBjYWxsYmFjayBmdW5jdGlvbiBmaXJlcyBvbmx5IG9uY2UgYW5kIHRodXMgdGhlcmUgaXMgbm8gbmVlZCB0byBtYW51YWxseVxuICogdW5yZWdpc3RlciBpdCksIHlvdSBzaG91bGQgdXNlIHtAbGluayBiaW5kQ2FsbGJhY2t9IG9yIHtAbGluayBiaW5kTm9kZUNhbGxiYWNrfVxuICogaW5zdGVhZC5cbiAqXG4gKiBgZnJvbUV2ZW50YCBzdXBwb3J0cyBmb2xsb3dpbmcgdHlwZXMgb2YgZXZlbnQgdGFyZ2V0czpcbiAqXG4gKiAqKkRPTSBFdmVudFRhcmdldCoqXG4gKlxuICogVGhpcyBpcyBhbiBvYmplY3Qgd2l0aCBgYWRkRXZlbnRMaXN0ZW5lcmAgYW5kIGByZW1vdmVFdmVudExpc3RlbmVyYCBtZXRob2RzLlxuICpcbiAqIEluIHRoZSBicm93c2VyLCBgYWRkRXZlbnRMaXN0ZW5lcmAgYWNjZXB0cyAtIGFwYXJ0IGZyb20gZXZlbnQgdHlwZSBzdHJpbmcgYW5kIGV2ZW50XG4gKiBoYW5kbGVyIGZ1bmN0aW9uIGFyZ3VtZW50cyAtIG9wdGlvbmFsIHRoaXJkIHBhcmFtZXRlciwgd2hpY2ggaXMgZWl0aGVyIGFuIG9iamVjdCBvciBib29sZWFuLFxuICogYm90aCB1c2VkIGZvciBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gaG93IGFuZCB3aGVuIHBhc3NlZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZC4gV2hlblxuICogYGZyb21FdmVudGAgaXMgdXNlZCB3aXRoIGV2ZW50IHRhcmdldCBvZiB0aGF0IHR5cGUsIHlvdSBjYW4gcHJvdmlkZSB0aGlzIHZhbHVlc1xuICogYXMgdGhpcmQgcGFyYW1ldGVyIGFzIHdlbGwuXG4gKlxuICogKipOb2RlLmpzIEV2ZW50RW1pdHRlcioqXG4gKlxuICogQW4gb2JqZWN0IHdpdGggYGFkZExpc3RlbmVyYCBhbmQgYHJlbW92ZUxpc3RlbmVyYCBtZXRob2RzLlxuICpcbiAqICoqSlF1ZXJ5LXN0eWxlIGV2ZW50IHRhcmdldCoqXG4gKlxuICogQW4gb2JqZWN0IHdpdGggYG9uYCBhbmQgYG9mZmAgbWV0aG9kc1xuICpcbiAqICoqRE9NIE5vZGVMaXN0KipcbiAqXG4gKiBMaXN0IG9mIERPTSBOb2RlcywgcmV0dXJuZWQgZm9yIGV4YW1wbGUgYnkgYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGxgIG9yIGBOb2RlLmNoaWxkTm9kZXNgLlxuICpcbiAqIEFsdGhvdWdoIHRoaXMgY29sbGVjdGlvbiBpcyBub3QgZXZlbnQgdGFyZ2V0IGluIGl0c2VsZiwgYGZyb21FdmVudGAgd2lsbCBpdGVyYXRlIG92ZXIgYWxsIE5vZGVzXG4gKiBpdCBjb250YWlucyBhbmQgaW5zdGFsbCBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIGluIGV2ZXJ5IG9mIHRoZW0uIFdoZW4gcmV0dXJuZWQgT2JzZXJ2YWJsZVxuICogaXMgdW5zdWJzY3JpYmVkLCBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgZnJvbSBhbGwgTm9kZXMuXG4gKlxuICogKipET00gSHRtbENvbGxlY3Rpb24qKlxuICpcbiAqIEp1c3QgYXMgaW4gY2FzZSBvZiBOb2RlTGlzdCBpdCBpcyBhIGNvbGxlY3Rpb24gb2YgRE9NIG5vZGVzLiBIZXJlIGFzIHdlbGwgZXZlbnQgaGFuZGxlciBmdW5jdGlvbiBpc1xuICogaW5zdGFsbGVkIGFuZCByZW1vdmVkIGluIGVhY2ggb2YgZWxlbWVudHMuXG4gKlxuICpcbiAqICMjIEV4YW1wbGVzXG4gKlxuICogRW1pdCBjbGlja3MgaGFwcGVuaW5nIG9uIHRoZSBET00gZG9jdW1lbnRcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbjpcbiAqIC8vIE1vdXNlRXZlbnQgb2JqZWN0IGxvZ2dlZCB0byBjb25zb2xlIGV2ZXJ5IHRpbWUgYSBjbGlja1xuICogLy8gb2NjdXJzIG9uIHRoZSBkb2N1bWVudC5cbiAqIGBgYFxuICpcbiAqIFVzZSBgYWRkRXZlbnRMaXN0ZW5lcmAgd2l0aCBjYXB0dXJlIG9wdGlvblxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqIGRpdi5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOiAyMDBweDsgaGVpZ2h0OiAyMDBweDsgYmFja2dyb3VuZDogIzA5YzsnO1xuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICpcbiAqIC8vIG5vdGUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXIgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYWRkRXZlbnRMaXN0ZW5lclxuICogY29uc3QgY2xpY2tzSW5Eb2N1bWVudCA9IGZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJywgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICogY29uc3QgY2xpY2tzSW5EaXYgPSBmcm9tRXZlbnQoZGl2LCAnY2xpY2snKTtcbiAqXG4gKiBjbGlja3NJbkRvY3VtZW50LnN1YnNjcmliZSgoKSA9PiBjb25zb2xlLmxvZygnZG9jdW1lbnQnKSk7XG4gKiBjbGlja3NJbkRpdi5zdWJzY3JpYmUoKCkgPT4gY29uc29sZS5sb2coJ2RpdicpKTtcbiAqXG4gKiAvLyBCeSBkZWZhdWx0IGV2ZW50cyBidWJibGUgVVAgaW4gRE9NIHRyZWUsIHNvIG5vcm1hbGx5XG4gKiAvLyB3aGVuIHdlIHdvdWxkIGNsaWNrIG9uIGRpdiBpbiBkb2N1bWVudFxuICogLy8gXCJkaXZcIiB3b3VsZCBiZSBsb2dnZWQgZmlyc3QgYW5kIHRoZW4gXCJkb2N1bWVudFwiLlxuICogLy8gU2luY2Ugd2Ugc3BlY2lmaWVkIG9wdGlvbmFsIGBjYXB0dXJlYCBvcHRpb24sIGRvY3VtZW50XG4gKiAvLyB3aWxsIGNhdGNoIGV2ZW50IHdoZW4gaXQgZ29lcyBET1dOIERPTSB0cmVlLCBzbyBjb25zb2xlXG4gKiAvLyB3aWxsIGxvZyBcImRvY3VtZW50XCIgYW5kIHRoZW4gXCJkaXZcIi5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGJpbmRDYWxsYmFja31cbiAqIEBzZWUge0BsaW5rIGJpbmROb2RlQ2FsbGJhY2t9XG4gKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICpcbiAqIEBwYXJhbSB7RnJvbUV2ZW50VGFyZ2V0PFQ+fSB0YXJnZXQgVGhlIERPTSBFdmVudFRhcmdldCwgTm9kZS5qc1xuICogRXZlbnRFbWl0dGVyLCBKUXVlcnktbGlrZSBldmVudCB0YXJnZXQsIE5vZGVMaXN0IG9yIEhUTUxDb2xsZWN0aW9uIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlciB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgb2YgaW50ZXJlc3QsIGJlaW5nIGVtaXR0ZWQgYnkgdGhlXG4gKiBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdGhyb3VnaCB0byBhZGRFdmVudExpc3RlbmVyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV2ZW50PFQ+KFxuICB0YXJnZXQ6IGFueSxcbiAgZXZlbnROYW1lOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBFdmVudExpc3RlbmVyT3B0aW9ucyB8ICgoLi4uYXJnczogYW55W10pID0+IFQpLFxuICByZXN1bHRTZWxlY3Rvcj86ICguLi5hcmdzOiBhbnlbXSkgPT4gVFxuKTogT2JzZXJ2YWJsZTxUPiB7XG4gIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgcmVzdWx0U2VsZWN0b3IgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZyb21FdmVudDxUPih0YXJnZXQsIGV2ZW50TmFtZSwgb3B0aW9ucyBhcyBFdmVudExpc3RlbmVyT3B0aW9ucykucGlwZShtYXBPbmVPck1hbnlBcmdzKHJlc3VsdFNlbGVjdG9yKSk7XG4gIH1cblxuICAvLyBGaWd1cmUgb3V0IG91ciBhZGQgYW5kIHJlbW92ZSBtZXRob2RzLiBJbiBvcmRlciB0byBkbyB0aGlzLFxuICAvLyB3ZSBhcmUgZ29pbmcgdG8gYW5hbHl6ZSB0aGUgdGFyZ2V0IGluIGEgcHJlZmVycmVkIG9yZGVyLCBpZlxuICAvLyB0aGUgdGFyZ2V0IG1hdGNoZXMgYSBnaXZlbiBzaWduYXR1cmUsIHdlIHRha2UgdGhlIHR3byBcImFkZFwiIGFuZCBcInJlbW92ZVwiXG4gIC8vIG1ldGhvZCBuYW1lcyBhbmQgYXBwbHkgdGhlbSB0byBhIG1hcCB0byBjcmVhdGUgb3Bwb3NpdGUgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHNhbWUgZnVuY3Rpb24uIFRoaXMgaXMgYmVjYXVzZSB0aGV5IGFsbCBvcGVyYXRlIGluIGR1cGxpY2F0ZSBwYWlycyxcbiAgLy8gYGFkZExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpYCwgYHJlbW92ZUxpc3RlbmVyKG5hbWUsIGhhbmRsZXIpYCwgZm9yIGV4YW1wbGUuXG4gIC8vIFRoZSBjYWxsIG9ubHkgZGlmZmVycyBieSBtZXRob2QgbmFtZSwgYXMgdG8gd2hldGhlciBvciBub3QgeW91J3JlIGFkZGluZyBvciByZW1vdmluZy5cbiAgY29uc3QgW2FkZCwgcmVtb3ZlXSA9XG4gICAgLy8gSWYgaXQgaXMgYW4gRXZlbnRUYXJnZXQsIHdlIG5lZWQgdG8gdXNlIGEgc2xpZ2h0bHkgZGlmZmVyZW50IG1ldGhvZCB0aGFuIHRoZSBvdGhlciB0d28gcGF0dGVybnMuXG4gICAgaXNFdmVudFRhcmdldCh0YXJnZXQpXG4gICAgICA/IGV2ZW50VGFyZ2V0TWV0aG9kcy5tYXAoKG1ldGhvZE5hbWUpID0+IChoYW5kbGVyOiBhbnkpID0+IHRhcmdldFttZXRob2ROYW1lXShldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMgYXMgRXZlbnRMaXN0ZW5lck9wdGlvbnMpKVxuICAgICAgOiAvLyBJbiBhbGwgb3RoZXIgY2FzZXMsIHRoZSBjYWxsIHBhdHRlcm4gaXMgaWRlbnRpY2FsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgbWV0aG9kIG5hbWVzLlxuICAgICAgaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIodGFyZ2V0KVxuICAgICAgPyBub2RlRXZlbnRFbWl0dGVyTWV0aG9kcy5tYXAodG9Db21tb25IYW5kbGVyUmVnaXN0cnkodGFyZ2V0LCBldmVudE5hbWUpKVxuICAgICAgOiBpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHRhcmdldClcbiAgICAgID8ganF1ZXJ5TWV0aG9kcy5tYXAodG9Db21tb25IYW5kbGVyUmVnaXN0cnkodGFyZ2V0LCBldmVudE5hbWUpKVxuICAgICAgOiBbXTtcblxuICAvLyBJZiBhZGQgaXMgZmFsc3ksIGl0J3MgYmVjYXVzZSB3ZSBkaWRuJ3QgbWF0Y2ggYSBwYXR0ZXJuIGFib3ZlLlxuICAvLyBDaGVjayB0byBzZWUgaWYgaXQgaXMgYW4gQXJyYXlMaWtlLCBiZWNhdXNlIGlmIGl0IGlzLCB3ZSB3YW50IHRvXG4gIC8vIHRyeSB0byBhcHBseSBmcm9tRXZlbnQgdG8gYWxsIG9mIGl0J3MgaXRlbXMuIFdlIGRvIHRoaXMgY2hlY2sgbGFzdCxcbiAgLy8gYmVjYXVzZSB0aGVyZSBhcmUgbWF5IGJlIHNvbWUgdHlwZXMgdGhhdCBhcmUgYm90aCBBcnJheUxpa2UgKmFuZCogaW1wbGVtZW50XG4gIC8vIGV2ZW50IHJlZ2lzdHJ5IHBvaW50cywgYW5kIHdlJ2QgcmF0aGVyIGRlbGVnYXRlIHRvIHRoYXQgd2hlbiBwb3NzaWJsZS5cbiAgaWYgKCFhZGQpIHtcbiAgICBpZiAoaXNBcnJheUxpa2UodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIG1lcmdlTWFwKChzdWJUYXJnZXQ6IGFueSkgPT4gZnJvbUV2ZW50KHN1YlRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zIGFzIEV2ZW50TGlzdGVuZXJPcHRpb25zKSkoXG4gICAgICAgIGlubmVyRnJvbSh0YXJnZXQpXG4gICAgICApIGFzIE9ic2VydmFibGU8VD47XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYWRkIGlzIGZhbHN5IGFuZCB3ZSBtYWRlIGl0IGhlcmUsIGl0J3MgYmVjYXVzZSB3ZSBkaWRuJ3RcbiAgLy8gbWF0Y2ggYW55IHZhbGlkIHRhcmdldCBvYmplY3RzIGFib3ZlLlxuICBpZiAoIWFkZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZXZlbnQgdGFyZ2V0Jyk7XG4gIH1cblxuICByZXR1cm4gbmV3IE9ic2VydmFibGU8VD4oKHN1YnNjcmliZXIpID0+IHtcbiAgICAvLyBUaGUgaGFuZGxlciB3ZSBhcmUgZ29pbmcgdG8gcmVnaXN0ZXIuIEZvcndhcmRzIHRoZSBldmVudCBvYmplY3QsIGJ5IGl0c2VsZiwgb3JcbiAgICAvLyBhbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gdGhlIGV2ZW50IGhhbmRsZXIsIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsXG4gICAgLy8gdG8gdGhlIGNvbnN1bWVyLlxuICAgIGNvbnN0IGhhbmRsZXIgPSAoLi4uYXJnczogYW55W10pID0+IHN1YnNjcmliZXIubmV4dCgxIDwgYXJncy5sZW5ndGggPyBhcmdzIDogYXJnc1swXSk7XG4gICAgLy8gRG8gdGhlIHdvcmsgb2YgYWRkaW5nIHRoZSBoYW5kbGVyIHRvIHRoZSB0YXJnZXQuXG4gICAgYWRkKGhhbmRsZXIpO1xuICAgIC8vIFdoZW4gd2UgZmluYWxpemUsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyIGFuZCBmcmVlIHVwIG1lbW9yeS5cbiAgICByZXR1cm4gKCkgPT4gcmVtb3ZlIShoYW5kbGVyKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVXNlZCB0byBjcmVhdGUgYGFkZGAgYW5kIGByZW1vdmVgIGZ1bmN0aW9ucyB0byByZWdpc3RlciBhbmQgdW5yZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICogZnJvbSBhIHRhcmdldCBpbiB0aGUgbW9zdCBjb21tb24gaGFuZGxlciBwYXR0ZXJuLCB3aGVyZSB0aGVyZSBhcmUgb25seSB0d28gYXJndW1lbnRzLlxuICogKGUuZy4gIGBvbihuYW1lLCBmbilgLCBgb2ZmKG5hbWUsIGZuKWAsIGBhZGRMaXN0ZW5lcihuYW1lLCBmbilgLCBvciBgcmVtb3ZlTGlzdGVuZXIobmFtZSwgZm4pYClcbiAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCB3ZSdyZSBjYWxsaW5nIG1ldGhvZHMgb25cbiAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgZm9yIHRoZSBldmVudCB3ZSdyZSBjcmVhdGluZyByZWdpc3RlciBvciB1bnJlZ2lzdGVyIGZ1bmN0aW9ucyBmb3JcbiAqL1xuZnVuY3Rpb24gdG9Db21tb25IYW5kbGVyUmVnaXN0cnkodGFyZ2V0OiBhbnksIGV2ZW50TmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiAobWV0aG9kTmFtZTogc3RyaW5nKSA9PiAoaGFuZGxlcjogYW55KSA9PiB0YXJnZXRbbWV0aG9kTmFtZV0oZXZlbnROYW1lLCBoYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSB0YXJnZXQgaW1wbGVtZW50cyB0aGUgcmVxdWlyZWQgbm9kZS1zdHlsZSBFdmVudEVtaXR0ZXIgbWV0aG9kc1xuICogZm9yIGFkZGluZyBhbmQgcmVtb3ZpbmcgZXZlbnQgaGFuZGxlcnMuXG4gKiBAcGFyYW0gdGFyZ2V0IHRoZSBvYmplY3QgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIodGFyZ2V0OiBhbnkpOiB0YXJnZXQgaXMgTm9kZVN0eWxlRXZlbnRFbWl0dGVyIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odGFyZ2V0LmFkZExpc3RlbmVyKSAmJiBpc0Z1bmN0aW9uKHRhcmdldC5yZW1vdmVMaXN0ZW5lcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgdGFyZ2V0IGltcGxlbWVudHMgdGhlIHJlcXVpcmVkIGpRdWVyeS1zdHlsZSBFdmVudEVtaXR0ZXIgbWV0aG9kc1xuICogZm9yIGFkZGluZyBhbmQgcmVtb3ZpbmcgZXZlbnQgaGFuZGxlcnMuXG4gKiBAcGFyYW0gdGFyZ2V0IHRoZSBvYmplY3QgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcih0YXJnZXQ6IGFueSk6IHRhcmdldCBpcyBKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcjxhbnksIGFueT4ge1xuICByZXR1cm4gaXNGdW5jdGlvbih0YXJnZXQub24pICYmIGlzRnVuY3Rpb24odGFyZ2V0Lm9mZik7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgdGFyZ2V0IGltcGxlbWVudHMgdGhlIHJlcXVpcmVkIEV2ZW50VGFyZ2V0IG1ldGhvZHNcbiAqIGZvciBhZGRpbmcgYW5kIHJlbW92aW5nIGV2ZW50IGhhbmRsZXJzLlxuICogQHBhcmFtIHRhcmdldCB0aGUgb2JqZWN0IHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQodGFyZ2V0OiBhbnkpOiB0YXJnZXQgaXMgSGFzRXZlbnRUYXJnZXRBZGRSZW1vdmU8YW55PiB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSAmJiBpc0Z1bmN0aW9uKHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKTtcbn1cbiJdfQ==
