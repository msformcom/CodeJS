import { asyncScheduler } from '../scheduler/async.mjs';
import { timer } from './timer.mjs';
/**
 * Creates an Observable that emits sequential numbers every specified
 * interval of time, on a specified {@link SchedulerLike}.
 *
 * <span class="informal">Emits incremental numbers periodically in time.</span>
 *
 * ![](interval.png)
 *
 * `interval` returns an Observable that emits an infinite sequence of
 * ascending integers, with a constant interval of time of your choosing
 * between those emissions. The first emission is not sent immediately, but
 * only after the first period has passed. By default, this operator uses the
 * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any
 * {@link SchedulerLike} to it.
 *
 * ## Example
 *
 * Emits ascending numbers, one every second (1000ms) up to the number 3
 *
 * ```ts
 * import { interval, take } from 'rxjs';
 *
 * const numbers = interval(1000);
 *
 * const takeFourNumbers = numbers.pipe(take(4));
 *
 * takeFourNumbers.subscribe(x => console.log('Next: ', x));
 *
 * // Logs:
 * // Next: 0
 * // Next: 1
 * // Next: 2
 * // Next: 3
 * ```
 *
 * @see {@link timer}
 * @see {@link delay}
 *
 * @param {number} [period=0] The interval size in milliseconds (by default)
 * or the time unit determined by the scheduler's clock.
 * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
 * the emission of values, and providing a notion of "time".
 * @return {Observable} An Observable that emits a sequential number each time
 * interval.
 */
export function interval(period = 0, scheduler = asyncScheduler) {
    if (period < 0) {
        // We cannot schedule an interval in the past.
        period = 0;
    }
    return timer(period, period, scheduler);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2ludGVydmFsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVwRCxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTRDRztBQUNILE1BQU0sVUFBVSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxZQUEyQixjQUFjO0lBQzVFLElBQUksTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ2YsOENBQThDO1FBQzlDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDYixDQUFDO0lBRUQsT0FBTyxLQUFLLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztBQUMxQyxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2ludGVydmFsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgYXN5bmNTY2hlZHVsZXIgfSBmcm9tICcuLi9zY2hlZHVsZXIvYXN5bmMnO1xuaW1wb3J0IHsgU2NoZWR1bGVyTGlrZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHRpbWVyIH0gZnJvbSAnLi90aW1lcic7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgc2VxdWVudGlhbCBudW1iZXJzIGV2ZXJ5IHNwZWNpZmllZFxuICogaW50ZXJ2YWwgb2YgdGltZSwgb24gYSBzcGVjaWZpZWQge0BsaW5rIFNjaGVkdWxlckxpa2V9LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FbWl0cyBpbmNyZW1lbnRhbCBudW1iZXJzIHBlcmlvZGljYWxseSBpbiB0aW1lLjwvc3Bhbj5cbiAqXG4gKiAhW10oaW50ZXJ2YWwucG5nKVxuICpcbiAqIGBpbnRlcnZhbGAgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYW4gaW5maW5pdGUgc2VxdWVuY2Ugb2ZcbiAqIGFzY2VuZGluZyBpbnRlZ2Vycywgd2l0aCBhIGNvbnN0YW50IGludGVydmFsIG9mIHRpbWUgb2YgeW91ciBjaG9vc2luZ1xuICogYmV0d2VlbiB0aG9zZSBlbWlzc2lvbnMuIFRoZSBmaXJzdCBlbWlzc2lvbiBpcyBub3Qgc2VudCBpbW1lZGlhdGVseSwgYnV0XG4gKiBvbmx5IGFmdGVyIHRoZSBmaXJzdCBwZXJpb2QgaGFzIHBhc3NlZC4gQnkgZGVmYXVsdCwgdGhpcyBvcGVyYXRvciB1c2VzIHRoZVxuICogYGFzeW5jYCB7QGxpbmsgU2NoZWR1bGVyTGlrZX0gdG8gcHJvdmlkZSBhIG5vdGlvbiBvZiB0aW1lLCBidXQgeW91IG1heSBwYXNzIGFueVxuICoge0BsaW5rIFNjaGVkdWxlckxpa2V9IHRvIGl0LlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBFbWl0cyBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCAoMTAwMG1zKSB1cCB0byB0aGUgbnVtYmVyIDNcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaW50ZXJ2YWwsIHRha2UgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBudW1iZXJzID0gaW50ZXJ2YWwoMTAwMCk7XG4gKlxuICogY29uc3QgdGFrZUZvdXJOdW1iZXJzID0gbnVtYmVycy5waXBlKHRha2UoNCkpO1xuICpcbiAqIHRha2VGb3VyTnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZygnTmV4dDogJywgeCkpO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyBOZXh0OiAwXG4gKiAvLyBOZXh0OiAxXG4gKiAvLyBOZXh0OiAyXG4gKiAvLyBOZXh0OiAzXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayB0aW1lcn1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyaW9kPTBdIFRoZSBpbnRlcnZhbCBzaXplIGluIG1pbGxpc2Vjb25kcyAoYnkgZGVmYXVsdClcbiAqIG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZCBieSB0aGUgc2NoZWR1bGVyJ3MgY2xvY2suXG4gKiBAcGFyYW0ge1NjaGVkdWxlckxpa2V9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgU2NoZWR1bGVyTGlrZX0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gKiB0aGUgZW1pc3Npb24gb2YgdmFsdWVzLCBhbmQgcHJvdmlkaW5nIGEgbm90aW9uIG9mIFwidGltZVwiLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgc2VxdWVudGlhbCBudW1iZXIgZWFjaCB0aW1lXG4gKiBpbnRlcnZhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVydmFsKHBlcmlvZCA9IDAsIHNjaGVkdWxlcjogU2NoZWR1bGVyTGlrZSA9IGFzeW5jU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgaWYgKHBlcmlvZCA8IDApIHtcbiAgICAvLyBXZSBjYW5ub3Qgc2NoZWR1bGUgYW4gaW50ZXJ2YWwgaW4gdGhlIHBhc3QuXG4gICAgcGVyaW9kID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aW1lcihwZXJpb2QsIHBlcmlvZCwgc2NoZWR1bGVyKTtcbn1cbiJdfQ==
