import { Observable } from '../Observable.mjs';
import { Subscription } from '../Subscription.mjs';
import { refCount as higherOrderRefCount } from '../operators/refCount.mjs';
import { createOperatorSubscriber } from '../operators/OperatorSubscriber.mjs';
import { hasLift } from '../util/lift.mjs';
/**
 * @class ConnectableObservable<T>
 * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.
 * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator
 * instead.
 * Details: https://rxjs.dev/deprecations/multicasting
 */
export class ConnectableObservable extends Observable {
    /**
     * @param source The source observable
     * @param subjectFactory The factory that creates the subject used internally.
     * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.
     * `new ConnectableObservable(source, factory)` is equivalent to
     * `connectable(source, { connector: factory })`.
     * When the `refCount()` method is needed, the {@link share} operator should be used instead:
     * `new ConnectableObservable(source, factory).refCount()` is equivalent to
     * `source.pipe(share({ connector: factory }))`.
     * Details: https://rxjs.dev/deprecations/multicasting
     */
    constructor(source, subjectFactory) {
        super();
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._subject = null;
        this._refCount = 0;
        this._connection = null;
        // If we have lift, monkey patch that here. This is done so custom observable
        // types will compose through multicast. Otherwise the resulting observable would
        // simply be an instance of `ConnectableObservable`.
        if (hasLift(source)) {
            this.lift = source.lift;
        }
    }
    /** @internal */
    _subscribe(subscriber) {
        return this.getSubject().subscribe(subscriber);
    }
    getSubject() {
        const subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    }
    _teardown() {
        this._refCount = 0;
        const { _connection } = this;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
    }
    /**
     * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.
     * Details: https://rxjs.dev/deprecations/multicasting
     */
    connect() {
        let connection = this._connection;
        if (!connection) {
            connection = this._connection = new Subscription();
            const subject = this.getSubject();
            connection.add(this.source.subscribe(createOperatorSubscriber(subject, undefined, () => {
                this._teardown();
                subject.complete();
            }, (err) => {
                this._teardown();
                subject.error(err);
            }, () => this._teardown())));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription.EMPTY;
            }
        }
        return connection;
    }
    /**
     * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.
     * Details: https://rxjs.dev/deprecations/multicasting
     */
    refCount() {
        return higherOrderRefCount()(this);
    }
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsUUFBUSxJQUFJLG1CQUFtQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDeEUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0UsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUV2Qzs7Ozs7O0dBTUc7QUFDSCxNQUFNLE9BQU8scUJBQXlCLFNBQVEsVUFBYTtJQUt6RDs7Ozs7Ozs7OztPQVVHO0lBQ0gsWUFBbUIsTUFBcUIsRUFBWSxjQUFnQztRQUNsRixLQUFLLEVBQUUsQ0FBQztRQURTLFdBQU0sR0FBTixNQUFNLENBQWU7UUFBWSxtQkFBYyxHQUFkLGNBQWMsQ0FBa0I7UUFmMUUsYUFBUSxHQUFzQixJQUFJLENBQUM7UUFDbkMsY0FBUyxHQUFXLENBQUMsQ0FBQztRQUN0QixnQkFBVyxHQUF3QixJQUFJLENBQUM7UUFlaEQsNkVBQTZFO1FBQzdFLGlGQUFpRjtRQUNqRixvREFBb0Q7UUFDcEQsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztZQUNwQixJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFDMUIsQ0FBQztJQUNILENBQUM7SUFFRCxnQkFBZ0I7SUFDTixVQUFVLENBQUMsVUFBeUI7UUFDNUMsT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFUyxVQUFVO1FBQ2xCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDOUIsSUFBSSxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDbEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDeEMsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVMsQ0FBQztJQUN4QixDQUFDO0lBRVMsU0FBUztRQUNqQixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztRQUNuQixNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDeEMsV0FBVyxhQUFYLFdBQVcsdUJBQVgsV0FBVyxDQUFFLFdBQVcsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPO1FBQ0wsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUNsQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDaEIsVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztZQUNuRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDbEMsVUFBVSxDQUFDLEdBQUcsQ0FDWixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FDbkIsd0JBQXdCLENBQ3RCLE9BQWMsRUFDZCxTQUFTLEVBQ1QsR0FBRyxFQUFFO2dCQUNILElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDakIsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3JCLENBQUMsRUFDRCxDQUFDLEdBQUcsRUFBRSxFQUFFO2dCQUNOLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDakIsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyQixDQUFDLEVBQ0QsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUN2QixDQUNGLENBQ0YsQ0FBQztZQUVGLElBQUksVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN0QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztnQkFDeEIsVUFBVSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUM7WUFDbEMsQ0FBQztRQUNILENBQUM7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNOLE9BQU8sbUJBQW1CLEVBQUUsQ0FBQyxJQUFJLENBQWtCLENBQUM7SUFDdEQsQ0FBQztDQUNGIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyByZWZDb3VudCBhcyBoaWdoZXJPcmRlclJlZkNvdW50IH0gZnJvbSAnLi4vb3BlcmF0b3JzL3JlZkNvdW50JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4uL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXInO1xuaW1wb3J0IHsgaGFzTGlmdCB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5cbi8qKlxuICogQGNsYXNzIENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY4LiBVc2Uge0BsaW5rIGNvbm5lY3RhYmxlfSB0byBjcmVhdGUgYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlLlxuICogSWYgeW91IGFyZSB1c2luZyB0aGUgYHJlZkNvdW50YCBtZXRob2Qgb2YgYENvbm5lY3RhYmxlT2JzZXJ2YWJsZWAsIHVzZSB0aGUge0BsaW5rIHNoYXJlfSBvcGVyYXRvclxuICogaW5zdGVhZC5cbiAqIERldGFpbHM6IGh0dHBzOi8vcnhqcy5kZXYvZGVwcmVjYXRpb25zL211bHRpY2FzdGluZ1xuICovXG5leHBvcnQgY2xhc3MgQ29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+IGV4dGVuZHMgT2JzZXJ2YWJsZTxUPiB7XG4gIHByb3RlY3RlZCBfc3ViamVjdDogU3ViamVjdDxUPiB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgX3JlZkNvdW50OiBudW1iZXIgPSAwO1xuICBwcm90ZWN0ZWQgX2Nvbm5lY3Rpb246IFN1YnNjcmlwdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2Ugb2JzZXJ2YWJsZVxuICAgKiBAcGFyYW0gc3ViamVjdEZhY3RvcnkgVGhlIGZhY3RvcnkgdGhhdCBjcmVhdGVzIHRoZSBzdWJqZWN0IHVzZWQgaW50ZXJuYWxseS5cbiAgICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY4LiBVc2Uge0BsaW5rIGNvbm5lY3RhYmxlfSB0byBjcmVhdGUgYSBjb25uZWN0YWJsZSBvYnNlcnZhYmxlLlxuICAgKiBgbmV3IENvbm5lY3RhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIGZhY3RvcnkpYCBpcyBlcXVpdmFsZW50IHRvXG4gICAqIGBjb25uZWN0YWJsZShzb3VyY2UsIHsgY29ubmVjdG9yOiBmYWN0b3J5IH0pYC5cbiAgICogV2hlbiB0aGUgYHJlZkNvdW50KClgIG1ldGhvZCBpcyBuZWVkZWQsIHRoZSB7QGxpbmsgc2hhcmV9IG9wZXJhdG9yIHNob3VsZCBiZSB1c2VkIGluc3RlYWQ6XG4gICAqIGBuZXcgQ29ubmVjdGFibGVPYnNlcnZhYmxlKHNvdXJjZSwgZmFjdG9yeSkucmVmQ291bnQoKWAgaXMgZXF1aXZhbGVudCB0b1xuICAgKiBgc291cmNlLnBpcGUoc2hhcmUoeyBjb25uZWN0b3I6IGZhY3RvcnkgfSkpYC5cbiAgICogRGV0YWlsczogaHR0cHM6Ly9yeGpzLmRldi9kZXByZWNhdGlvbnMvbXVsdGljYXN0aW5nXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc291cmNlOiBPYnNlcnZhYmxlPFQ+LCBwcm90ZWN0ZWQgc3ViamVjdEZhY3Rvcnk6ICgpID0+IFN1YmplY3Q8VD4pIHtcbiAgICBzdXBlcigpO1xuICAgIC8vIElmIHdlIGhhdmUgbGlmdCwgbW9ua2V5IHBhdGNoIHRoYXQgaGVyZS4gVGhpcyBpcyBkb25lIHNvIGN1c3RvbSBvYnNlcnZhYmxlXG4gICAgLy8gdHlwZXMgd2lsbCBjb21wb3NlIHRocm91Z2ggbXVsdGljYXN0LiBPdGhlcndpc2UgdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIHdvdWxkXG4gICAgLy8gc2ltcGx5IGJlIGFuIGluc3RhbmNlIG9mIGBDb25uZWN0YWJsZU9ic2VydmFibGVgLlxuICAgIGlmIChoYXNMaWZ0KHNvdXJjZSkpIHtcbiAgICAgIHRoaXMubGlmdCA9IHNvdXJjZS5saWZ0O1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPikge1xuICAgIHJldHVybiB0aGlzLmdldFN1YmplY3QoKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0U3ViamVjdCgpOiBTdWJqZWN0PFQ+IHtcbiAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5fc3ViamVjdDtcbiAgICBpZiAoIXN1YmplY3QgfHwgc3ViamVjdC5pc1N0b3BwZWQpIHtcbiAgICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdWJqZWN0ITtcbiAgfVxuXG4gIHByb3RlY3RlZCBfdGVhcmRvd24oKSB7XG4gICAgdGhpcy5fcmVmQ291bnQgPSAwO1xuICAgIGNvbnN0IHsgX2Nvbm5lY3Rpb24gfSA9IHRoaXM7XG4gICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICAgIF9jb25uZWN0aW9uPy51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHtAbGluayBDb25uZWN0YWJsZU9ic2VydmFibGV9IHdpbGwgYmUgcmVtb3ZlZCBpbiB2OC4gVXNlIHtAbGluayBjb25uZWN0YWJsZX0gaW5zdGVhZC5cbiAgICogRGV0YWlsczogaHR0cHM6Ly9yeGpzLmRldi9kZXByZWNhdGlvbnMvbXVsdGljYXN0aW5nXG4gICAqL1xuICBjb25uZWN0KCk6IFN1YnNjcmlwdGlvbiB7XG4gICAgbGV0IGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uO1xuICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5nZXRTdWJqZWN0KCk7XG4gICAgICBjb25uZWN0aW9uLmFkZChcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgICAgIHN1YmplY3QgYXMgYW55LFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl90ZWFyZG93bigpO1xuICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl90ZWFyZG93bigpO1xuICAgICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5fdGVhcmRvd24oKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgaWYgKGNvbm5lY3Rpb24uY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICBjb25uZWN0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB7QGxpbmsgQ29ubmVjdGFibGVPYnNlcnZhYmxlfSB3aWxsIGJlIHJlbW92ZWQgaW4gdjguIFVzZSB0aGUge0BsaW5rIHNoYXJlfSBvcGVyYXRvciBpbnN0ZWFkLlxuICAgKiBEZXRhaWxzOiBodHRwczovL3J4anMuZGV2L2RlcHJlY2F0aW9ucy9tdWx0aWNhc3RpbmdcbiAgICovXG4gIHJlZkNvdW50KCk6IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBoaWdoZXJPcmRlclJlZkNvdW50KCkodGhpcykgYXMgT2JzZXJ2YWJsZTxUPjtcbiAgfVxufVxuIl19
