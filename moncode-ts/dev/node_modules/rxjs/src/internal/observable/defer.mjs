import { Observable } from '../Observable.mjs';
import { innerFrom } from './innerFrom.mjs';
/**
 * Creates an Observable that, on subscribe, calls an Observable factory to
 * make an Observable for each new Observer.
 *
 * <span class="informal">Creates the Observable lazily, that is, only when it
 * is subscribed.
 * </span>
 *
 * ![](defer.png)
 *
 * `defer` allows you to create an Observable only when the Observer
 * subscribes. It waits until an Observer subscribes to it, calls the given
 * factory function to get an Observable -- where a factory function typically
 * generates a new Observable -- and subscribes the Observer to this Observable.
 * In case the factory function returns a falsy value, then EMPTY is used as
 * Observable instead. Last but not least, an exception during the factory
 * function call is transferred to the Observer by calling `error`.
 *
 * ## Example
 *
 * Subscribe to either an Observable of clicks or an Observable of interval, at random
 *
 * ```ts
 * import { defer, fromEvent, interval } from 'rxjs';
 *
 * const clicksOrInterval = defer(() => {
 *   return Math.random() > 0.5
 *     ? fromEvent(document, 'click')
 *     : interval(1000);
 * });
 * clicksOrInterval.subscribe(x => console.log(x));
 *
 * // Results in the following behavior:
 * // If the result of Math.random() is greater than 0.5 it will listen
 * // for clicks anywhere on the "document"; when document is clicked it
 * // will log a MouseEvent object to the console. If the result is less
 * // than 0.5 it will emit ascending numbers, one every second(1000ms).
 * ```
 *
 * @see {@link Observable}
 *
 * @param {function(): ObservableInput} observableFactory The Observable
 * factory function to invoke for each Observer that subscribes to the output
 * Observable. May also return a Promise, which will be converted on the fly
 * to an Observable.
 * @return {Observable} An Observable whose Observers' subscriptions trigger
 * an invocation of the given Observable factory function.
 */
export function defer(observableFactory) {
    return new Observable((subscriber) => {
        innerFrom(observableFactory()).subscribe(subscriber);
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2RlZmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUV4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQ0c7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUFpQyxpQkFBMEI7SUFDOUUsT0FBTyxJQUFJLFVBQVUsQ0FBcUIsQ0FBQyxVQUFVLEVBQUUsRUFBRTtRQUN2RCxTQUFTLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN2RCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29ic2VydmFibGUvZGVmZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPYnNlcnZlZFZhbHVlT2YsIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4vaW5uZXJGcm9tJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCwgb24gc3Vic2NyaWJlLCBjYWxscyBhbiBPYnNlcnZhYmxlIGZhY3RvcnkgdG9cbiAqIG1ha2UgYW4gT2JzZXJ2YWJsZSBmb3IgZWFjaCBuZXcgT2JzZXJ2ZXIuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNyZWF0ZXMgdGhlIE9ic2VydmFibGUgbGF6aWx5LCB0aGF0IGlzLCBvbmx5IHdoZW4gaXRcbiAqIGlzIHN1YnNjcmliZWQuXG4gKiA8L3NwYW4+XG4gKlxuICogIVtdKGRlZmVyLnBuZylcbiAqXG4gKiBgZGVmZXJgIGFsbG93cyB5b3UgdG8gY3JlYXRlIGFuIE9ic2VydmFibGUgb25seSB3aGVuIHRoZSBPYnNlcnZlclxuICogc3Vic2NyaWJlcy4gSXQgd2FpdHMgdW50aWwgYW4gT2JzZXJ2ZXIgc3Vic2NyaWJlcyB0byBpdCwgY2FsbHMgdGhlIGdpdmVuXG4gKiBmYWN0b3J5IGZ1bmN0aW9uIHRvIGdldCBhbiBPYnNlcnZhYmxlIC0tIHdoZXJlIGEgZmFjdG9yeSBmdW5jdGlvbiB0eXBpY2FsbHlcbiAqIGdlbmVyYXRlcyBhIG5ldyBPYnNlcnZhYmxlIC0tIGFuZCBzdWJzY3JpYmVzIHRoZSBPYnNlcnZlciB0byB0aGlzIE9ic2VydmFibGUuXG4gKiBJbiBjYXNlIHRoZSBmYWN0b3J5IGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgdGhlbiBFTVBUWSBpcyB1c2VkIGFzXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQuIExhc3QgYnV0IG5vdCBsZWFzdCwgYW4gZXhjZXB0aW9uIGR1cmluZyB0aGUgZmFjdG9yeVxuICogZnVuY3Rpb24gY2FsbCBpcyB0cmFuc2ZlcnJlZCB0byB0aGUgT2JzZXJ2ZXIgYnkgY2FsbGluZyBgZXJyb3JgLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiBTdWJzY3JpYmUgdG8gZWl0aGVyIGFuIE9ic2VydmFibGUgb2YgY2xpY2tzIG9yIGFuIE9ic2VydmFibGUgb2YgaW50ZXJ2YWwsIGF0IHJhbmRvbVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBkZWZlciwgZnJvbUV2ZW50LCBpbnRlcnZhbCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IGNsaWNrc09ySW50ZXJ2YWwgPSBkZWZlcigoKSA9PiB7XG4gKiAgIHJldHVybiBNYXRoLnJhbmRvbSgpID4gMC41XG4gKiAgICAgPyBmcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpXG4gKiAgICAgOiBpbnRlcnZhbCgxMDAwKTtcbiAqIH0pO1xuICogY2xpY2tzT3JJbnRlcnZhbC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIGJlaGF2aW9yOlxuICogLy8gSWYgdGhlIHJlc3VsdCBvZiBNYXRoLnJhbmRvbSgpIGlzIGdyZWF0ZXIgdGhhbiAwLjUgaXQgd2lsbCBsaXN0ZW5cbiAqIC8vIGZvciBjbGlja3MgYW55d2hlcmUgb24gdGhlIFwiZG9jdW1lbnRcIjsgd2hlbiBkb2N1bWVudCBpcyBjbGlja2VkIGl0XG4gKiAvLyB3aWxsIGxvZyBhIE1vdXNlRXZlbnQgb2JqZWN0IHRvIHRoZSBjb25zb2xlLiBJZiB0aGUgcmVzdWx0IGlzIGxlc3NcbiAqIC8vIHRoYW4gMC41IGl0IHdpbGwgZW1pdCBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCgxMDAwbXMpLlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgT2JzZXJ2YWJsZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IE9ic2VydmFibGVJbnB1dH0gb2JzZXJ2YWJsZUZhY3RvcnkgVGhlIE9ic2VydmFibGVcbiAqIGZhY3RvcnkgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIE9ic2VydmVyIHRoYXQgc3Vic2NyaWJlcyB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBNYXkgYWxzbyByZXR1cm4gYSBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGNvbnZlcnRlZCBvbiB0aGUgZmx5XG4gKiB0byBhbiBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB3aG9zZSBPYnNlcnZlcnMnIHN1YnNjcmlwdGlvbnMgdHJpZ2dlclxuICogYW4gaW52b2NhdGlvbiBvZiB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmZXI8UiBleHRlbmRzIE9ic2VydmFibGVJbnB1dDxhbnk+PihvYnNlcnZhYmxlRmFjdG9yeTogKCkgPT4gUik6IE9ic2VydmFibGU8T2JzZXJ2ZWRWYWx1ZU9mPFI+PiB7XG4gIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxPYnNlcnZlZFZhbHVlT2Y8Uj4+KChzdWJzY3JpYmVyKSA9PiB7XG4gICAgaW5uZXJGcm9tKG9ic2VydmFibGVGYWN0b3J5KCkpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgfSk7XG59XG4iXX0=
