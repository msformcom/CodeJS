import { bindCallbackInternals } from './bindCallbackInternals.mjs';
/**
 * Converts a callback API to a function that returns an Observable.
 *
 * <span class="informal">Give it a function `f` of type `f(x, callback)` and
 * it will return a function `g` that when called as `g(x)` will output an
 * Observable.</span>
 *
 * `bindCallback` is not an operator because its input and output are not
 * Observables. The input is a function `func` with some parameters. The
 * last parameter must be a callback function that `func` calls when it is
 * done.
 *
 * The output of `bindCallback` is a function that takes the same parameters
 * as `func`, except the last one (the callback). When the output function
 * is called with arguments it will return an Observable. If function `func`
 * calls its callback with one argument, the Observable will emit that value.
 * If on the other hand the callback is called with multiple values the resulting
 * Observable will emit an array with said values as arguments.
 *
 * It is **very important** to remember that input function `func` is not called
 * when the output function is, but rather when the Observable returned by the output
 * function is subscribed. This means if `func` makes an AJAX request, that request
 * will be made every time someone subscribes to the resulting Observable, but not before.
 *
 * The last optional parameter - `scheduler` - can be used to control when the call
 * to `func` happens after someone subscribes to Observable, as well as when results
 * passed to callback will be emitted. By default, the subscription to an Observable calls `func`
 * synchronously, but using {@link asyncScheduler} as the last parameter will defer the call to `func`,
 * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you were to use the async Scheduler
 * and call `subscribe` on the output Observable, all function calls that are currently executing
 * will end before `func` is invoked.
 *
 * By default, results passed to the callback are emitted immediately after `func` invokes the callback.
 * In particular, if the callback is called synchronously, then the subscription of the resulting Observable
 * will call the `next` function synchronously as well.  If you want to defer that call,
 * you may use {@link asyncScheduler} just as before.  This means that by using `Scheduler.async` you can
 * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.
 *
 * Note that the Observable created by the output function will always emit a single value
 * and then complete immediately. If `func` calls the callback multiple times, values from subsequent
 * calls will not appear in the stream. If you need to listen for multiple calls,
 *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.
 *
 * If `func` depends on some context (`this` property) and is not already bound, the context of `func`
 * will be the context that the output function has at call time. In particular, if `func`
 * is called as a method of some object and if `func` is not already bound, in order to preserve the context
 * it is recommended that the context of the output function is set to that object as well.
 *
 * If the input function calls its callback in the "node style" (i.e. first argument to callback is
 * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}
 * provides convenient error handling and probably is a better choice.
 * `bindCallback` will treat such functions the same as any other and error parameters
 * (whether passed or not) will always be interpreted as regular callback argument.
 *
 * ## Examples
 *
 * ### Convert jQuery's getJSON to an Observable API
 * ```ts
 * import { bindCallback } from 'rxjs';
 * import * as jQuery from 'jquery';
 *
 * // Suppose we have jQuery.getJSON('/my/url', callback)
 * const getJSONAsObservable = bindCallback(jQuery.getJSON);
 * const result = getJSONAsObservable('/my/url');
 * result.subscribe(x => console.log(x), e => console.error(e));
 * ```
 *
 * ### Receive an array of arguments passed to a callback
 * ```ts
 * import { bindCallback } from 'rxjs';
 *
 * const someFunction = (n, s, cb) => {
 *   cb(n, s, { someProperty: 'someValue' });
 * };
 *
 * const boundSomeFunction = bindCallback(someFunction);
 * boundSomeFunction(5, 'some string').subscribe((values) => {
 *   console.log(values); // [5, 'some string', {someProperty: 'someValue'}]
 * });
 * ```
 *
 * ### Compare behaviour with and without async Scheduler
 * ```ts
 * import { bindCallback, asyncScheduler } from 'rxjs';
 *
 * function iCallMyCallbackSynchronously(cb) {
 *   cb();
 * }
 *
 * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);
 * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, asyncScheduler);
 *
 * boundSyncFn().subscribe(() => console.log('I was sync!'));
 * boundAsyncFn().subscribe(() => console.log('I was async!'));
 * console.log('This happened...');
 *
 * // Logs:
 * // I was sync!
 * // This happened...
 * // I was async!
 * ```
 *
 * ### Use bindCallback on an object method
 * ```ts
 * import { bindCallback } from 'rxjs';
 *
 * const boundMethod = bindCallback(someObject.methodWithCallback);
 * boundMethod
 *   .call(someObject) // make sure methodWithCallback has access to someObject
 *   .subscribe(subscriber);
 * ```
 *
 * @see {@link bindNodeCallback}
 * @see {@link from}
 *
 * @param {function} func A function with a callback as the last parameter.
 * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the
 * callbacks.
 * @return {function(...params: *): Observable} A function which returns the
 * Observable that delivers the same values the callback would deliver.
 */
export function bindCallback(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQWNoRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0hHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FDMUIsWUFBa0UsRUFDbEUsY0FBMEQsRUFDMUQsU0FBeUI7SUFFekIsT0FBTyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsWUFBWSxFQUFFLGNBQWMsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUMvRSxDQUFDIiwiZmlsZSI6Im5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBwcmV0dGllciAqL1xuaW1wb3J0IHsgU2NoZWR1bGVyTGlrZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGJpbmRDYWxsYmFja0ludGVybmFscyB9IGZyb20gJy4vYmluZENhbGxiYWNrSW50ZXJuYWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRDYWxsYmFjayhcbiAgY2FsbGJhY2tGdW5jOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQsXG4gIHJlc3VsdFNlbGVjdG9yOiAoLi4uYXJnczogYW55W10pID0+IGFueSxcbiAgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZVxuKTogKC4uLmFyZ3M6IGFueVtdKSA9PiBPYnNlcnZhYmxlPGFueT47XG5cbi8vIGFyZ3MgaXMgdGhlIGFyZ3VtZW50cyBhcnJheSBhbmQgd2UgcHVzaCB0aGUgY2FsbGJhY2sgb24gdGhlIHJlc3QgdHVwbGUgc2luY2UgdGhlIHJlc3QgcGFyYW1ldGVyIG11c3QgYmUgbGFzdCAob25seSBpdGVtKSBpbiBhIHBhcmFtZXRlciBsaXN0XG5leHBvcnQgZnVuY3Rpb24gYmluZENhbGxiYWNrPEEgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10sIFIgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10+KFxuICBjYWxsYmFja0Z1bmM6ICguLi5hcmdzOiBbLi4uQSwgKC4uLnJlczogUikgPT4gdm9pZF0pID0+IHZvaWQsXG4gIHNjaGVkdWxlckxpa2U/OiBTY2hlZHVsZXJMaWtlXG4pOiAoLi4uYXJnOiBBKSA9PiBPYnNlcnZhYmxlPFIgZXh0ZW5kcyBbXSA/IHZvaWQgOiBSIGV4dGVuZHMgW2FueV0gPyBSWzBdIDogUj47XG5cbi8qKlxuICogQ29udmVydHMgYSBjYWxsYmFjayBBUEkgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+R2l2ZSBpdCBhIGZ1bmN0aW9uIGBmYCBvZiB0eXBlIGBmKHgsIGNhbGxiYWNrKWAgYW5kXG4gKiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIGBnYCB0aGF0IHdoZW4gY2FsbGVkIGFzIGBnKHgpYCB3aWxsIG91dHB1dCBhblxuICogT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogYGJpbmRDYWxsYmFja2AgaXMgbm90IGFuIG9wZXJhdG9yIGJlY2F1c2UgaXRzIGlucHV0IGFuZCBvdXRwdXQgYXJlIG5vdFxuICogT2JzZXJ2YWJsZXMuIFRoZSBpbnB1dCBpcyBhIGZ1bmN0aW9uIGBmdW5jYCB3aXRoIHNvbWUgcGFyYW1ldGVycy4gVGhlXG4gKiBsYXN0IHBhcmFtZXRlciBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBgZnVuY2AgY2FsbHMgd2hlbiBpdCBpc1xuICogZG9uZS5cbiAqXG4gKiBUaGUgb3V0cHV0IG9mIGBiaW5kQ2FsbGJhY2tgIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgc2FtZSBwYXJhbWV0ZXJzXG4gKiBhcyBgZnVuY2AsIGV4Y2VwdCB0aGUgbGFzdCBvbmUgKHRoZSBjYWxsYmFjaykuIFdoZW4gdGhlIG91dHB1dCBmdW5jdGlvblxuICogaXMgY2FsbGVkIHdpdGggYXJndW1lbnRzIGl0IHdpbGwgcmV0dXJuIGFuIE9ic2VydmFibGUuIElmIGZ1bmN0aW9uIGBmdW5jYFxuICogY2FsbHMgaXRzIGNhbGxiYWNrIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgdGhhdCB2YWx1ZS5cbiAqIElmIG9uIHRoZSBvdGhlciBoYW5kIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBtdWx0aXBsZSB2YWx1ZXMgdGhlIHJlc3VsdGluZ1xuICogT2JzZXJ2YWJsZSB3aWxsIGVtaXQgYW4gYXJyYXkgd2l0aCBzYWlkIHZhbHVlcyBhcyBhcmd1bWVudHMuXG4gKlxuICogSXQgaXMgKip2ZXJ5IGltcG9ydGFudCoqIHRvIHJlbWVtYmVyIHRoYXQgaW5wdXQgZnVuY3Rpb24gYGZ1bmNgIGlzIG5vdCBjYWxsZWRcbiAqIHdoZW4gdGhlIG91dHB1dCBmdW5jdGlvbiBpcywgYnV0IHJhdGhlciB3aGVuIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGJ5IHRoZSBvdXRwdXRcbiAqIGZ1bmN0aW9uIGlzIHN1YnNjcmliZWQuIFRoaXMgbWVhbnMgaWYgYGZ1bmNgIG1ha2VzIGFuIEFKQVggcmVxdWVzdCwgdGhhdCByZXF1ZXN0XG4gKiB3aWxsIGJlIG1hZGUgZXZlcnkgdGltZSBzb21lb25lIHN1YnNjcmliZXMgdG8gdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlLCBidXQgbm90IGJlZm9yZS5cbiAqXG4gKiBUaGUgbGFzdCBvcHRpb25hbCBwYXJhbWV0ZXIgLSBgc2NoZWR1bGVyYCAtIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgd2hlbiB0aGUgY2FsbFxuICogdG8gYGZ1bmNgIGhhcHBlbnMgYWZ0ZXIgc29tZW9uZSBzdWJzY3JpYmVzIHRvIE9ic2VydmFibGUsIGFzIHdlbGwgYXMgd2hlbiByZXN1bHRzXG4gKiBwYXNzZWQgdG8gY2FsbGJhY2sgd2lsbCBiZSBlbWl0dGVkLiBCeSBkZWZhdWx0LCB0aGUgc3Vic2NyaXB0aW9uIHRvIGFuIE9ic2VydmFibGUgY2FsbHMgYGZ1bmNgXG4gKiBzeW5jaHJvbm91c2x5LCBidXQgdXNpbmcge0BsaW5rIGFzeW5jU2NoZWR1bGVyfSBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgd2lsbCBkZWZlciB0aGUgY2FsbCB0byBgZnVuY2AsXG4gKiBqdXN0IGxpa2Ugd3JhcHBpbmcgdGhlIGNhbGwgaW4gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYCB3b3VsZC4gSWYgeW91IHdlcmUgdG8gdXNlIHRoZSBhc3luYyBTY2hlZHVsZXJcbiAqIGFuZCBjYWxsIGBzdWJzY3JpYmVgIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYWxsIGZ1bmN0aW9uIGNhbGxzIHRoYXQgYXJlIGN1cnJlbnRseSBleGVjdXRpbmdcbiAqIHdpbGwgZW5kIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAqXG4gKiBCeSBkZWZhdWx0LCByZXN1bHRzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgYXJlIGVtaXR0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYGZ1bmNgIGludm9rZXMgdGhlIGNhbGxiYWNrLlxuICogSW4gcGFydGljdWxhciwgaWYgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5LCB0aGVuIHRoZSBzdWJzY3JpcHRpb24gb2YgdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlXG4gKiB3aWxsIGNhbGwgdGhlIGBuZXh0YCBmdW5jdGlvbiBzeW5jaHJvbm91c2x5IGFzIHdlbGwuICBJZiB5b3Ugd2FudCB0byBkZWZlciB0aGF0IGNhbGwsXG4gKiB5b3UgbWF5IHVzZSB7QGxpbmsgYXN5bmNTY2hlZHVsZXJ9IGp1c3QgYXMgYmVmb3JlLiAgVGhpcyBtZWFucyB0aGF0IGJ5IHVzaW5nIGBTY2hlZHVsZXIuYXN5bmNgIHlvdSBjYW5cbiAqIGVuc3VyZSB0aGF0IGBmdW5jYCBhbHdheXMgY2FsbHMgaXRzIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5LCB0aHVzIGF2b2lkaW5nIHRlcnJpZnlpbmcgWmFsZ28uXG4gKlxuICogTm90ZSB0aGF0IHRoZSBPYnNlcnZhYmxlIGNyZWF0ZWQgYnkgdGhlIG91dHB1dCBmdW5jdGlvbiB3aWxsIGFsd2F5cyBlbWl0IGEgc2luZ2xlIHZhbHVlXG4gKiBhbmQgdGhlbiBjb21wbGV0ZSBpbW1lZGlhdGVseS4gSWYgYGZ1bmNgIGNhbGxzIHRoZSBjYWxsYmFjayBtdWx0aXBsZSB0aW1lcywgdmFsdWVzIGZyb20gc3Vic2VxdWVudFxuICogY2FsbHMgd2lsbCBub3QgYXBwZWFyIGluIHRoZSBzdHJlYW0uIElmIHlvdSBuZWVkIHRvIGxpc3RlbiBmb3IgbXVsdGlwbGUgY2FsbHMsXG4gKiAgeW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIHtAbGluayBmcm9tRXZlbnR9IG9yIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufSBpbnN0ZWFkLlxuICpcbiAqIElmIGBmdW5jYCBkZXBlbmRzIG9uIHNvbWUgY29udGV4dCAoYHRoaXNgIHByb3BlcnR5KSBhbmQgaXMgbm90IGFscmVhZHkgYm91bmQsIHRoZSBjb250ZXh0IG9mIGBmdW5jYFxuICogd2lsbCBiZSB0aGUgY29udGV4dCB0aGF0IHRoZSBvdXRwdXQgZnVuY3Rpb24gaGFzIGF0IGNhbGwgdGltZS4gSW4gcGFydGljdWxhciwgaWYgYGZ1bmNgXG4gKiBpcyBjYWxsZWQgYXMgYSBtZXRob2Qgb2Ygc29tZSBvYmplY3QgYW5kIGlmIGBmdW5jYCBpcyBub3QgYWxyZWFkeSBib3VuZCwgaW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIGNvbnRleHRcbiAqIGl0IGlzIHJlY29tbWVuZGVkIHRoYXQgdGhlIGNvbnRleHQgb2YgdGhlIG91dHB1dCBmdW5jdGlvbiBpcyBzZXQgdG8gdGhhdCBvYmplY3QgYXMgd2VsbC5cbiAqXG4gKiBJZiB0aGUgaW5wdXQgZnVuY3Rpb24gY2FsbHMgaXRzIGNhbGxiYWNrIGluIHRoZSBcIm5vZGUgc3R5bGVcIiAoaS5lLiBmaXJzdCBhcmd1bWVudCB0byBjYWxsYmFjayBpc1xuICogb3B0aW9uYWwgZXJyb3IgcGFyYW1ldGVyIHNpZ25hbGluZyB3aGV0aGVyIHRoZSBjYWxsIGZhaWxlZCBvciBub3QpLCB7QGxpbmsgYmluZE5vZGVDYWxsYmFja31cbiAqIHByb3ZpZGVzIGNvbnZlbmllbnQgZXJyb3IgaGFuZGxpbmcgYW5kIHByb2JhYmx5IGlzIGEgYmV0dGVyIGNob2ljZS5cbiAqIGBiaW5kQ2FsbGJhY2tgIHdpbGwgdHJlYXQgc3VjaCBmdW5jdGlvbnMgdGhlIHNhbWUgYXMgYW55IG90aGVyIGFuZCBlcnJvciBwYXJhbWV0ZXJzXG4gKiAod2hldGhlciBwYXNzZWQgb3Igbm90KSB3aWxsIGFsd2F5cyBiZSBpbnRlcnByZXRlZCBhcyByZWd1bGFyIGNhbGxiYWNrIGFyZ3VtZW50LlxuICpcbiAqICMjIEV4YW1wbGVzXG4gKlxuICogIyMjIENvbnZlcnQgalF1ZXJ5J3MgZ2V0SlNPTiB0byBhbiBPYnNlcnZhYmxlIEFQSVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGJpbmRDYWxsYmFjayB9IGZyb20gJ3J4anMnO1xuICogaW1wb3J0ICogYXMgalF1ZXJ5IGZyb20gJ2pxdWVyeSc7XG4gKlxuICogLy8gU3VwcG9zZSB3ZSBoYXZlIGpRdWVyeS5nZXRKU09OKCcvbXkvdXJsJywgY2FsbGJhY2spXG4gKiBjb25zdCBnZXRKU09OQXNPYnNlcnZhYmxlID0gYmluZENhbGxiYWNrKGpRdWVyeS5nZXRKU09OKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGdldEpTT05Bc09ic2VydmFibGUoJy9teS91cmwnKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgZSA9PiBjb25zb2xlLmVycm9yKGUpKTtcbiAqIGBgYFxuICpcbiAqICMjIyBSZWNlaXZlIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gYSBjYWxsYmFja1xuICogYGBgdHNcbiAqIGltcG9ydCB7IGJpbmRDYWxsYmFjayB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IHNvbWVGdW5jdGlvbiA9IChuLCBzLCBjYikgPT4ge1xuICogICBjYihuLCBzLCB7IHNvbWVQcm9wZXJ0eTogJ3NvbWVWYWx1ZScgfSk7XG4gKiB9O1xuICpcbiAqIGNvbnN0IGJvdW5kU29tZUZ1bmN0aW9uID0gYmluZENhbGxiYWNrKHNvbWVGdW5jdGlvbik7XG4gKiBib3VuZFNvbWVGdW5jdGlvbig1LCAnc29tZSBzdHJpbmcnKS5zdWJzY3JpYmUoKHZhbHVlcykgPT4ge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZXMpOyAvLyBbNSwgJ3NvbWUgc3RyaW5nJywge3NvbWVQcm9wZXJ0eTogJ3NvbWVWYWx1ZSd9XVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAjIyMgQ29tcGFyZSBiZWhhdmlvdXIgd2l0aCBhbmQgd2l0aG91dCBhc3luYyBTY2hlZHVsZXJcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBiaW5kQ2FsbGJhY2ssIGFzeW5jU2NoZWR1bGVyIH0gZnJvbSAncnhqcyc7XG4gKlxuICogZnVuY3Rpb24gaUNhbGxNeUNhbGxiYWNrU3luY2hyb25vdXNseShjYikge1xuICogICBjYigpO1xuICogfVxuICpcbiAqIGNvbnN0IGJvdW5kU3luY0ZuID0gYmluZENhbGxiYWNrKGlDYWxsTXlDYWxsYmFja1N5bmNocm9ub3VzbHkpO1xuICogY29uc3QgYm91bmRBc3luY0ZuID0gYmluZENhbGxiYWNrKGlDYWxsTXlDYWxsYmFja1N5bmNocm9ub3VzbHksIG51bGwsIGFzeW5jU2NoZWR1bGVyKTtcbiAqXG4gKiBib3VuZFN5bmNGbigpLnN1YnNjcmliZSgoKSA9PiBjb25zb2xlLmxvZygnSSB3YXMgc3luYyEnKSk7XG4gKiBib3VuZEFzeW5jRm4oKS5zdWJzY3JpYmUoKCkgPT4gY29uc29sZS5sb2coJ0kgd2FzIGFzeW5jIScpKTtcbiAqIGNvbnNvbGUubG9nKCdUaGlzIGhhcHBlbmVkLi4uJyk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIEkgd2FzIHN5bmMhXG4gKiAvLyBUaGlzIGhhcHBlbmVkLi4uXG4gKiAvLyBJIHdhcyBhc3luYyFcbiAqIGBgYFxuICpcbiAqICMjIyBVc2UgYmluZENhbGxiYWNrIG9uIGFuIG9iamVjdCBtZXRob2RcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBiaW5kQ2FsbGJhY2sgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBib3VuZE1ldGhvZCA9IGJpbmRDYWxsYmFjayhzb21lT2JqZWN0Lm1ldGhvZFdpdGhDYWxsYmFjayk7XG4gKiBib3VuZE1ldGhvZFxuICogICAuY2FsbChzb21lT2JqZWN0KSAvLyBtYWtlIHN1cmUgbWV0aG9kV2l0aENhbGxiYWNrIGhhcyBhY2Nlc3MgdG8gc29tZU9iamVjdFxuICogICAuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgYmluZE5vZGVDYWxsYmFja31cbiAqIEBzZWUge0BsaW5rIGZyb219XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBBIGZ1bmN0aW9uIHdpdGggYSBjYWxsYmFjayBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge1NjaGVkdWxlckxpa2V9IFtzY2hlZHVsZXJdIFRoZSBzY2hlZHVsZXIgb24gd2hpY2ggdG8gc2NoZWR1bGUgdGhlXG4gKiBjYWxsYmFja3MuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5wYXJhbXM6ICopOiBPYnNlcnZhYmxlfSBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gKiBPYnNlcnZhYmxlIHRoYXQgZGVsaXZlcnMgdGhlIHNhbWUgdmFsdWVzIHRoZSBjYWxsYmFjayB3b3VsZCBkZWxpdmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZENhbGxiYWNrKFxuICBjYWxsYmFja0Z1bmM6ICguLi5hcmdzOiBbLi4uYW55W10sICguLi5yZXM6IGFueSkgPT4gdm9pZF0pID0+IHZvaWQsXG4gIHJlc3VsdFNlbGVjdG9yPzogKCguLi5hcmdzOiBhbnlbXSkgPT4gYW55KSB8IFNjaGVkdWxlckxpa2UsXG4gIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2Vcbik6ICguLi5hcmdzOiBhbnlbXSkgPT4gT2JzZXJ2YWJsZTx1bmtub3duPiB7XG4gIHJldHVybiBiaW5kQ2FsbGJhY2tJbnRlcm5hbHMoZmFsc2UsIGNhbGxiYWNrRnVuYywgcmVzdWx0U2VsZWN0b3IsIHNjaGVkdWxlcik7XG59XG4iXX0=
