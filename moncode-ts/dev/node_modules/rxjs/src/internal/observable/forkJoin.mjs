import { Observable } from '../Observable.mjs';
import { argsArgArrayOrObject } from '../util/argsArgArrayOrObject.mjs';
import { innerFrom } from './innerFrom.mjs';
import { popResultSelector } from '../util/args.mjs';
import { createOperatorSubscriber } from '../operators/OperatorSubscriber.mjs';
import { mapOneOrManyArgs } from '../util/mapOneOrManyArgs.mjs';
import { createObject } from '../util/createObject.mjs';
/**
 * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns
 * an {@link Observable} that emits either an array of values in the exact same order as the passed array,
 * or a dictionary of values in the same shape as the passed dictionary.
 *
 * <span class="informal">Wait for Observables to complete and then combine last values they emitted;
 * complete immediately if an empty array is passed.</span>
 *
 * ![](forkJoin.png)
 *
 * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array
 * or a dictionary of input observables. If no input observables are provided (e.g. an empty array is passed),
 * then the resulting stream will complete immediately.
 *
 * `forkJoin` will wait for all passed observables to emit and complete and then it will emit an array or an object with last
 * values from corresponding observables.
 *
 * If you pass an array of `n` observables to the operator, then the resulting
 * array will have `n` values, where the first value is the last one emitted by the first observable,
 * second value is the last one emitted by the second observable and so on.
 *
 * If you pass a dictionary of observables to the operator, then the resulting
 * objects will have the same keys as the dictionary passed, with their last values they have emitted
 * located at the corresponding key.
 *
 * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined
 * values not only at the end of the lifecycle of passed observables, but also throughout it, try out {@link combineLatest}
 * or {@link zip} instead.
 *
 * In order for the resulting array to have the same length as the number of input observables, whenever any of
 * the given observables completes without emitting any value, `forkJoin` will complete at that moment as well
 * and it will not emit anything either, even if it already has some last values from other observables.
 * Conversely, if there is an observable that never completes, `forkJoin` will never complete either,
 * unless at any point some other observable completes without emitting a value, which brings us back to
 * the previous case. Overall, in order for `forkJoin` to emit a value, all given observables
 * have to emit something at least once and complete.
 *
 * If any given observable errors at some point, `forkJoin` will error as well and immediately unsubscribe
 * from the other observables.
 *
 * Optionally `forkJoin` accepts a `resultSelector` function, that will be called with values which normally
 * would land in the emitted array. Whatever is returned by the `resultSelector`, will appear in the output
 * observable instead. This means that the default `resultSelector` can be thought of as a function that takes
 * all its arguments and puts them into an array. Note that the `resultSelector` will be called only
 * when `forkJoin` is supposed to emit a result.
 *
 * ## Examples
 *
 * Use `forkJoin` with a dictionary of observable inputs
 *
 * ```ts
 * import { forkJoin, of, timer } from 'rxjs';
 *
 * const observable = forkJoin({
 *   foo: of(1, 2, 3, 4),
 *   bar: Promise.resolve(8),
 *   baz: timer(4000)
 * });
 * observable.subscribe({
 *  next: value => console.log(value),
 *  complete: () => console.log('This is how it ends!'),
 * });
 *
 * // Logs:
 * // { foo: 4, bar: 8, baz: 0 } after 4 seconds
 * // 'This is how it ends!' immediately after
 * ```
 *
 * Use `forkJoin` with an array of observable inputs
 *
 * ```ts
 * import { forkJoin, of, timer } from 'rxjs';
 *
 * const observable = forkJoin([
 *   of(1, 2, 3, 4),
 *   Promise.resolve(8),
 *   timer(4000)
 * ]);
 * observable.subscribe({
 *  next: value => console.log(value),
 *  complete: () => console.log('This is how it ends!'),
 * });
 *
 * // Logs:
 * // [4, 8, 0] after 4 seconds
 * // 'This is how it ends!' immediately after
 * ```
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 *
 * @param {...ObservableInput} args Any number of Observables provided either as an array or as an arguments
 * passed directly to the operator.
 * @param {function} [project] Function that takes values emitted by input Observables and returns value
 * that will appear in resulting Observable instead of default array.
 * @return {Observable} Observable emitting either an array of last values emitted by passed Observables
 * or value from project function.
 */
export function forkJoin(...args) {
    const resultSelector = popResultSelector(args);
    const { args: sources, keys } = argsArgArrayOrObject(args);
    const result = new Observable((subscriber) => {
        const { length } = sources;
        if (!length) {
            subscriber.complete();
            return;
        }
        const values = new Array(length);
        let remainingCompletions = length;
        let remainingEmissions = length;
        for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {
            let hasValue = false;
            innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, (value) => {
                if (!hasValue) {
                    hasValue = true;
                    remainingEmissions--;
                }
                values[sourceIndex] = value;
            }, () => remainingCompletions--, undefined, () => {
                if (!remainingCompletions || !hasValue) {
                    if (!remainingEmissions) {
                        subscriber.next(keys ? createObject(keys, values) : values);
                    }
                    subscriber.complete();
                }
            }));
        }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2ZvcmtKb2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDcEUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN4QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDakQsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0UsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDNUQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBeUNwRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWlHRztBQUNILE1BQU0sVUFBVSxRQUFRLENBQUMsR0FBRyxJQUFXO0lBQ3JDLE1BQU0sY0FBYyxHQUFHLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQy9DLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxHQUFHLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNELE1BQU0sTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUU7UUFDM0MsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUMzQixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDWixVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDdEIsT0FBTztRQUNULENBQUM7UUFDRCxNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNqQyxJQUFJLG9CQUFvQixHQUFHLE1BQU0sQ0FBQztRQUNsQyxJQUFJLGtCQUFrQixHQUFHLE1BQU0sQ0FBQztRQUNoQyxLQUFLLElBQUksV0FBVyxHQUFHLENBQUMsRUFBRSxXQUFXLEdBQUcsTUFBTSxFQUFFLFdBQVcsRUFBRSxFQUFFLENBQUM7WUFDOUQsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1lBQ3JCLFNBQVMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQ3ZDLHdCQUF3QixDQUN0QixVQUFVLEVBQ1YsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDUixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQ2QsUUFBUSxHQUFHLElBQUksQ0FBQztvQkFDaEIsa0JBQWtCLEVBQUUsQ0FBQztnQkFDdkIsQ0FBQztnQkFDRCxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsS0FBSyxDQUFDO1lBQzlCLENBQUMsRUFDRCxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsRUFBRSxFQUM1QixTQUFTLEVBQ1QsR0FBRyxFQUFFO2dCQUNILElBQUksQ0FBQyxvQkFBb0IsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUN2QyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQzt3QkFDeEIsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUM5RCxDQUFDO29CQUNELFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDeEIsQ0FBQztZQUNILENBQUMsQ0FDRixDQUNGLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLGNBQWMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDakYsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mb3JrSm9pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9ic2VydmVkVmFsdWVPZiwgT2JzZXJ2YWJsZUlucHV0VHVwbGUsIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFyZ3NBcmdBcnJheU9yT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9hcmdzQXJnQXJyYXlPck9iamVjdCc7XG5pbXBvcnQgeyBpbm5lckZyb20gfSBmcm9tICcuL2lubmVyRnJvbSc7XG5pbXBvcnQgeyBwb3BSZXN1bHRTZWxlY3RvciB9IGZyb20gJy4uL3V0aWwvYXJncyc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuLi9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IG1hcE9uZU9yTWFueUFyZ3MgfSBmcm9tICcuLi91dGlsL21hcE9uZU9yTWFueUFyZ3MnO1xuaW1wb3J0IHsgY3JlYXRlT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9jcmVhdGVPYmplY3QnO1xuaW1wb3J0IHsgQW55Q2F0Y2hlciB9IGZyb20gJy4uL0FueUNhdGNoZXInO1xuXG4vLyBmb3JrSm9pbihhbnkpXG4vLyBXZSBwdXQgdGhpcyBmaXJzdCBiZWNhdXNlIHdlIG5lZWQgdG8gY2F0Y2ggY2FzZXMgd2hlcmUgdGhlIHVzZXIgaGFzIHN1cHBsaWVkXG4vLyBfZXhhY3RseSBgYW55YF8gYXMgdGhlIGFyZ3VtZW50LiBTaW5jZSBgYW55YCBsaXRlcmFsbHkgbWF0Y2hlcyBfYW55dGhpbmdfLFxuLy8gd2UgZG9uJ3Qgd2FudCBpdCB0byByYW5kb21seSBoaXQgb25lIG9mIHRoZSBvdGhlciB0eXBlIHNpZ25hdHVyZXMgYmVsb3csXG4vLyBhcyB3ZSBoYXZlIG5vIGlkZWEgYXQgYnVpbGQtdGltZSB3aGF0IHR5cGUgd2Ugc2hvdWxkIGJlIHJldHVybmluZyB3aGVuIGdpdmVuIGFuIGFueS5cblxuLyoqXG4gKiBZb3UgaGF2ZSBwYXNzZWQgYGFueWAgaGVyZSwgd2UgY2FuJ3QgZmlndXJlIG91dCBpZiBpdCBpc1xuICogYW4gYXJyYXkgb3IgYW4gb2JqZWN0LCBzbyB5b3UncmUgZ2V0dGluZyBgdW5rbm93bmAuIFVzZSBiZXR0ZXIgdHlwZXMuXG4gKiBAcGFyYW0gYXJnIFNvbWV0aGluZyB0eXBlZCBhcyBgYW55YFxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ya0pvaW48VCBleHRlbmRzIEFueUNhdGNoZXI+KGFyZzogVCk6IE9ic2VydmFibGU8dW5rbm93bj47XG5cbi8vIGZvcmtKb2luKG51bGwgfCB1bmRlZmluZWQpXG5leHBvcnQgZnVuY3Rpb24gZm9ya0pvaW4oc2NoZWR1bGVyOiBudWxsIHwgdW5kZWZpbmVkKTogT2JzZXJ2YWJsZTxuZXZlcj47XG5cbi8vIGZvcmtKb2luKFthLCBiLCBjXSlcbmV4cG9ydCBmdW5jdGlvbiBmb3JrSm9pbihzb3VyY2VzOiByZWFkb25seSBbXSk6IE9ic2VydmFibGU8bmV2ZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIGZvcmtKb2luPEEgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10+KHNvdXJjZXM6IHJlYWRvbmx5IFsuLi5PYnNlcnZhYmxlSW5wdXRUdXBsZTxBPl0pOiBPYnNlcnZhYmxlPEE+O1xuZXhwb3J0IGZ1bmN0aW9uIGZvcmtKb2luPEEgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10sIFI+KFxuICBzb3VyY2VzOiByZWFkb25seSBbLi4uT2JzZXJ2YWJsZUlucHV0VHVwbGU8QT5dLFxuICByZXN1bHRTZWxlY3RvcjogKC4uLnZhbHVlczogQSkgPT4gUlxuKTogT2JzZXJ2YWJsZTxSPjtcblxuLy8gZm9ya0pvaW4oYSwgYiwgYylcbi8qKiBAZGVwcmVjYXRlZCBQYXNzIGFuIGFycmF5IG9mIHNvdXJjZXMgaW5zdGVhZC4gVGhlIHJlc3QtcGFyYW1ldGVycyBzaWduYXR1cmUgd2lsbCBiZSByZW1vdmVkIGluIHY4LiBEZXRhaWxzOiBodHRwczovL3J4anMuZGV2L2RlcHJlY2F0aW9ucy9hcnJheS1hcmd1bWVudCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcmtKb2luPEEgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10+KC4uLnNvdXJjZXM6IFsuLi5PYnNlcnZhYmxlSW5wdXRUdXBsZTxBPl0pOiBPYnNlcnZhYmxlPEE+O1xuLyoqIEBkZXByZWNhdGVkIFBhc3MgYW4gYXJyYXkgb2Ygc291cmNlcyBpbnN0ZWFkLiBUaGUgcmVzdC1wYXJhbWV0ZXJzIHNpZ25hdHVyZSB3aWxsIGJlIHJlbW92ZWQgaW4gdjguIERldGFpbHM6IGh0dHBzOi8vcnhqcy5kZXYvZGVwcmVjYXRpb25zL2FycmF5LWFyZ3VtZW50ICovXG5leHBvcnQgZnVuY3Rpb24gZm9ya0pvaW48QSBleHRlbmRzIHJlYWRvbmx5IHVua25vd25bXSwgUj4oXG4gIC4uLnNvdXJjZXNBbmRSZXN1bHRTZWxlY3RvcjogWy4uLk9ic2VydmFibGVJbnB1dFR1cGxlPEE+LCAoLi4udmFsdWVzOiBBKSA9PiBSXVxuKTogT2JzZXJ2YWJsZTxSPjtcblxuLy8gZm9ya0pvaW4oe2EsIGIsIGN9KVxuZXhwb3J0IGZ1bmN0aW9uIGZvcmtKb2luKHNvdXJjZXNPYmplY3Q6IHsgW0sgaW4gYW55XTogbmV2ZXIgfSk6IE9ic2VydmFibGU8bmV2ZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIGZvcmtKb2luPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBPYnNlcnZhYmxlSW5wdXQ8YW55Pj4+KFxuICBzb3VyY2VzT2JqZWN0OiBUXG4pOiBPYnNlcnZhYmxlPHsgW0sgaW4ga2V5b2YgVF06IE9ic2VydmVkVmFsdWVPZjxUW0tdPiB9PjtcblxuLyoqXG4gKiBBY2NlcHRzIGFuIGBBcnJheWAgb2Yge0BsaW5rIE9ic2VydmFibGVJbnB1dH0gb3IgYSBkaWN0aW9uYXJ5IGBPYmplY3RgIG9mIHtAbGluayBPYnNlcnZhYmxlSW5wdXR9IGFuZCByZXR1cm5zXG4gKiBhbiB7QGxpbmsgT2JzZXJ2YWJsZX0gdGhhdCBlbWl0cyBlaXRoZXIgYW4gYXJyYXkgb2YgdmFsdWVzIGluIHRoZSBleGFjdCBzYW1lIG9yZGVyIGFzIHRoZSBwYXNzZWQgYXJyYXksXG4gKiBvciBhIGRpY3Rpb25hcnkgb2YgdmFsdWVzIGluIHRoZSBzYW1lIHNoYXBlIGFzIHRoZSBwYXNzZWQgZGljdGlvbmFyeS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V2FpdCBmb3IgT2JzZXJ2YWJsZXMgdG8gY29tcGxldGUgYW5kIHRoZW4gY29tYmluZSBsYXN0IHZhbHVlcyB0aGV5IGVtaXR0ZWQ7XG4gKiBjb21wbGV0ZSBpbW1lZGlhdGVseSBpZiBhbiBlbXB0eSBhcnJheSBpcyBwYXNzZWQuPC9zcGFuPlxuICpcbiAqICFbXShmb3JrSm9pbi5wbmcpXG4gKlxuICogYGZvcmtKb2luYCBpcyBhbiBvcGVyYXRvciB0aGF0IHRha2VzIGFueSBudW1iZXIgb2YgaW5wdXQgb2JzZXJ2YWJsZXMgd2hpY2ggY2FuIGJlIHBhc3NlZCBlaXRoZXIgYXMgYW4gYXJyYXlcbiAqIG9yIGEgZGljdGlvbmFyeSBvZiBpbnB1dCBvYnNlcnZhYmxlcy4gSWYgbm8gaW5wdXQgb2JzZXJ2YWJsZXMgYXJlIHByb3ZpZGVkIChlLmcuIGFuIGVtcHR5IGFycmF5IGlzIHBhc3NlZCksXG4gKiB0aGVuIHRoZSByZXN1bHRpbmcgc3RyZWFtIHdpbGwgY29tcGxldGUgaW1tZWRpYXRlbHkuXG4gKlxuICogYGZvcmtKb2luYCB3aWxsIHdhaXQgZm9yIGFsbCBwYXNzZWQgb2JzZXJ2YWJsZXMgdG8gZW1pdCBhbmQgY29tcGxldGUgYW5kIHRoZW4gaXQgd2lsbCBlbWl0IGFuIGFycmF5IG9yIGFuIG9iamVjdCB3aXRoIGxhc3RcbiAqIHZhbHVlcyBmcm9tIGNvcnJlc3BvbmRpbmcgb2JzZXJ2YWJsZXMuXG4gKlxuICogSWYgeW91IHBhc3MgYW4gYXJyYXkgb2YgYG5gIG9ic2VydmFibGVzIHRvIHRoZSBvcGVyYXRvciwgdGhlbiB0aGUgcmVzdWx0aW5nXG4gKiBhcnJheSB3aWxsIGhhdmUgYG5gIHZhbHVlcywgd2hlcmUgdGhlIGZpcnN0IHZhbHVlIGlzIHRoZSBsYXN0IG9uZSBlbWl0dGVkIGJ5IHRoZSBmaXJzdCBvYnNlcnZhYmxlLFxuICogc2Vjb25kIHZhbHVlIGlzIHRoZSBsYXN0IG9uZSBlbWl0dGVkIGJ5IHRoZSBzZWNvbmQgb2JzZXJ2YWJsZSBhbmQgc28gb24uXG4gKlxuICogSWYgeW91IHBhc3MgYSBkaWN0aW9uYXJ5IG9mIG9ic2VydmFibGVzIHRvIHRoZSBvcGVyYXRvciwgdGhlbiB0aGUgcmVzdWx0aW5nXG4gKiBvYmplY3RzIHdpbGwgaGF2ZSB0aGUgc2FtZSBrZXlzIGFzIHRoZSBkaWN0aW9uYXJ5IHBhc3NlZCwgd2l0aCB0aGVpciBsYXN0IHZhbHVlcyB0aGV5IGhhdmUgZW1pdHRlZFxuICogbG9jYXRlZCBhdCB0aGUgY29ycmVzcG9uZGluZyBrZXkuXG4gKlxuICogVGhhdCBtZWFucyBgZm9ya0pvaW5gIHdpbGwgbm90IGVtaXQgbW9yZSB0aGFuIG9uY2UgYW5kIGl0IHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhhdC4gSWYgeW91IG5lZWQgdG8gZW1pdCBjb21iaW5lZFxuICogdmFsdWVzIG5vdCBvbmx5IGF0IHRoZSBlbmQgb2YgdGhlIGxpZmVjeWNsZSBvZiBwYXNzZWQgb2JzZXJ2YWJsZXMsIGJ1dCBhbHNvIHRocm91Z2hvdXQgaXQsIHRyeSBvdXQge0BsaW5rIGNvbWJpbmVMYXRlc3R9XG4gKiBvciB7QGxpbmsgemlwfSBpbnN0ZWFkLlxuICpcbiAqIEluIG9yZGVyIGZvciB0aGUgcmVzdWx0aW5nIGFycmF5IHRvIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBudW1iZXIgb2YgaW5wdXQgb2JzZXJ2YWJsZXMsIHdoZW5ldmVyIGFueSBvZlxuICogdGhlIGdpdmVuIG9ic2VydmFibGVzIGNvbXBsZXRlcyB3aXRob3V0IGVtaXR0aW5nIGFueSB2YWx1ZSwgYGZvcmtKb2luYCB3aWxsIGNvbXBsZXRlIGF0IHRoYXQgbW9tZW50IGFzIHdlbGxcbiAqIGFuZCBpdCB3aWxsIG5vdCBlbWl0IGFueXRoaW5nIGVpdGhlciwgZXZlbiBpZiBpdCBhbHJlYWR5IGhhcyBzb21lIGxhc3QgdmFsdWVzIGZyb20gb3RoZXIgb2JzZXJ2YWJsZXMuXG4gKiBDb252ZXJzZWx5LCBpZiB0aGVyZSBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgbmV2ZXIgY29tcGxldGVzLCBgZm9ya0pvaW5gIHdpbGwgbmV2ZXIgY29tcGxldGUgZWl0aGVyLFxuICogdW5sZXNzIGF0IGFueSBwb2ludCBzb21lIG90aGVyIG9ic2VydmFibGUgY29tcGxldGVzIHdpdGhvdXQgZW1pdHRpbmcgYSB2YWx1ZSwgd2hpY2ggYnJpbmdzIHVzIGJhY2sgdG9cbiAqIHRoZSBwcmV2aW91cyBjYXNlLiBPdmVyYWxsLCBpbiBvcmRlciBmb3IgYGZvcmtKb2luYCB0byBlbWl0IGEgdmFsdWUsIGFsbCBnaXZlbiBvYnNlcnZhYmxlc1xuICogaGF2ZSB0byBlbWl0IHNvbWV0aGluZyBhdCBsZWFzdCBvbmNlIGFuZCBjb21wbGV0ZS5cbiAqXG4gKiBJZiBhbnkgZ2l2ZW4gb2JzZXJ2YWJsZSBlcnJvcnMgYXQgc29tZSBwb2ludCwgYGZvcmtKb2luYCB3aWxsIGVycm9yIGFzIHdlbGwgYW5kIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJlXG4gKiBmcm9tIHRoZSBvdGhlciBvYnNlcnZhYmxlcy5cbiAqXG4gKiBPcHRpb25hbGx5IGBmb3JrSm9pbmAgYWNjZXB0cyBhIGByZXN1bHRTZWxlY3RvcmAgZnVuY3Rpb24sIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB2YWx1ZXMgd2hpY2ggbm9ybWFsbHlcbiAqIHdvdWxkIGxhbmQgaW4gdGhlIGVtaXR0ZWQgYXJyYXkuIFdoYXRldmVyIGlzIHJldHVybmVkIGJ5IHRoZSBgcmVzdWx0U2VsZWN0b3JgLCB3aWxsIGFwcGVhciBpbiB0aGUgb3V0cHV0XG4gKiBvYnNlcnZhYmxlIGluc3RlYWQuIFRoaXMgbWVhbnMgdGhhdCB0aGUgZGVmYXVsdCBgcmVzdWx0U2VsZWN0b3JgIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGEgZnVuY3Rpb24gdGhhdCB0YWtlc1xuICogYWxsIGl0cyBhcmd1bWVudHMgYW5kIHB1dHMgdGhlbSBpbnRvIGFuIGFycmF5LiBOb3RlIHRoYXQgdGhlIGByZXN1bHRTZWxlY3RvcmAgd2lsbCBiZSBjYWxsZWQgb25seVxuICogd2hlbiBgZm9ya0pvaW5gIGlzIHN1cHBvc2VkIHRvIGVtaXQgYSByZXN1bHQuXG4gKlxuICogIyMgRXhhbXBsZXNcbiAqXG4gKiBVc2UgYGZvcmtKb2luYCB3aXRoIGEgZGljdGlvbmFyeSBvZiBvYnNlcnZhYmxlIGlucHV0c1xuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmb3JrSm9pbiwgb2YsIHRpbWVyIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3Qgb2JzZXJ2YWJsZSA9IGZvcmtKb2luKHtcbiAqICAgZm9vOiBvZigxLCAyLCAzLCA0KSxcbiAqICAgYmFyOiBQcm9taXNlLnJlc29sdmUoOCksXG4gKiAgIGJhejogdGltZXIoNDAwMClcbiAqIH0pO1xuICogb2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICogIG5leHQ6IHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSxcbiAqICBjb21wbGV0ZTogKCkgPT4gY29uc29sZS5sb2coJ1RoaXMgaXMgaG93IGl0IGVuZHMhJyksXG4gKiB9KTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8geyBmb286IDQsIGJhcjogOCwgYmF6OiAwIH0gYWZ0ZXIgNCBzZWNvbmRzXG4gKiAvLyAnVGhpcyBpcyBob3cgaXQgZW5kcyEnIGltbWVkaWF0ZWx5IGFmdGVyXG4gKiBgYGBcbiAqXG4gKiBVc2UgYGZvcmtKb2luYCB3aXRoIGFuIGFycmF5IG9mIG9ic2VydmFibGUgaW5wdXRzXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZvcmtKb2luLCBvZiwgdGltZXIgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBvYnNlcnZhYmxlID0gZm9ya0pvaW4oW1xuICogICBvZigxLCAyLCAzLCA0KSxcbiAqICAgUHJvbWlzZS5yZXNvbHZlKDgpLFxuICogICB0aW1lcig0MDAwKVxuICogXSk7XG4gKiBvYnNlcnZhYmxlLnN1YnNjcmliZSh7XG4gKiAgbmV4dDogdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogIGNvbXBsZXRlOiAoKSA9PiBjb25zb2xlLmxvZygnVGhpcyBpcyBob3cgaXQgZW5kcyEnKSxcbiAqIH0pO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyBbNCwgOCwgMF0gYWZ0ZXIgNCBzZWNvbmRzXG4gKiAvLyAnVGhpcyBpcyBob3cgaXQgZW5kcyEnIGltbWVkaWF0ZWx5IGFmdGVyXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICogQHNlZSB7QGxpbmsgemlwfVxuICpcbiAqIEBwYXJhbSB7Li4uT2JzZXJ2YWJsZUlucHV0fSBhcmdzIEFueSBudW1iZXIgb2YgT2JzZXJ2YWJsZXMgcHJvdmlkZWQgZWl0aGVyIGFzIGFuIGFycmF5IG9yIGFzIGFuIGFyZ3VtZW50c1xuICogcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9qZWN0XSBGdW5jdGlvbiB0aGF0IHRha2VzIHZhbHVlcyBlbWl0dGVkIGJ5IGlucHV0IE9ic2VydmFibGVzIGFuZCByZXR1cm5zIHZhbHVlXG4gKiB0aGF0IHdpbGwgYXBwZWFyIGluIHJlc3VsdGluZyBPYnNlcnZhYmxlIGluc3RlYWQgb2YgZGVmYXVsdCBhcnJheS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IE9ic2VydmFibGUgZW1pdHRpbmcgZWl0aGVyIGFuIGFycmF5IG9mIGxhc3QgdmFsdWVzIGVtaXR0ZWQgYnkgcGFzc2VkIE9ic2VydmFibGVzXG4gKiBvciB2YWx1ZSBmcm9tIHByb2plY3QgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JrSm9pbiguLi5hcmdzOiBhbnlbXSk6IE9ic2VydmFibGU8YW55PiB7XG4gIGNvbnN0IHJlc3VsdFNlbGVjdG9yID0gcG9wUmVzdWx0U2VsZWN0b3IoYXJncyk7XG4gIGNvbnN0IHsgYXJnczogc291cmNlcywga2V5cyB9ID0gYXJnc0FyZ0FycmF5T3JPYmplY3QoYXJncyk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHNvdXJjZXM7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IHJlbWFpbmluZ0NvbXBsZXRpb25zID0gbGVuZ3RoO1xuICAgIGxldCByZW1haW5pbmdFbWlzc2lvbnMgPSBsZW5ndGg7XG4gICAgZm9yIChsZXQgc291cmNlSW5kZXggPSAwOyBzb3VyY2VJbmRleCA8IGxlbmd0aDsgc291cmNlSW5kZXgrKykge1xuICAgICAgbGV0IGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICBpbm5lckZyb20oc291cmNlc1tzb3VyY2VJbmRleF0pLnN1YnNjcmliZShcbiAgICAgICAgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKFxuICAgICAgICAgIHN1YnNjcmliZXIsXG4gICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhc1ZhbHVlKSB7XG4gICAgICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVtYWluaW5nRW1pc3Npb25zLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbc291cmNlSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiByZW1haW5pbmdDb21wbGV0aW9ucy0tLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlbWFpbmluZ0NvbXBsZXRpb25zIHx8ICFoYXNWYWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoIXJlbWFpbmluZ0VtaXNzaW9ucykge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChrZXlzID8gY3JlYXRlT2JqZWN0KGtleXMsIHZhbHVlcykgOiB2YWx1ZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdFNlbGVjdG9yID8gcmVzdWx0LnBpcGUobWFwT25lT3JNYW55QXJncyhyZXN1bHRTZWxlY3RvcikpIDogcmVzdWx0O1xufVxuIl19
