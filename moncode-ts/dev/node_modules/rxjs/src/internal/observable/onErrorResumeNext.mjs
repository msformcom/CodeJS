import { Observable } from '../Observable.mjs';
import { argsOrArgArray } from '../util/argsOrArgArray.mjs';
import { OperatorSubscriber } from '../operators/OperatorSubscriber.mjs';
import { noop } from '../util/noop.mjs';
import { innerFrom } from './innerFrom.mjs';
/* tslint:enable:max-line-length */
/**
 * When any of the provided Observable emits a complete or an error notification, it immediately subscribes to the next one
 * that was passed.
 *
 * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
 *
 * ![](onErrorResumeNext.png)
 *
 * `onErrorResumeNext` will subscribe to each observable source it is provided, in order.
 * If the source it's subscribed to emits an error or completes, it will move to the next source
 * without error.
 *
 * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.
 *
 * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its
 * sources emits an error.
 *
 * Note that there is no way to handle any errors thrown by sources via the result of
 * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can
 * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.
 *
 * ## Example
 *
 * Subscribe to the next Observable after map fails
 *
 * ```ts
 * import { onErrorResumeNext, of, map } from 'rxjs';
 *
 * onErrorResumeNext(
 *   of(1, 2, 3, 0).pipe(
 *     map(x => {
 *       if (x === 0) {
 *         throw Error();
 *       }
 *       return 10 / x;
 *     })
 *   ),
 *   of(1, 2, 3)
 * )
 * .subscribe({
 *   next: value => console.log(value),
 *   error: err => console.log(err),     // Will never be called.
 *   complete: () => console.log('done')
 * });
 *
 * // Logs:
 * // 10
 * // 5
 * // 3.3333333333333335
 * // 1
 * // 2
 * // 3
 * // 'done'
 * ```
 *
 * @see {@link concat}
 * @see {@link catchError}
 *
 * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.
 * @return {Observable} An Observable that concatenates all sources, one after the other,
 * ignoring all errors, such that any error causes it to move on to the next source.
 */
export function onErrorResumeNext(...sources) {
    const nextSources = argsOrArgArray(sources);
    return new Observable((subscriber) => {
        let sourceIndex = 0;
        const subscribeNext = () => {
            if (sourceIndex < nextSources.length) {
                let nextSource;
                try {
                    nextSource = innerFrom(nextSources[sourceIndex++]);
                }
                catch (err) {
                    subscribeNext();
                    return;
                }
                const innerSubscriber = new OperatorSubscriber(subscriber, undefined, noop, noop);
                nextSource.subscribe(innerSubscriber);
                innerSubscriber.add(subscribeNext);
            }
            else {
                subscriber.complete();
            }
        };
        subscribeNext();
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL29uRXJyb3JSZXN1bWVOZXh0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3hELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDcEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQU14QyxtQ0FBbUM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2REc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQy9CLEdBQUcsT0FBc0U7SUFFekUsTUFBTSxXQUFXLEdBQTRCLGNBQWMsQ0FBQyxPQUFPLENBQVEsQ0FBQztJQUU1RSxPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUU7UUFDbkMsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLE1BQU0sYUFBYSxHQUFHLEdBQUcsRUFBRTtZQUN6QixJQUFJLFdBQVcsR0FBRyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3JDLElBQUksVUFBaUMsQ0FBQztnQkFDdEMsSUFBSSxDQUFDO29CQUNILFVBQVUsR0FBRyxTQUFTLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDckQsQ0FBQztnQkFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO29CQUNiLGFBQWEsRUFBRSxDQUFDO29CQUNoQixPQUFPO2dCQUNULENBQUM7Z0JBQ0QsTUFBTSxlQUFlLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbEYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDdEMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNyQyxDQUFDO2lCQUFNLENBQUM7Z0JBQ04sVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3hCLENBQUM7UUFDSCxDQUFDLENBQUM7UUFDRixhQUFhLEVBQUUsQ0FBQztJQUNsQixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29ic2VydmFibGUvb25FcnJvclJlc3VtZU5leHQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlSW5wdXRUdXBsZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFyZ3NPckFyZ0FycmF5IH0gZnJvbSAnLi4vdXRpbC9hcmdzT3JBcmdBcnJheSc7XG5pbXBvcnQgeyBPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuLi9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlsL25vb3AnO1xuaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi9pbm5lckZyb20nO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dDxBIGV4dGVuZHMgcmVhZG9ubHkgdW5rbm93bltdPihzb3VyY2VzOiBbLi4uT2JzZXJ2YWJsZUlucHV0VHVwbGU8QT5dKTogT2JzZXJ2YWJsZTxBW251bWJlcl0+O1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0PEEgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10+KC4uLnNvdXJjZXM6IFsuLi5PYnNlcnZhYmxlSW5wdXRUdXBsZTxBPl0pOiBPYnNlcnZhYmxlPEFbbnVtYmVyXT47XG5cbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogV2hlbiBhbnkgb2YgdGhlIHByb3ZpZGVkIE9ic2VydmFibGUgZW1pdHMgYSBjb21wbGV0ZSBvciBhbiBlcnJvciBub3RpZmljYXRpb24sIGl0IGltbWVkaWF0ZWx5IHN1YnNjcmliZXMgdG8gdGhlIG5leHQgb25lXG4gKiB0aGF0IHdhcyBwYXNzZWQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkV4ZWN1dGUgc2VyaWVzIG9mIE9ic2VydmFibGVzIG5vIG1hdHRlciB3aGF0LCBldmVuIGlmIGl0IG1lYW5zIHN3YWxsb3dpbmcgZXJyb3JzLjwvc3Bhbj5cbiAqXG4gKiAhW10ob25FcnJvclJlc3VtZU5leHQucG5nKVxuICpcbiAqIGBvbkVycm9yUmVzdW1lTmV4dGAgd2lsbCBzdWJzY3JpYmUgdG8gZWFjaCBvYnNlcnZhYmxlIHNvdXJjZSBpdCBpcyBwcm92aWRlZCwgaW4gb3JkZXIuXG4gKiBJZiB0aGUgc291cmNlIGl0J3Mgc3Vic2NyaWJlZCB0byBlbWl0cyBhbiBlcnJvciBvciBjb21wbGV0ZXMsIGl0IHdpbGwgbW92ZSB0byB0aGUgbmV4dCBzb3VyY2VcbiAqIHdpdGhvdXQgZXJyb3IuXG4gKlxuICogSWYgYG9uRXJyb3JSZXN1bWVOZXh0YCBpcyBwcm92aWRlZCBubyBhcmd1bWVudHMsIG9yIGEgc2luZ2xlLCBlbXB0eSBhcnJheSwgaXQgd2lsbCByZXR1cm4ge0BsaW5rIEVNUFRZfS5cbiAqXG4gKiBgb25FcnJvclJlc3VtZU5leHRgIGlzIGJhc2ljYWxseSB7QGxpbmsgY29uY2F0fSwgb25seSBpdCB3aWxsIGNvbnRpbnVlLCBldmVuIGlmIG9uZSBvZiBpdHNcbiAqIHNvdXJjZXMgZW1pdHMgYW4gZXJyb3IuXG4gKlxuICogTm90ZSB0aGF0IHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgYW55IGVycm9ycyB0aHJvd24gYnkgc291cmNlcyB2aWEgdGhlIHJlc3VsdCBvZlxuICogYG9uRXJyb3JSZXN1bWVOZXh0YC4gSWYgeW91IHdhbnQgdG8gaGFuZGxlIGVycm9ycyB0aHJvd24gaW4gYW55IGdpdmVuIHNvdXJjZSwgeW91IGNhblxuICogYWx3YXlzIHVzZSB0aGUge0BsaW5rIGNhdGNoRXJyb3J9IG9wZXJhdG9yIG9uIHRoZW0gYmVmb3JlIHBhc3NpbmcgdGhlbSBpbnRvIGBvbkVycm9yUmVzdW1lTmV4dGAuXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIFN1YnNjcmliZSB0byB0aGUgbmV4dCBPYnNlcnZhYmxlIGFmdGVyIG1hcCBmYWlsc1xuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBvbkVycm9yUmVzdW1lTmV4dCwgb2YsIG1hcCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIG9uRXJyb3JSZXN1bWVOZXh0KFxuICogICBvZigxLCAyLCAzLCAwKS5waXBlKFxuICogICAgIG1hcCh4ID0+IHtcbiAqICAgICAgIGlmICh4ID09PSAwKSB7XG4gKiAgICAgICAgIHRocm93IEVycm9yKCk7XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4gMTAgLyB4O1xuICogICAgIH0pXG4gKiAgICksXG4gKiAgIG9mKDEsIDIsIDMpXG4gKiApXG4gKiAuc3Vic2NyaWJlKHtcbiAqICAgbmV4dDogdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogICBlcnJvcjogZXJyID0+IGNvbnNvbGUubG9nKGVyciksICAgICAvLyBXaWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAqICAgY29tcGxldGU6ICgpID0+IGNvbnNvbGUubG9nKCdkb25lJylcbiAqIH0pO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyAxMFxuICogLy8gNVxuICogLy8gMy4zMzMzMzMzMzMzMzMzMzM1XG4gKiAvLyAxXG4gKiAvLyAyXG4gKiAvLyAzXG4gKiAvLyAnZG9uZSdcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIGNhdGNoRXJyb3J9XG4gKlxuICogQHBhcmFtIHsuLi5PYnNlcnZhYmxlSW5wdXR9IHNvdXJjZXMgT2JzZXJ2YWJsZXMgKG9yIGFueXRoaW5nIHRoYXQgKmlzKiBvYnNlcnZhYmxlKSBwYXNzZWQgZWl0aGVyIGRpcmVjdGx5IG9yIGFzIGFuIGFycmF5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGNvbmNhdGVuYXRlcyBhbGwgc291cmNlcywgb25lIGFmdGVyIHRoZSBvdGhlcixcbiAqIGlnbm9yaW5nIGFsbCBlcnJvcnMsIHN1Y2ggdGhhdCBhbnkgZXJyb3IgY2F1c2VzIGl0IHRvIG1vdmUgb24gdG8gdGhlIG5leHQgc291cmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHQ8QSBleHRlbmRzIHJlYWRvbmx5IHVua25vd25bXT4oXG4gIC4uLnNvdXJjZXM6IFtbLi4uT2JzZXJ2YWJsZUlucHV0VHVwbGU8QT5dXSB8IFsuLi5PYnNlcnZhYmxlSW5wdXRUdXBsZTxBPl1cbik6IE9ic2VydmFibGU8QVtudW1iZXJdPiB7XG4gIGNvbnN0IG5leHRTb3VyY2VzOiBPYnNlcnZhYmxlSW5wdXRUdXBsZTxBPiA9IGFyZ3NPckFyZ0FycmF5KHNvdXJjZXMpIGFzIGFueTtcblxuICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcbiAgICBsZXQgc291cmNlSW5kZXggPSAwO1xuICAgIGNvbnN0IHN1YnNjcmliZU5leHQgPSAoKSA9PiB7XG4gICAgICBpZiAoc291cmNlSW5kZXggPCBuZXh0U291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHRTb3VyY2U6IE9ic2VydmFibGU8QVtudW1iZXJdPjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0U291cmNlID0gaW5uZXJGcm9tKG5leHRTb3VyY2VzW3NvdXJjZUluZGV4KytdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgc3Vic2NyaWJlTmV4dCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbm5lclN1YnNjcmliZXIgPSBuZXcgT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHVuZGVmaW5lZCwgbm9vcCwgbm9vcCk7XG4gICAgICAgIG5leHRTb3VyY2Uuc3Vic2NyaWJlKGlubmVyU3Vic2NyaWJlcik7XG4gICAgICAgIGlubmVyU3Vic2NyaWJlci5hZGQoc3Vic2NyaWJlTmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdWJzY3JpYmVOZXh0KCk7XG4gIH0pO1xufVxuIl19
