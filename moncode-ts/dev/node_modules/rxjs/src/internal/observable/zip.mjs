import { Observable } from '../Observable.mjs';
import { innerFrom } from './innerFrom.mjs';
import { argsOrArgArray } from '../util/argsOrArgArray.mjs';
import { EMPTY } from './empty.mjs';
import { createOperatorSubscriber } from '../operators/OperatorSubscriber.mjs';
import { popResultSelector } from '../util/args.mjs';
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the last parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * ## Example
 *
 * Combine age and name from different sources
 *
 * ```ts
 * import { of, zip, map } from 'rxjs';
 *
 * const age$ = of(27, 25, 29);
 * const name$ = of('Foo', 'Bar', 'Beer');
 * const isDev$ = of(true, true, false);
 *
 * zip(age$, name$, isDev$).pipe(
 *   map(([age, name, isDev]) => ({ age, name, isDev }))
 * )
 * .subscribe(x => console.log(x));
 *
 * // Outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 * ```
 *
 * @param sources
 * @return {Observable<R>}
 */
export function zip(...args) {
    const resultSelector = popResultSelector(args);
    const sources = argsOrArgArray(args);
    return sources.length
        ? new Observable((subscriber) => {
            // A collection of buffers of values from each source.
            // Keyed by the same index with which the sources were passed in.
            let buffers = sources.map(() => []);
            // An array of flags of whether or not the sources have completed.
            // This is used to check to see if we should complete the result.
            // Keyed by the same index with which the sources were passed in.
            let completed = sources.map(() => false);
            // When everything is done, release the arrays above.
            subscriber.add(() => {
                buffers = completed = null;
            });
            // Loop over our sources and subscribe to each one. The index `i` is
            // especially important here, because we use it in closures below to
            // access the related buffers and completion properties
            for (let sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
                innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, (value) => {
                    buffers[sourceIndex].push(value);
                    // if every buffer has at least one value in it, then we
                    // can shift out the oldest value from each buffer and emit
                    // them as an array.
                    if (buffers.every((buffer) => buffer.length)) {
                        const result = buffers.map((buffer) => buffer.shift());
                        // Emit the array. If theres' a result selector, use that.
                        subscriber.next(resultSelector ? resultSelector(...result) : result);
                        // If any one of the sources is both complete and has an empty buffer
                        // then we complete the result. This is because we cannot possibly have
                        // any more values to zip together.
                        if (buffers.some((buffer, i) => !buffer.length && completed[i])) {
                            subscriber.complete();
                        }
                    }
                }, () => {
                    // This source completed. Mark it as complete so we can check it later
                    // if we have to.
                    completed[sourceIndex] = true;
                    // But, if this complete source has nothing in its buffer, then we
                    // can complete the result, because we can't possibly have any more
                    // values from this to zip together with the other values.
                    !buffers[sourceIndex].length && subscriber.complete();
                }));
            }
            // When everything is done, release the arrays above.
            return () => {
                buffers = completed = null;
            };
        })
        : EMPTY;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL3ppcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3hELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDaEMsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0UsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBWWpEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBK0JHO0FBQ0gsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLElBQWU7SUFDcEMsTUFBTSxjQUFjLEdBQUcsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFL0MsTUFBTSxPQUFPLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBMEIsQ0FBQztJQUU5RCxPQUFPLE9BQU8sQ0FBQyxNQUFNO1FBQ25CLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBWSxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQ3ZDLHNEQUFzRDtZQUN0RCxpRUFBaUU7WUFDakUsSUFBSSxPQUFPLEdBQWdCLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFakQsa0VBQWtFO1lBQ2xFLGlFQUFpRTtZQUNqRSxpRUFBaUU7WUFDakUsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUV6QyxxREFBcUQ7WUFDckQsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2xCLE9BQU8sR0FBRyxTQUFTLEdBQUcsSUFBSyxDQUFDO1lBQzlCLENBQUMsQ0FBQyxDQUFDO1lBRUgsb0VBQW9FO1lBQ3BFLG9FQUFvRTtZQUNwRSx1REFBdUQ7WUFDdkQsS0FBSyxJQUFJLFdBQVcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxJQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxFQUFFLENBQUM7Z0JBQzVGLFNBQVMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQ3ZDLHdCQUF3QixDQUN0QixVQUFVLEVBQ1YsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDUixPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNqQyx3REFBd0Q7b0JBQ3hELDJEQUEyRDtvQkFDM0Qsb0JBQW9CO29CQUNwQixJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO3dCQUM3QyxNQUFNLE1BQU0sR0FBUSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFHLENBQUMsQ0FBQzt3QkFDN0QsMERBQTBEO3dCQUMxRCxVQUFVLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3dCQUNyRSxxRUFBcUU7d0JBQ3JFLHVFQUF1RTt3QkFDdkUsbUNBQW1DO3dCQUNuQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzs0QkFDaEUsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO3dCQUN4QixDQUFDO29CQUNILENBQUM7Z0JBQ0gsQ0FBQyxFQUNELEdBQUcsRUFBRTtvQkFDSCxzRUFBc0U7b0JBQ3RFLGlCQUFpQjtvQkFDakIsU0FBUyxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDOUIsa0VBQWtFO29CQUNsRSxtRUFBbUU7b0JBQ25FLDBEQUEwRDtvQkFDMUQsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxJQUFJLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDeEQsQ0FBQyxDQUNGLENBQ0YsQ0FBQztZQUNKLENBQUM7WUFFRCxxREFBcUQ7WUFDckQsT0FBTyxHQUFHLEVBQUU7Z0JBQ1YsT0FBTyxHQUFHLFNBQVMsR0FBRyxJQUFLLENBQUM7WUFDOUIsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNaLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL29ic2VydmFibGUvemlwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZUlucHV0VHVwbGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpbm5lckZyb20gfSBmcm9tICcuL2lubmVyRnJvbSc7XG5pbXBvcnQgeyBhcmdzT3JBcmdBcnJheSB9IGZyb20gJy4uL3V0aWwvYXJnc09yQXJnQXJyYXknO1xuaW1wb3J0IHsgRU1QVFkgfSBmcm9tICcuL2VtcHR5JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4uL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXInO1xuaW1wb3J0IHsgcG9wUmVzdWx0U2VsZWN0b3IgfSBmcm9tICcuLi91dGlsL2FyZ3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gemlwPEEgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10+KHNvdXJjZXM6IFsuLi5PYnNlcnZhYmxlSW5wdXRUdXBsZTxBPl0pOiBPYnNlcnZhYmxlPEE+O1xuZXhwb3J0IGZ1bmN0aW9uIHppcDxBIGV4dGVuZHMgcmVhZG9ubHkgdW5rbm93bltdLCBSPihcbiAgc291cmNlczogWy4uLk9ic2VydmFibGVJbnB1dFR1cGxlPEE+XSxcbiAgcmVzdWx0U2VsZWN0b3I6ICguLi52YWx1ZXM6IEEpID0+IFJcbik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gemlwPEEgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10+KC4uLnNvdXJjZXM6IFsuLi5PYnNlcnZhYmxlSW5wdXRUdXBsZTxBPl0pOiBPYnNlcnZhYmxlPEE+O1xuZXhwb3J0IGZ1bmN0aW9uIHppcDxBIGV4dGVuZHMgcmVhZG9ubHkgdW5rbm93bltdLCBSPihcbiAgLi4uc291cmNlc0FuZFJlc3VsdFNlbGVjdG9yOiBbLi4uT2JzZXJ2YWJsZUlucHV0VHVwbGU8QT4sICguLi52YWx1ZXM6IEEpID0+IFJdXG4pOiBPYnNlcnZhYmxlPFI+O1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiBlYWNoXG4gKiBvZiBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKlxuICogSWYgdGhlIGxhc3QgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24sIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjb21wdXRlIHRoZSBjcmVhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IHZhbHVlcy5cbiAqIE90aGVyd2lzZSwgYW4gYXJyYXkgb2YgdGhlIGlucHV0IHZhbHVlcyBpcyByZXR1cm5lZC5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogQ29tYmluZSBhZ2UgYW5kIG5hbWUgZnJvbSBkaWZmZXJlbnQgc291cmNlc1xuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBvZiwgemlwLCBtYXAgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBhZ2UkID0gb2YoMjcsIDI1LCAyOSk7XG4gKiBjb25zdCBuYW1lJCA9IG9mKCdGb28nLCAnQmFyJywgJ0JlZXInKTtcbiAqIGNvbnN0IGlzRGV2JCA9IG9mKHRydWUsIHRydWUsIGZhbHNlKTtcbiAqXG4gKiB6aXAoYWdlJCwgbmFtZSQsIGlzRGV2JCkucGlwZShcbiAqICAgbWFwKChbYWdlLCBuYW1lLCBpc0Rldl0pID0+ICh7IGFnZSwgbmFtZSwgaXNEZXYgfSkpXG4gKiApXG4gKiAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIE91dHB1dHNcbiAqIC8vIHsgYWdlOiAyNywgbmFtZTogJ0ZvbycsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyNSwgbmFtZTogJ0JhcicsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyOSwgbmFtZTogJ0JlZXInLCBpc0RldjogZmFsc2UgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNvdXJjZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6aXAoLi4uYXJnczogdW5rbm93bltdKTogT2JzZXJ2YWJsZTx1bmtub3duPiB7XG4gIGNvbnN0IHJlc3VsdFNlbGVjdG9yID0gcG9wUmVzdWx0U2VsZWN0b3IoYXJncyk7XG5cbiAgY29uc3Qgc291cmNlcyA9IGFyZ3NPckFyZ0FycmF5KGFyZ3MpIGFzIE9ic2VydmFibGU8dW5rbm93bj5bXTtcblxuICByZXR1cm4gc291cmNlcy5sZW5ndGhcbiAgICA/IG5ldyBPYnNlcnZhYmxlPHVua25vd25bXT4oKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgLy8gQSBjb2xsZWN0aW9uIG9mIGJ1ZmZlcnMgb2YgdmFsdWVzIGZyb20gZWFjaCBzb3VyY2UuXG4gICAgICAgIC8vIEtleWVkIGJ5IHRoZSBzYW1lIGluZGV4IHdpdGggd2hpY2ggdGhlIHNvdXJjZXMgd2VyZSBwYXNzZWQgaW4uXG4gICAgICAgIGxldCBidWZmZXJzOiB1bmtub3duW11bXSA9IHNvdXJjZXMubWFwKCgpID0+IFtdKTtcblxuICAgICAgICAvLyBBbiBhcnJheSBvZiBmbGFncyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgc291cmNlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGNoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgY29tcGxldGUgdGhlIHJlc3VsdC5cbiAgICAgICAgLy8gS2V5ZWQgYnkgdGhlIHNhbWUgaW5kZXggd2l0aCB3aGljaCB0aGUgc291cmNlcyB3ZXJlIHBhc3NlZCBpbi5cbiAgICAgICAgbGV0IGNvbXBsZXRlZCA9IHNvdXJjZXMubWFwKCgpID0+IGZhbHNlKTtcblxuICAgICAgICAvLyBXaGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgcmVsZWFzZSB0aGUgYXJyYXlzIGFib3ZlLlxuICAgICAgICBzdWJzY3JpYmVyLmFkZCgoKSA9PiB7XG4gICAgICAgICAgYnVmZmVycyA9IGNvbXBsZXRlZCA9IG51bGwhO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMb29wIG92ZXIgb3VyIHNvdXJjZXMgYW5kIHN1YnNjcmliZSB0byBlYWNoIG9uZS4gVGhlIGluZGV4IGBpYCBpc1xuICAgICAgICAvLyBlc3BlY2lhbGx5IGltcG9ydGFudCBoZXJlLCBiZWNhdXNlIHdlIHVzZSBpdCBpbiBjbG9zdXJlcyBiZWxvdyB0b1xuICAgICAgICAvLyBhY2Nlc3MgdGhlIHJlbGF0ZWQgYnVmZmVycyBhbmQgY29tcGxldGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAobGV0IHNvdXJjZUluZGV4ID0gMDsgIXN1YnNjcmliZXIuY2xvc2VkICYmIHNvdXJjZUluZGV4IDwgc291cmNlcy5sZW5ndGg7IHNvdXJjZUluZGV4KyspIHtcbiAgICAgICAgICBpbm5lckZyb20oc291cmNlc1tzb3VyY2VJbmRleF0pLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihcbiAgICAgICAgICAgICAgc3Vic2NyaWJlcixcbiAgICAgICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVmZmVyc1tzb3VyY2VJbmRleF0ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgZXZlcnkgYnVmZmVyIGhhcyBhdCBsZWFzdCBvbmUgdmFsdWUgaW4gaXQsIHRoZW4gd2VcbiAgICAgICAgICAgICAgICAvLyBjYW4gc2hpZnQgb3V0IHRoZSBvbGRlc3QgdmFsdWUgZnJvbSBlYWNoIGJ1ZmZlciBhbmQgZW1pdFxuICAgICAgICAgICAgICAgIC8vIHRoZW0gYXMgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcnMuZXZlcnkoKGJ1ZmZlcikgPT4gYnVmZmVyLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0gYnVmZmVycy5tYXAoKGJ1ZmZlcikgPT4gYnVmZmVyLnNoaWZ0KCkhKTtcbiAgICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIGFycmF5LiBJZiB0aGVyZXMnIGEgcmVzdWx0IHNlbGVjdG9yLCB1c2UgdGhhdC5cbiAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHRTZWxlY3RvciA/IHJlc3VsdFNlbGVjdG9yKC4uLnJlc3VsdCkgOiByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgLy8gSWYgYW55IG9uZSBvZiB0aGUgc291cmNlcyBpcyBib3RoIGNvbXBsZXRlIGFuZCBoYXMgYW4gZW1wdHkgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIGNvbXBsZXRlIHRoZSByZXN1bHQuIFRoaXMgaXMgYmVjYXVzZSB3ZSBjYW5ub3QgcG9zc2libHkgaGF2ZVxuICAgICAgICAgICAgICAgICAgLy8gYW55IG1vcmUgdmFsdWVzIHRvIHppcCB0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJzLnNvbWUoKGJ1ZmZlciwgaSkgPT4gIWJ1ZmZlci5sZW5ndGggJiYgY29tcGxldGVkW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzb3VyY2UgY29tcGxldGVkLiBNYXJrIGl0IGFzIGNvbXBsZXRlIHNvIHdlIGNhbiBjaGVjayBpdCBsYXRlclxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgdG8uXG4gICAgICAgICAgICAgICAgY29tcGxldGVkW3NvdXJjZUluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gQnV0LCBpZiB0aGlzIGNvbXBsZXRlIHNvdXJjZSBoYXMgbm90aGluZyBpbiBpdHMgYnVmZmVyLCB0aGVuIHdlXG4gICAgICAgICAgICAgICAgLy8gY2FuIGNvbXBsZXRlIHRoZSByZXN1bHQsIGJlY2F1c2Ugd2UgY2FuJ3QgcG9zc2libHkgaGF2ZSBhbnkgbW9yZVxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBmcm9tIHRoaXMgdG8gemlwIHRvZ2V0aGVyIHdpdGggdGhlIG90aGVyIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAhYnVmZmVyc1tzb3VyY2VJbmRleF0ubGVuZ3RoICYmIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgcmVsZWFzZSB0aGUgYXJyYXlzIGFib3ZlLlxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGJ1ZmZlcnMgPSBjb21wbGV0ZWQgPSBudWxsITtcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgOiBFTVBUWTtcbn1cbiJdfQ==
