import { bindCallbackInternals } from './bindCallbackInternals.mjs';
/**
 * Converts a Node.js-style callback API to a function that returns an
 * Observable.
 *
 * <span class="informal">It's just like {@link bindCallback}, but the
 * callback is expected to be of type `callback(error, result)`.</span>
 *
 * `bindNodeCallback` is not an operator because its input and output are not
 * Observables. The input is a function `func` with some parameters, but the
 * last parameter must be a callback function that `func` calls when it is
 * done. The callback function is expected to follow Node.js conventions,
 * where the first argument to the callback is an error object, signaling
 * whether call was successful. If that object is passed to callback, it means
 * something went wrong.
 *
 * The output of `bindNodeCallback` is a function that takes the same
 * parameters as `func`, except the last one (the callback). When the output
 * function is called with arguments, it will return an Observable.
 * If `func` calls its callback with error parameter present, Observable will
 * error with that value as well. If error parameter is not passed, Observable will emit
 * second parameter. If there are more parameters (third and so on),
 * Observable will emit an array with all arguments, except first error argument.
 *
 * Note that `func` will not be called at the same time output function is,
 * but rather whenever resulting Observable is subscribed. By default call to
 * `func` will happen synchronously after subscription, but that can be changed
 * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}
 * can also control when values from callback will be emitted by Observable.
 * To find out more, check out documentation for {@link bindCallback}, where
 * {@link SchedulerLike} works exactly the same.
 *
 * As in {@link bindCallback}, context (`this` property) of input function will be set to context
 * of returned function, when it is called.
 *
 * After Observable emits value, it will complete immediately. This means
 * even if `func` calls callback again, values from second and consecutive
 * calls will never appear on the stream. If you need to handle functions
 * that call callbacks multiple times, check out {@link fromEvent} or
 * {@link fromEventPattern} instead.
 *
 * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
 * "Node.js-style" callbacks are just a convention, so if you write for
 * browsers or any other environment and API you use implements that callback style,
 * `bindNodeCallback` can be safely used on that API functions as well.
 *
 * Remember that Error object passed to callback does not have to be an instance
 * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
 * Error parameter of callback function is interpreted as "present", when value
 * of that parameter is truthy. It could be, for example, non-zero number, non-empty
 * string or boolean `true`. In all of these cases resulting Observable would error
 * with that value. This means usually regular style callbacks will fail very often when
 * `bindNodeCallback` is used. If your Observable errors much more often then you
 * would expect, check if callback really is called in Node.js-style and, if not,
 * switch to {@link bindCallback} instead.
 *
 * Note that even if error parameter is technically present in callback, but its value
 * is falsy, it still won't appear in array emitted by Observable.
 *
 * ## Examples
 * ###  Read a file from the filesystem and get the data as an Observable
 * ```ts
 * import * as fs from 'fs';
 * const readFileAsObservable = bindNodeCallback(fs.readFile);
 * const result = readFileAsObservable('./roadNames.txt', 'utf8');
 * result.subscribe(x => console.log(x), e => console.error(e));
 * ```
 *
 * ### Use on function calling callback with multiple arguments
 * ```ts
 * someFunction((err, a, b) => {
 *   console.log(err); // null
 *   console.log(a); // 5
 *   console.log(b); // "some string"
 * });
 * const boundSomeFunction = bindNodeCallback(someFunction);
 * boundSomeFunction()
 * .subscribe(value => {
 *   console.log(value); // [5, "some string"]
 * });
 * ```
 *
 * ### Use on function calling callback in regular style
 * ```ts
 * someFunction(a => {
 *   console.log(a); // 5
 * });
 * const boundSomeFunction = bindNodeCallback(someFunction);
 * boundSomeFunction()
 * .subscribe(
 *   value => {}             // never gets called
 *   err => console.log(err) // 5
 * );
 * ```
 *
 * @see {@link bindCallback}
 * @see {@link from}
 *
 * @param {function} func Function with a Node.js-style callback as the last parameter.
 * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the
 * callbacks.
 * @return {function(...params: *): Observable} A function which returns the
 * Observable that delivers the same values the Node.js callback would
 * deliver.
 */
export function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2JpbmROb2RlQ2FsbGJhY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFjaEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1R0c7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQzlCLFlBQTRFLEVBQzVFLGNBQTBELEVBQzFELFNBQXlCO0lBRXpCLE9BQU8scUJBQXFCLENBQUMsSUFBSSxFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDOUUsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogQHByZXR0aWVyICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTY2hlZHVsZXJMaWtlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYmluZENhbGxiYWNrSW50ZXJuYWxzIH0gZnJvbSAnLi9iaW5kQ2FsbGJhY2tJbnRlcm5hbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYmluZE5vZGVDYWxsYmFjayhcbiAgY2FsbGJhY2tGdW5jOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQsXG4gIHJlc3VsdFNlbGVjdG9yOiAoLi4uYXJnczogYW55W10pID0+IGFueSxcbiAgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZVxuKTogKC4uLmFyZ3M6IGFueVtdKSA9PiBPYnNlcnZhYmxlPGFueT47XG5cbi8vIGFyZ3MgaXMgdGhlIGFyZ3VtZW50cyBhcnJheSBhbmQgd2UgcHVzaCB0aGUgY2FsbGJhY2sgb24gdGhlIHJlc3QgdHVwbGUgc2luY2UgdGhlIHJlc3QgcGFyYW1ldGVyIG11c3QgYmUgbGFzdCAob25seSBpdGVtKSBpbiBhIHBhcmFtZXRlciBsaXN0XG5leHBvcnQgZnVuY3Rpb24gYmluZE5vZGVDYWxsYmFjazxBIGV4dGVuZHMgcmVhZG9ubHkgdW5rbm93bltdLCBSIGV4dGVuZHMgcmVhZG9ubHkgdW5rbm93bltdPihcbiAgY2FsbGJhY2tGdW5jOiAoLi4uYXJnczogWy4uLkEsIChlcnI6IGFueSwgLi4ucmVzOiBSKSA9PiB2b2lkXSkgPT4gdm9pZCxcbiAgc2NoZWR1bGVyTGlrZT86IFNjaGVkdWxlckxpa2Vcbik6ICguLi5hcmc6IEEpID0+IE9ic2VydmFibGU8UiBleHRlbmRzIFtdID8gdm9pZCA6IFIgZXh0ZW5kcyBbYW55XSA/IFJbMF0gOiBSPjtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2sgQVBJIHRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuXG4gKiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGp1c3QgbGlrZSB7QGxpbmsgYmluZENhbGxiYWNrfSwgYnV0IHRoZVxuICogY2FsbGJhY2sgaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSBgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClgLjwvc3Bhbj5cbiAqXG4gKiBgYmluZE5vZGVDYWxsYmFja2AgaXMgbm90IGFuIG9wZXJhdG9yIGJlY2F1c2UgaXRzIGlucHV0IGFuZCBvdXRwdXQgYXJlIG5vdFxuICogT2JzZXJ2YWJsZXMuIFRoZSBpbnB1dCBpcyBhIGZ1bmN0aW9uIGBmdW5jYCB3aXRoIHNvbWUgcGFyYW1ldGVycywgYnV0IHRoZVxuICogbGFzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYGZ1bmNgIGNhbGxzIHdoZW4gaXQgaXNcbiAqIGRvbmUuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byBmb2xsb3cgTm9kZS5qcyBjb252ZW50aW9ucyxcbiAqIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgaXMgYW4gZXJyb3Igb2JqZWN0LCBzaWduYWxpbmdcbiAqIHdoZXRoZXIgY2FsbCB3YXMgc3VjY2Vzc2Z1bC4gSWYgdGhhdCBvYmplY3QgaXMgcGFzc2VkIHRvIGNhbGxiYWNrLCBpdCBtZWFuc1xuICogc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gKlxuICogVGhlIG91dHB1dCBvZiBgYmluZE5vZGVDYWxsYmFja2AgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBzYW1lXG4gKiBwYXJhbWV0ZXJzIGFzIGBmdW5jYCwgZXhjZXB0IHRoZSBsYXN0IG9uZSAodGhlIGNhbGxiYWNrKS4gV2hlbiB0aGUgb3V0cHV0XG4gKiBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhcmd1bWVudHMsIGl0IHdpbGwgcmV0dXJuIGFuIE9ic2VydmFibGUuXG4gKiBJZiBgZnVuY2AgY2FsbHMgaXRzIGNhbGxiYWNrIHdpdGggZXJyb3IgcGFyYW1ldGVyIHByZXNlbnQsIE9ic2VydmFibGUgd2lsbFxuICogZXJyb3Igd2l0aCB0aGF0IHZhbHVlIGFzIHdlbGwuIElmIGVycm9yIHBhcmFtZXRlciBpcyBub3QgcGFzc2VkLCBPYnNlcnZhYmxlIHdpbGwgZW1pdFxuICogc2Vjb25kIHBhcmFtZXRlci4gSWYgdGhlcmUgYXJlIG1vcmUgcGFyYW1ldGVycyAodGhpcmQgYW5kIHNvIG9uKSxcbiAqIE9ic2VydmFibGUgd2lsbCBlbWl0IGFuIGFycmF5IHdpdGggYWxsIGFyZ3VtZW50cywgZXhjZXB0IGZpcnN0IGVycm9yIGFyZ3VtZW50LlxuICpcbiAqIE5vdGUgdGhhdCBgZnVuY2Agd2lsbCBub3QgYmUgY2FsbGVkIGF0IHRoZSBzYW1lIHRpbWUgb3V0cHV0IGZ1bmN0aW9uIGlzLFxuICogYnV0IHJhdGhlciB3aGVuZXZlciByZXN1bHRpbmcgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLiBCeSBkZWZhdWx0IGNhbGwgdG9cbiAqIGBmdW5jYCB3aWxsIGhhcHBlbiBzeW5jaHJvbm91c2x5IGFmdGVyIHN1YnNjcmlwdGlvbiwgYnV0IHRoYXQgY2FuIGJlIGNoYW5nZWRcbiAqIHdpdGggcHJvcGVyIGBzY2hlZHVsZXJgIHByb3ZpZGVkIGFzIG9wdGlvbmFsIHRoaXJkIHBhcmFtZXRlci4ge0BsaW5rIFNjaGVkdWxlckxpa2V9XG4gKiBjYW4gYWxzbyBjb250cm9sIHdoZW4gdmFsdWVzIGZyb20gY2FsbGJhY2sgd2lsbCBiZSBlbWl0dGVkIGJ5IE9ic2VydmFibGUuXG4gKiBUbyBmaW5kIG91dCBtb3JlLCBjaGVjayBvdXQgZG9jdW1lbnRhdGlvbiBmb3Ige0BsaW5rIGJpbmRDYWxsYmFja30sIHdoZXJlXG4gKiB7QGxpbmsgU2NoZWR1bGVyTGlrZX0gd29ya3MgZXhhY3RseSB0aGUgc2FtZS5cbiAqXG4gKiBBcyBpbiB7QGxpbmsgYmluZENhbGxiYWNrfSwgY29udGV4dCAoYHRoaXNgIHByb3BlcnR5KSBvZiBpbnB1dCBmdW5jdGlvbiB3aWxsIGJlIHNldCB0byBjb250ZXh0XG4gKiBvZiByZXR1cm5lZCBmdW5jdGlvbiwgd2hlbiBpdCBpcyBjYWxsZWQuXG4gKlxuICogQWZ0ZXIgT2JzZXJ2YWJsZSBlbWl0cyB2YWx1ZSwgaXQgd2lsbCBjb21wbGV0ZSBpbW1lZGlhdGVseS4gVGhpcyBtZWFuc1xuICogZXZlbiBpZiBgZnVuY2AgY2FsbHMgY2FsbGJhY2sgYWdhaW4sIHZhbHVlcyBmcm9tIHNlY29uZCBhbmQgY29uc2VjdXRpdmVcbiAqIGNhbGxzIHdpbGwgbmV2ZXIgYXBwZWFyIG9uIHRoZSBzdHJlYW0uIElmIHlvdSBuZWVkIHRvIGhhbmRsZSBmdW5jdGlvbnNcbiAqIHRoYXQgY2FsbCBjYWxsYmFja3MgbXVsdGlwbGUgdGltZXMsIGNoZWNrIG91dCB7QGxpbmsgZnJvbUV2ZW50fSBvclxuICoge0BsaW5rIGZyb21FdmVudFBhdHRlcm59IGluc3RlYWQuXG4gKlxuICogTm90ZSB0aGF0IGBiaW5kTm9kZUNhbGxiYWNrYCBjYW4gYmUgdXNlZCBpbiBub24tTm9kZS5qcyBlbnZpcm9ubWVudHMgYXMgd2VsbC5cbiAqIFwiTm9kZS5qcy1zdHlsZVwiIGNhbGxiYWNrcyBhcmUganVzdCBhIGNvbnZlbnRpb24sIHNvIGlmIHlvdSB3cml0ZSBmb3JcbiAqIGJyb3dzZXJzIG9yIGFueSBvdGhlciBlbnZpcm9ubWVudCBhbmQgQVBJIHlvdSB1c2UgaW1wbGVtZW50cyB0aGF0IGNhbGxiYWNrIHN0eWxlLFxuICogYGJpbmROb2RlQ2FsbGJhY2tgIGNhbiBiZSBzYWZlbHkgdXNlZCBvbiB0aGF0IEFQSSBmdW5jdGlvbnMgYXMgd2VsbC5cbiAqXG4gKiBSZW1lbWJlciB0aGF0IEVycm9yIG9iamVjdCBwYXNzZWQgdG8gY2FsbGJhY2sgZG9lcyBub3QgaGF2ZSB0byBiZSBhbiBpbnN0YW5jZVxuICogb2YgSmF2YVNjcmlwdCBidWlsdC1pbiBgRXJyb3JgIG9iamVjdC4gSW4gZmFjdCwgaXQgZG9lcyBub3QgZXZlbiBoYXZlIHRvIGFuIG9iamVjdC5cbiAqIEVycm9yIHBhcmFtZXRlciBvZiBjYWxsYmFjayBmdW5jdGlvbiBpcyBpbnRlcnByZXRlZCBhcyBcInByZXNlbnRcIiwgd2hlbiB2YWx1ZVxuICogb2YgdGhhdCBwYXJhbWV0ZXIgaXMgdHJ1dGh5LiBJdCBjb3VsZCBiZSwgZm9yIGV4YW1wbGUsIG5vbi16ZXJvIG51bWJlciwgbm9uLWVtcHR5XG4gKiBzdHJpbmcgb3IgYm9vbGVhbiBgdHJ1ZWAuIEluIGFsbCBvZiB0aGVzZSBjYXNlcyByZXN1bHRpbmcgT2JzZXJ2YWJsZSB3b3VsZCBlcnJvclxuICogd2l0aCB0aGF0IHZhbHVlLiBUaGlzIG1lYW5zIHVzdWFsbHkgcmVndWxhciBzdHlsZSBjYWxsYmFja3Mgd2lsbCBmYWlsIHZlcnkgb2Z0ZW4gd2hlblxuICogYGJpbmROb2RlQ2FsbGJhY2tgIGlzIHVzZWQuIElmIHlvdXIgT2JzZXJ2YWJsZSBlcnJvcnMgbXVjaCBtb3JlIG9mdGVuIHRoZW4geW91XG4gKiB3b3VsZCBleHBlY3QsIGNoZWNrIGlmIGNhbGxiYWNrIHJlYWxseSBpcyBjYWxsZWQgaW4gTm9kZS5qcy1zdHlsZSBhbmQsIGlmIG5vdCxcbiAqIHN3aXRjaCB0byB7QGxpbmsgYmluZENhbGxiYWNrfSBpbnN0ZWFkLlxuICpcbiAqIE5vdGUgdGhhdCBldmVuIGlmIGVycm9yIHBhcmFtZXRlciBpcyB0ZWNobmljYWxseSBwcmVzZW50IGluIGNhbGxiYWNrLCBidXQgaXRzIHZhbHVlXG4gKiBpcyBmYWxzeSwgaXQgc3RpbGwgd29uJ3QgYXBwZWFyIGluIGFycmF5IGVtaXR0ZWQgYnkgT2JzZXJ2YWJsZS5cbiAqXG4gKiAjIyBFeGFtcGxlc1xuICogIyMjICBSZWFkIGEgZmlsZSBmcm9tIHRoZSBmaWxlc3lzdGVtIGFuZCBnZXQgdGhlIGRhdGEgYXMgYW4gT2JzZXJ2YWJsZVxuICogYGBgdHNcbiAqIGltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbiAqIGNvbnN0IHJlYWRGaWxlQXNPYnNlcnZhYmxlID0gYmluZE5vZGVDYWxsYmFjayhmcy5yZWFkRmlsZSk7XG4gKiBjb25zdCByZXN1bHQgPSByZWFkRmlsZUFzT2JzZXJ2YWJsZSgnLi9yb2FkTmFtZXMudHh0JywgJ3V0ZjgnKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgZSA9PiBjb25zb2xlLmVycm9yKGUpKTtcbiAqIGBgYFxuICpcbiAqICMjIyBVc2Ugb24gZnVuY3Rpb24gY2FsbGluZyBjYWxsYmFjayB3aXRoIG11bHRpcGxlIGFyZ3VtZW50c1xuICogYGBgdHNcbiAqIHNvbWVGdW5jdGlvbigoZXJyLCBhLCBiKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGVycik7IC8vIG51bGxcbiAqICAgY29uc29sZS5sb2coYSk7IC8vIDVcbiAqICAgY29uc29sZS5sb2coYik7IC8vIFwic29tZSBzdHJpbmdcIlxuICogfSk7XG4gKiBjb25zdCBib3VuZFNvbWVGdW5jdGlvbiA9IGJpbmROb2RlQ2FsbGJhY2soc29tZUZ1bmN0aW9uKTtcbiAqIGJvdW5kU29tZUZ1bmN0aW9uKClcbiAqIC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFs1LCBcInNvbWUgc3RyaW5nXCJdXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyBVc2Ugb24gZnVuY3Rpb24gY2FsbGluZyBjYWxsYmFjayBpbiByZWd1bGFyIHN0eWxlXG4gKiBgYGB0c1xuICogc29tZUZ1bmN0aW9uKGEgPT4ge1xuICogICBjb25zb2xlLmxvZyhhKTsgLy8gNVxuICogfSk7XG4gKiBjb25zdCBib3VuZFNvbWVGdW5jdGlvbiA9IGJpbmROb2RlQ2FsbGJhY2soc29tZUZ1bmN0aW9uKTtcbiAqIGJvdW5kU29tZUZ1bmN0aW9uKClcbiAqIC5zdWJzY3JpYmUoXG4gKiAgIHZhbHVlID0+IHt9ICAgICAgICAgICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gKiAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpIC8vIDVcbiAqICk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBiaW5kQ2FsbGJhY2t9XG4gKiBAc2VlIHtAbGluayBmcm9tfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gd2l0aCBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2sgYXMgdGhlIGxhc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtTY2hlZHVsZXJMaWtlfSBbc2NoZWR1bGVyXSBUaGUgc2NoZWR1bGVyIG9uIHdoaWNoIHRvIHNjaGVkdWxlIHRoZVxuICogY2FsbGJhY2tzLlxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4ucGFyYW1zOiAqKTogT2JzZXJ2YWJsZX0gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICogT2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzIHRoZSBzYW1lIHZhbHVlcyB0aGUgTm9kZS5qcyBjYWxsYmFjayB3b3VsZFxuICogZGVsaXZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmROb2RlQ2FsbGJhY2soXG4gIGNhbGxiYWNrRnVuYzogKC4uLmFyZ3M6IFsuLi5hbnlbXSwgKGVycjogYW55LCAuLi5yZXM6IGFueSkgPT4gdm9pZF0pID0+IHZvaWQsXG4gIHJlc3VsdFNlbGVjdG9yPzogKCguLi5hcmdzOiBhbnlbXSkgPT4gYW55KSB8IFNjaGVkdWxlckxpa2UsXG4gIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2Vcbik6ICguLi5hcmdzOiBhbnlbXSkgPT4gT2JzZXJ2YWJsZTxhbnk+IHtcbiAgcmV0dXJuIGJpbmRDYWxsYmFja0ludGVybmFscyh0cnVlLCBjYWxsYmFja0Z1bmMsIHJlc3VsdFNlbGVjdG9yLCBzY2hlZHVsZXIpO1xufVxuIl19
