import { map } from '../operators/map.mjs';
import { Observable } from '../Observable.mjs';
import { AjaxResponse } from './AjaxResponse.mjs';
import { AjaxTimeoutError, AjaxError } from './errors.mjs';
function ajaxGet(url, headers) {
    return ajax({ method: 'GET', url, headers });
}
function ajaxPost(url, body, headers) {
    return ajax({ method: 'POST', url, body, headers });
}
function ajaxDelete(url, headers) {
    return ajax({ method: 'DELETE', url, headers });
}
function ajaxPut(url, body, headers) {
    return ajax({ method: 'PUT', url, body, headers });
}
function ajaxPatch(url, body, headers) {
    return ajax({ method: 'PATCH', url, body, headers });
}
const mapResponse = map((x) => x.response);
function ajaxGetJSON(url, headers) {
    return mapResponse(ajax({
        method: 'GET',
        url,
        headers,
    }));
}
/**
 * There is an ajax operator on the Rx object.
 *
 * It creates an observable for an Ajax request with either a request object with
 * url, headers, etc or a string for a URL.
 *
 * ## Examples
 *
 * Using `ajax()` to fetch the response object that is being returned from API
 *
 * ```ts
 * import { ajax } from 'rxjs/ajax';
 * import { map, catchError, of } from 'rxjs';
 *
 * const obs$ = ajax('https://api.github.com/users?per_page=5').pipe(
 *   map(userResponse => console.log('users: ', userResponse)),
 *   catchError(error => {
 *     console.log('error: ', error);
 *     return of(error);
 *   })
 * );
 *
 * obs$.subscribe({
 *   next: value => console.log(value),
 *   error: err => console.log(err)
 * });
 * ```
 *
 * Using `ajax.getJSON()` to fetch data from API
 *
 * ```ts
 * import { ajax } from 'rxjs/ajax';
 * import { map, catchError, of } from 'rxjs';
 *
 * const obs$ = ajax.getJSON('https://api.github.com/users?per_page=5').pipe(
 *   map(userResponse => console.log('users: ', userResponse)),
 *   catchError(error => {
 *     console.log('error: ', error);
 *     return of(error);
 *   })
 * );
 *
 * obs$.subscribe({
 *   next: value => console.log(value),
 *   error: err => console.log(err)
 * });
 * ```
 *
 * Using `ajax()` with object as argument and method POST with a two seconds delay
 *
 * ```ts
 * import { ajax } from 'rxjs/ajax';
 * import { map, catchError, of } from 'rxjs';
 *
 * const users = ajax({
 *   url: 'https://httpbin.org/delay/2',
 *   method: 'POST',
 *   headers: {
 *     'Content-Type': 'application/json',
 *     'rxjs-custom-header': 'Rxjs'
 *   },
 *   body: {
 *     rxjs: 'Hello World!'
 *   }
 * }).pipe(
 *   map(response => console.log('response: ', response)),
 *   catchError(error => {
 *     console.log('error: ', error);
 *     return of(error);
 *   })
 * );
 *
 * users.subscribe({
 *   next: value => console.log(value),
 *   error: err => console.log(err)
 * });
 * ```
 *
 * Using `ajax()` to fetch. An error object that is being returned from the request
 *
 * ```ts
 * import { ajax } from 'rxjs/ajax';
 * import { map, catchError, of } from 'rxjs';
 *
 * const obs$ = ajax('https://api.github.com/404').pipe(
 *   map(userResponse => console.log('users: ', userResponse)),
 *   catchError(error => {
 *     console.log('error: ', error);
 *     return of(error);
 *   })
 * );
 *
 * obs$.subscribe({
 *   next: value => console.log(value),
 *   error: err => console.log(err)
 * });
 * ```
 */
export const ajax = (() => {
    const create = (urlOrConfig) => {
        const config = typeof urlOrConfig === 'string'
            ? {
                url: urlOrConfig,
            }
            : urlOrConfig;
        return fromAjax(config);
    };
    create.get = ajaxGet;
    create.post = ajaxPost;
    create.delete = ajaxDelete;
    create.put = ajaxPut;
    create.patch = ajaxPatch;
    create.getJSON = ajaxGetJSON;
    return create;
})();
const UPLOAD = 'upload';
const DOWNLOAD = 'download';
const LOADSTART = 'loadstart';
const PROGRESS = 'progress';
const LOAD = 'load';
export function fromAjax(init) {
    return new Observable((destination) => {
        var _a, _b;
        const config = Object.assign({ 
            // Defaults
            async: true, crossDomain: false, withCredentials: false, method: 'GET', timeout: 0, responseType: 'json' }, init);
        const { queryParams, body: configuredBody, headers: configuredHeaders } = config;
        let url = config.url;
        if (!url) {
            throw new TypeError('url is required');
        }
        if (queryParams) {
            let searchParams;
            if (url.includes('?')) {
                // If the user has passed a URL with a querystring already in it,
                // we need to combine them. So we're going to split it. There
                // should only be one `?` in a valid URL.
                const parts = url.split('?');
                if (2 < parts.length) {
                    throw new TypeError('invalid url');
                }
                // Add the passed queryParams to the params already in the url provided.
                searchParams = new URLSearchParams(parts[1]);
                // queryParams is converted to any because the runtime is *much* more permissive than
                // the types are.
                new URLSearchParams(queryParams).forEach((value, key) => searchParams.set(key, value));
                // We have to do string concatenation here, because `new URL(url)` does
                // not like relative URLs like `/this` without a base url, which we can't
                // specify, nor can we assume `location` will exist, because of node.
                url = parts[0] + '?' + searchParams;
            }
            else {
                // There is no preexisting querystring, so we can just use URLSearchParams
                // to convert the passed queryParams into the proper format and encodings.
                // queryParams is converted to any because the runtime is *much* more permissive than
                // the types are.
                searchParams = new URLSearchParams(queryParams);
                url = url + '?' + searchParams;
            }
        }
        // Normalize the headers. We're going to make them all lowercase, since
        // Headers are case insensitive by design. This makes it easier to verify
        // that we aren't setting or sending duplicates.
        const headers = {};
        if (configuredHeaders) {
            for (const key in configuredHeaders) {
                if (configuredHeaders.hasOwnProperty(key)) {
                    headers[key.toLowerCase()] = configuredHeaders[key];
                }
            }
        }
        const crossDomain = config.crossDomain;
        // Set the x-requested-with header. This is a non-standard header that has
        // come to be a de facto standard for HTTP requests sent by libraries and frameworks
        // using XHR. However, we DO NOT want to set this if it is a CORS request. This is
        // because sometimes this header can cause issues with CORS. To be clear,
        // None of this is necessary, it's only being set because it's "the thing libraries do"
        // Starting back as far as JQuery, and continuing with other libraries such as Angular 1,
        // Axios, et al.
        if (!crossDomain && !('x-requested-with' in headers)) {
            headers['x-requested-with'] = 'XMLHttpRequest';
        }
        // Allow users to provide their XSRF cookie name and the name of a custom header to use to
        // send the cookie.
        const { withCredentials, xsrfCookieName, xsrfHeaderName } = config;
        if ((withCredentials || !crossDomain) && xsrfCookieName && xsrfHeaderName) {
            const xsrfCookie = (_b = (_a = document === null || document === void 0 ? void 0 : document.cookie.match(new RegExp(`(^|;\\s*)(${xsrfCookieName})=([^;]*)`))) === null || _a === void 0 ? void 0 : _a.pop()) !== null && _b !== void 0 ? _b : '';
            if (xsrfCookie) {
                headers[xsrfHeaderName] = xsrfCookie;
            }
        }
        // Examine the body and determine whether or not to serialize it
        // and set the content-type in `headers`, if we're able.
        const body = extractContentTypeAndMaybeSerializeBody(configuredBody, headers);
        // The final request settings.
        const _request = Object.assign(Object.assign({}, config), { 
            // Set values we ensured above
            url,
            headers,
            body });
        let xhr;
        // Create our XHR so we can get started.
        xhr = init.createXHR ? init.createXHR() : new XMLHttpRequest();
        {
            ///////////////////////////////////////////////////
            // set up the events before open XHR
            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
            // You need to add the event listeners before calling open() on the request.
            // Otherwise the progress events will not fire.
            ///////////////////////////////////////////////////
            const { progressSubscriber, includeDownloadProgress = false, includeUploadProgress = false } = init;
            /**
             * Wires up an event handler that will emit an error when fired. Used
             * for timeout and abort events.
             * @param type The type of event we're treating as an error
             * @param errorFactory A function that creates the type of error to emit.
             */
            const addErrorEvent = (type, errorFactory) => {
                xhr.addEventListener(type, () => {
                    var _a;
                    const error = errorFactory();
                    (_a = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber, error);
                    destination.error(error);
                });
            };
            // If the request times out, handle errors appropriately.
            addErrorEvent('timeout', () => new AjaxTimeoutError(xhr, _request));
            // If the request aborts (due to a network disconnection or the like), handle
            // it as an error.
            addErrorEvent('abort', () => new AjaxError('aborted', xhr, _request));
            /**
             * Creates a response object to emit to the consumer.
             * @param direction the direction related to the event. Prefixes the event `type` in the
             * `AjaxResponse` object with "upload_" for events related to uploading and "download_"
             * for events related to downloading.
             * @param event the actual event object.
             */
            const createResponse = (direction, event) => new AjaxResponse(event, xhr, _request, `${direction}_${event.type}`);
            /**
             * Wires up an event handler that emits a Response object to the consumer, used for
             * all events that emit responses, loadstart, progress, and load.
             * Note that download load handling is a bit different below, because it has
             * more logic it needs to run.
             * @param target The target, either the XHR itself or the Upload object.
             * @param type The type of event to wire up
             * @param direction The "direction", used to prefix the response object that is
             * emitted to the consumer. (e.g. "upload_" or "download_")
             */
            const addProgressEvent = (target, type, direction) => {
                target.addEventListener(type, (event) => {
                    destination.next(createResponse(direction, event));
                });
            };
            if (includeUploadProgress) {
                [LOADSTART, PROGRESS, LOAD].forEach((type) => addProgressEvent(xhr.upload, type, UPLOAD));
            }
            if (progressSubscriber) {
                [LOADSTART, PROGRESS].forEach((type) => xhr.upload.addEventListener(type, (e) => { var _a; return (_a = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.next) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber, e); }));
            }
            if (includeDownloadProgress) {
                [LOADSTART, PROGRESS].forEach((type) => addProgressEvent(xhr, type, DOWNLOAD));
            }
            const emitError = (status) => {
                const msg = 'ajax error' + (status ? ' ' + status : '');
                destination.error(new AjaxError(msg, xhr, _request));
            };
            xhr.addEventListener('error', (e) => {
                var _a;
                (_a = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber, e);
                emitError();
            });
            xhr.addEventListener(LOAD, (event) => {
                var _a, _b;
                const { status } = xhr;
                // 4xx and 5xx should error (https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)
                if (status < 400) {
                    (_a = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.complete) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber);
                    let response;
                    try {
                        // This can throw in IE, because we end up needing to do a JSON.parse
                        // of the response in some cases to produce object we'd expect from
                        // modern browsers.
                        response = createResponse(DOWNLOAD, event);
                    }
                    catch (err) {
                        destination.error(err);
                        return;
                    }
                    destination.next(response);
                    destination.complete();
                }
                else {
                    (_b = progressSubscriber === null || progressSubscriber === void 0 ? void 0 : progressSubscriber.error) === null || _b === void 0 ? void 0 : _b.call(progressSubscriber, event);
                    emitError(status);
                }
            });
        }
        const { user, method, async } = _request;
        // open XHR
        if (user) {
            xhr.open(method, url, async, user, _request.password);
        }
        else {
            xhr.open(method, url, async);
        }
        // timeout, responseType and withCredentials can be set once the XHR is open
        if (async) {
            xhr.timeout = _request.timeout;
            xhr.responseType = _request.responseType;
        }
        if ('withCredentials' in xhr) {
            xhr.withCredentials = _request.withCredentials;
        }
        // set headers
        for (const key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
        // finally send the request
        if (body) {
            xhr.send(body);
        }
        else {
            xhr.send();
        }
        return () => {
            if (xhr && xhr.readyState !== 4 /*XHR done*/) {
                xhr.abort();
            }
        };
    });
}
/**
 * Examines the body to determine if we need to serialize it for them or not.
 * If the body is a type that XHR handles natively, we just allow it through,
 * otherwise, if the body is something that *we* can serialize for the user,
 * we will serialize it, and attempt to set the `content-type` header, if it's
 * not already set.
 * @param body The body passed in by the user
 * @param headers The normalized headers
 */
function extractContentTypeAndMaybeSerializeBody(body, headers) {
    var _a;
    if (!body ||
        typeof body === 'string' ||
        isFormData(body) ||
        isURLSearchParams(body) ||
        isArrayBuffer(body) ||
        isFile(body) ||
        isBlob(body) ||
        isReadableStream(body)) {
        // The XHR instance itself can handle serializing these, and set the content-type for us
        // so we don't need to do that. https://xhr.spec.whatwg.org/#the-send()-method
        return body;
    }
    if (isArrayBufferView(body)) {
        // This is a typed array (e.g. Float32Array or Uint8Array), or a DataView.
        // XHR can handle this one too: https://fetch.spec.whatwg.org/#concept-bodyinit-extract
        return body.buffer;
    }
    if (typeof body === 'object') {
        // If we have made it here, this is an object, probably a POJO, and we'll try
        // to serialize it for them. If this doesn't work, it will throw, obviously, which
        // is okay. The workaround for users would be to manually set the body to their own
        // serialized string (accounting for circular references or whatever), then set
        // the content-type manually as well.
        headers['content-type'] = (_a = headers['content-type']) !== null && _a !== void 0 ? _a : 'application/json;charset=utf-8';
        return JSON.stringify(body);
    }
    // If we've gotten past everything above, this is something we don't quite know how to
    // handle. Throw an error. This will be caught and emitted from the observable.
    throw new TypeError('Unknown body type');
}
const _toString = Object.prototype.toString;
function toStringCheck(obj, name) {
    return _toString.call(obj) === `[object ${name}]`;
}
function isArrayBuffer(body) {
    return toStringCheck(body, 'ArrayBuffer');
}
function isFile(body) {
    return toStringCheck(body, 'File');
}
function isBlob(body) {
    return toStringCheck(body, 'Blob');
}
function isArrayBufferView(body) {
    return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(body);
}
function isFormData(body) {
    return typeof FormData !== 'undefined' && body instanceof FormData;
}
function isURLSearchParams(body) {
    return typeof URLSearchParams !== 'undefined' && body instanceof URLSearchParams;
}
function isReadableStream(body) {
    return typeof ReadableStream !== 'undefined' && body instanceof ReadableStream;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9hamF4L2FqYXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxTQUFTLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFxSXZELFNBQVMsT0FBTyxDQUFJLEdBQVcsRUFBRSxPQUFnQztJQUMvRCxPQUFPLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUVELFNBQVMsUUFBUSxDQUFJLEdBQVcsRUFBRSxJQUFVLEVBQUUsT0FBZ0M7SUFDNUUsT0FBTyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztBQUN0RCxDQUFDO0FBRUQsU0FBUyxVQUFVLENBQUksR0FBVyxFQUFFLE9BQWdDO0lBQ2xFLE9BQU8sSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztBQUNsRCxDQUFDO0FBRUQsU0FBUyxPQUFPLENBQUksR0FBVyxFQUFFLElBQVUsRUFBRSxPQUFnQztJQUMzRSxPQUFPLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0FBQ3JELENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FBSSxHQUFXLEVBQUUsSUFBVSxFQUFFLE9BQWdDO0lBQzdFLE9BQU8sSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxH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akYsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvYWpheC9hamF4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vb3BlcmF0b3JzL21hcCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBBamF4Q29uZmlnLCBBamF4UmVxdWVzdCwgQWpheERpcmVjdGlvbiwgUHJvZ3Jlc3NFdmVudFR5cGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEFqYXhSZXNwb25zZSB9IGZyb20gJy4vQWpheFJlc3BvbnNlJztcbmltcG9ydCB7IEFqYXhUaW1lb3V0RXJyb3IsIEFqYXhFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBBamF4Q3JlYXRpb25NZXRob2Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHRoYXQgd2lsbCBwZXJmb3JtIGFuIEFKQVggcmVxdWVzdCB1c2luZyB0aGVcbiAgICogW1hNTEh0dHBSZXF1ZXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QpIGluXG4gICAqIGdsb2JhbCBzY29wZSBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBtb3N0IGNvbmZpZ3VyYWJsZSBvcHRpb24sIGFuZCB0aGUgYmFzaXMgZm9yIGFsbCBvdGhlciBBSkFYIGNhbGxzIGluIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiAjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IGFqYXggfSBmcm9tICdyeGpzL2FqYXgnO1xuICAgKiBpbXBvcnQgeyBtYXAsIGNhdGNoRXJyb3IsIG9mIH0gZnJvbSAncnhqcyc7XG4gICAqXG4gICAqIGNvbnN0IG9icyQgPSBhamF4KHtcbiAgICogICBtZXRob2Q6ICdHRVQnLFxuICAgKiAgIHVybDogJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vdXNlcnM/cGVyX3BhZ2U9NScsXG4gICAqICAgcmVzcG9uc2VUeXBlOiAnanNvbidcbiAgICogfSkucGlwZShcbiAgICogICBtYXAodXNlclJlc3BvbnNlID0+IGNvbnNvbGUubG9nKCd1c2VyczogJywgdXNlclJlc3BvbnNlKSksXG4gICAqICAgY2F0Y2hFcnJvcihlcnJvciA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZygnZXJyb3I6ICcsIGVycm9yKTtcbiAgICogICAgIHJldHVybiBvZihlcnJvcik7XG4gICAqICAgfSlcbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICA8VD4oY29uZmlnOiBBamF4Q29uZmlnKTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U8VD4+O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIEhUVFAgR0VUIHVzaW5nIHRoZVxuICAgKiBbWE1MSHR0cFJlcXVlc3RdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdCkgaW5cbiAgICogZ2xvYmFsIHNjb3BlLiBEZWZhdWx0cyB0byBhIGByZXNwb25zZVR5cGVgIG9mIGBcImpzb25cImAuXG4gICAqXG4gICAqICMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgYWpheCB9IGZyb20gJ3J4anMvYWpheCc7XG4gICAqIGltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciwgb2YgfSBmcm9tICdyeGpzJztcbiAgICpcbiAgICogY29uc3Qgb2JzJCA9IGFqYXgoJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vdXNlcnM/cGVyX3BhZ2U9NScpLnBpcGUoXG4gICAqICAgbWFwKHVzZXJSZXNwb25zZSA9PiBjb25zb2xlLmxvZygndXNlcnM6ICcsIHVzZXJSZXNwb25zZSkpLFxuICAgKiAgIGNhdGNoRXJyb3IoZXJyb3IgPT4ge1xuICAgKiAgICAgY29uc29sZS5sb2coJ2Vycm9yOiAnLCBlcnJvcik7XG4gICAqICAgICByZXR1cm4gb2YoZXJyb3IpO1xuICAgKiAgIH0pXG4gICAqICk7XG4gICAqIGBgYFxuICAgKi9cbiAgPFQ+KHVybDogc3RyaW5nKTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U8VD4+O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhbiBIVFRQIEdFVCB1c2luZyB0aGVcbiAgICogW1hNTEh0dHBSZXF1ZXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QpIGluXG4gICAqIGdsb2JhbCBzY29wZSBieSBkZWZhdWx0LCBhbmQgYSBgcmVzcG9uc2VUeXBlYCBvZiBgXCJqc29uXCJgLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gZ2V0IHRoZSByZXNvdXJjZSBmcm9tXG4gICAqIEBwYXJhbSBoZWFkZXJzIE9wdGlvbmFsIGhlYWRlcnMuIENhc2UtSW5zZW5zaXRpdmUuXG4gICAqL1xuICBnZXQ8VD4odXJsOiBzdHJpbmcsIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U8VD4+O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhbiBIVFRQIFBPU1QgdXNpbmcgdGhlXG4gICAqIFtYTUxIdHRwUmVxdWVzdF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0KSBpblxuICAgKiBnbG9iYWwgc2NvcGUgYnkgZGVmYXVsdCwgYW5kIGEgYHJlc3BvbnNlVHlwZWAgb2YgYFwianNvblwiYC5cbiAgICpcbiAgICogQmVmb3JlIHNlbmRpbmcgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGUgYGJvZHlgIGFyZ3VtZW50LCBpdCBpcyBhdXRvbWF0aWNhbGx5IHNlcmlhbGl6ZWRcbiAgICogYmFzZWQgb24gdGhlIHNwZWNpZmllZCBgcmVzcG9uc2VUeXBlYC4gQnkgZGVmYXVsdCwgYSBKYXZhU2NyaXB0IG9iamVjdCB3aWxsIGJlIHNlcmlhbGl6ZWRcbiAgICogdG8gSlNPTi4gQSBgcmVzcG9uc2VUeXBlYCBvZiBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYCB3aWxsIGZsYXR0ZW4gYW55IHByb3ZpZGVkXG4gICAqIGRpY3Rpb25hcnkgb2JqZWN0IHRvIGEgdXJsLWVuY29kZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gZ2V0IHRoZSByZXNvdXJjZSBmcm9tXG4gICAqIEBwYXJhbSBib2R5IFRoZSBjb250ZW50IHRvIHNlbmQuIFRoZSBib2R5IGlzIGF1dG9tYXRpY2FsbHkgc2VyaWFsaXplZC5cbiAgICogQHBhcmFtIGhlYWRlcnMgT3B0aW9uYWwgaGVhZGVycy4gQ2FzZS1JbnNlbnNpdGl2ZS5cbiAgICovXG4gIHBvc3Q8VD4odXJsOiBzdHJpbmcsIGJvZHk/OiBhbnksIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U8VD4+O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhbiBIVFRQIFBVVCB1c2luZyB0aGVcbiAgICogW1hNTEh0dHBSZXF1ZXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QpIGluXG4gICAqIGdsb2JhbCBzY29wZSBieSBkZWZhdWx0LCBhbmQgYSBgcmVzcG9uc2VUeXBlYCBvZiBgXCJqc29uXCJgLlxuICAgKlxuICAgKiBCZWZvcmUgc2VuZGluZyB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBgYm9keWAgYXJndW1lbnQsIGl0IGlzIGF1dG9tYXRpY2FsbHkgc2VyaWFsaXplZFxuICAgKiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGByZXNwb25zZVR5cGVgLiBCeSBkZWZhdWx0LCBhIEphdmFTY3JpcHQgb2JqZWN0IHdpbGwgYmUgc2VyaWFsaXplZFxuICAgKiB0byBKU09OLiBBIGByZXNwb25zZVR5cGVgIG9mIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgIHdpbGwgZmxhdHRlbiBhbnkgcHJvdmlkZWRcbiAgICogZGljdGlvbmFyeSBvYmplY3QgdG8gYSB1cmwtZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byBnZXQgdGhlIHJlc291cmNlIGZyb21cbiAgICogQHBhcmFtIGJvZHkgVGhlIGNvbnRlbnQgdG8gc2VuZC4gVGhlIGJvZHkgaXMgYXV0b21hdGljYWxseSBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0gaGVhZGVycyBPcHRpb25hbCBoZWFkZXJzLiBDYXNlLUluc2Vuc2l0aXZlLlxuICAgKi9cbiAgcHV0PFQ+KHVybDogc3RyaW5nLCBib2R5PzogYW55LCBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IE9ic2VydmFibGU8QWpheFJlc3BvbnNlPFQ+PjtcblxuICAvKipcbiAgICogUGVyZm9ybXMgYW4gSFRUUCBQQVRDSCB1c2luZyB0aGVcbiAgICogW1hNTEh0dHBSZXF1ZXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QpIGluXG4gICAqIGdsb2JhbCBzY29wZSBieSBkZWZhdWx0LCBhbmQgYSBgcmVzcG9uc2VUeXBlYCBvZiBgXCJqc29uXCJgLlxuICAgKlxuICAgKiBCZWZvcmUgc2VuZGluZyB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBgYm9keWAgYXJndW1lbnQsIGl0IGlzIGF1dG9tYXRpY2FsbHkgc2VyaWFsaXplZFxuICAgKiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGByZXNwb25zZVR5cGVgLiBCeSBkZWZhdWx0LCBhIEphdmFTY3JpcHQgb2JqZWN0IHdpbGwgYmUgc2VyaWFsaXplZFxuICAgKiB0byBKU09OLiBBIGByZXNwb25zZVR5cGVgIG9mIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgIHdpbGwgZmxhdHRlbiBhbnkgcHJvdmlkZWRcbiAgICogZGljdGlvbmFyeSBvYmplY3QgdG8gYSB1cmwtZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byBnZXQgdGhlIHJlc291cmNlIGZyb21cbiAgICogQHBhcmFtIGJvZHkgVGhlIGNvbnRlbnQgdG8gc2VuZC4gVGhlIGJvZHkgaXMgYXV0b21hdGljYWxseSBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0gaGVhZGVycyBPcHRpb25hbCBoZWFkZXJzLiBDYXNlLUluc2Vuc2l0aXZlLlxuICAgKi9cbiAgcGF0Y2g8VD4odXJsOiBzdHJpbmcsIGJvZHk/OiBhbnksIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U8VD4+O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhbiBIVFRQIERFTEVURSB1c2luZyB0aGVcbiAgICogW1hNTEh0dHBSZXF1ZXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QpIGluXG4gICAqIGdsb2JhbCBzY29wZSBieSBkZWZhdWx0LCBhbmQgYSBgcmVzcG9uc2VUeXBlYCBvZiBgXCJqc29uXCJgLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gZ2V0IHRoZSByZXNvdXJjZSBmcm9tXG4gICAqIEBwYXJhbSBoZWFkZXJzIE9wdGlvbmFsIGhlYWRlcnMuIENhc2UtSW5zZW5zaXRpdmUuXG4gICAqL1xuICBkZWxldGU8VD4odXJsOiBzdHJpbmcsIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U8VD4+O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhbiBIVFRQIEdFVCB1c2luZyB0aGVcbiAgICogW1hNTEh0dHBSZXF1ZXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QpIGluXG4gICAqIGdsb2JhbCBzY29wZSBieSBkZWZhdWx0LCBhbmQgcmV0dXJucyB0aGUgaHlkcmF0ZWQgSmF2YVNjcmlwdCBvYmplY3QgZnJvbSB0aGVcbiAgICogcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byBnZXQgdGhlIHJlc291cmNlIGZyb21cbiAgICogQHBhcmFtIGhlYWRlcnMgT3B0aW9uYWwgaGVhZGVycy4gQ2FzZS1JbnNlbnNpdGl2ZS5cbiAgICovXG4gIGdldEpTT048VD4odXJsOiBzdHJpbmcsIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogT2JzZXJ2YWJsZTxUPjtcbn1cblxuZnVuY3Rpb24gYWpheEdldDxUPih1cmw6IHN0cmluZywgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBPYnNlcnZhYmxlPEFqYXhSZXNwb25zZTxUPj4ge1xuICByZXR1cm4gYWpheCh7IG1ldGhvZDogJ0dFVCcsIHVybCwgaGVhZGVycyB9KTtcbn1cblxuZnVuY3Rpb24gYWpheFBvc3Q8VD4odXJsOiBzdHJpbmcsIGJvZHk/OiBhbnksIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U8VD4+IHtcbiAgcmV0dXJuIGFqYXgoeyBtZXRob2Q6ICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhamF4RGVsZXRlPFQ+KHVybDogc3RyaW5nLCBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IE9ic2VydmFibGU8QWpheFJlc3BvbnNlPFQ+PiB7XG4gIHJldHVybiBhamF4KHsgbWV0aG9kOiAnREVMRVRFJywgdXJsLCBoZWFkZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhamF4UHV0PFQ+KHVybDogc3RyaW5nLCBib2R5PzogYW55LCBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IE9ic2VydmFibGU8QWpheFJlc3BvbnNlPFQ+PiB7XG4gIHJldHVybiBhamF4KHsgbWV0aG9kOiAnUFVUJywgdXJsLCBib2R5LCBoZWFkZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhamF4UGF0Y2g8VD4odXJsOiBzdHJpbmcsIGJvZHk/OiBhbnksIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U8VD4+IHtcbiAgcmV0dXJuIGFqYXgoeyBtZXRob2Q6ICdQQVRDSCcsIHVybCwgYm9keSwgaGVhZGVycyB9KTtcbn1cblxuY29uc3QgbWFwUmVzcG9uc2UgPSBtYXAoKHg6IEFqYXhSZXNwb25zZTxhbnk+KSA9PiB4LnJlc3BvbnNlKTtcblxuZnVuY3Rpb24gYWpheEdldEpTT048VD4odXJsOiBzdHJpbmcsIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiBtYXBSZXNwb25zZShcbiAgICBhamF4PFQ+KHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogVGhlcmUgaXMgYW4gYWpheCBvcGVyYXRvciBvbiB0aGUgUnggb2JqZWN0LlxuICpcbiAqIEl0IGNyZWF0ZXMgYW4gb2JzZXJ2YWJsZSBmb3IgYW4gQWpheCByZXF1ZXN0IHdpdGggZWl0aGVyIGEgcmVxdWVzdCBvYmplY3Qgd2l0aFxuICogdXJsLCBoZWFkZXJzLCBldGMgb3IgYSBzdHJpbmcgZm9yIGEgVVJMLlxuICpcbiAqICMjIEV4YW1wbGVzXG4gKlxuICogVXNpbmcgYGFqYXgoKWAgdG8gZmV0Y2ggdGhlIHJlc3BvbnNlIG9iamVjdCB0aGF0IGlzIGJlaW5nIHJldHVybmVkIGZyb20gQVBJXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGFqYXggfSBmcm9tICdyeGpzL2FqYXgnO1xuICogaW1wb3J0IHsgbWFwLCBjYXRjaEVycm9yLCBvZiB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IG9icyQgPSBhamF4KCdodHRwczovL2FwaS5naXRodWIuY29tL3VzZXJzP3Blcl9wYWdlPTUnKS5waXBlKFxuICogICBtYXAodXNlclJlc3BvbnNlID0+IGNvbnNvbGUubG9nKCd1c2VyczogJywgdXNlclJlc3BvbnNlKSksXG4gKiAgIGNhdGNoRXJyb3IoZXJyb3IgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdlcnJvcjogJywgZXJyb3IpO1xuICogICAgIHJldHVybiBvZihlcnJvcik7XG4gKiAgIH0pXG4gKiApO1xuICpcbiAqIG9icyQuc3Vic2NyaWJlKHtcbiAqICAgbmV4dDogdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogICBlcnJvcjogZXJyID0+IGNvbnNvbGUubG9nKGVycilcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNpbmcgYGFqYXguZ2V0SlNPTigpYCB0byBmZXRjaCBkYXRhIGZyb20gQVBJXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGFqYXggfSBmcm9tICdyeGpzL2FqYXgnO1xuICogaW1wb3J0IHsgbWFwLCBjYXRjaEVycm9yLCBvZiB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IG9icyQgPSBhamF4LmdldEpTT04oJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vdXNlcnM/cGVyX3BhZ2U9NScpLnBpcGUoXG4gKiAgIG1hcCh1c2VyUmVzcG9uc2UgPT4gY29uc29sZS5sb2coJ3VzZXJzOiAnLCB1c2VyUmVzcG9uc2UpKSxcbiAqICAgY2F0Y2hFcnJvcihlcnJvciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ2Vycm9yOiAnLCBlcnJvcik7XG4gKiAgICAgcmV0dXJuIG9mKGVycm9yKTtcbiAqICAgfSlcbiAqICk7XG4gKlxuICogb2JzJC5zdWJzY3JpYmUoe1xuICogICBuZXh0OiB2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSksXG4gKiAgIGVycm9yOiBlcnIgPT4gY29uc29sZS5sb2coZXJyKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2luZyBgYWpheCgpYCB3aXRoIG9iamVjdCBhcyBhcmd1bWVudCBhbmQgbWV0aG9kIFBPU1Qgd2l0aCBhIHR3byBzZWNvbmRzIGRlbGF5XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGFqYXggfSBmcm9tICdyeGpzL2FqYXgnO1xuICogaW1wb3J0IHsgbWFwLCBjYXRjaEVycm9yLCBvZiB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IHVzZXJzID0gYWpheCh7XG4gKiAgIHVybDogJ2h0dHBzOi8vaHR0cGJpbi5vcmcvZGVsYXkvMicsXG4gKiAgIG1ldGhvZDogJ1BPU1QnLFxuICogICBoZWFkZXJzOiB7XG4gKiAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAqICAgICAncnhqcy1jdXN0b20taGVhZGVyJzogJ1J4anMnXG4gKiAgIH0sXG4gKiAgIGJvZHk6IHtcbiAqICAgICByeGpzOiAnSGVsbG8gV29ybGQhJ1xuICogICB9XG4gKiB9KS5waXBlKFxuICogICBtYXAocmVzcG9uc2UgPT4gY29uc29sZS5sb2coJ3Jlc3BvbnNlOiAnLCByZXNwb25zZSkpLFxuICogICBjYXRjaEVycm9yKGVycm9yID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyb3I6ICcsIGVycm9yKTtcbiAqICAgICByZXR1cm4gb2YoZXJyb3IpO1xuICogICB9KVxuICogKTtcbiAqXG4gKiB1c2Vycy5zdWJzY3JpYmUoe1xuICogICBuZXh0OiB2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSksXG4gKiAgIGVycm9yOiBlcnIgPT4gY29uc29sZS5sb2coZXJyKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2luZyBgYWpheCgpYCB0byBmZXRjaC4gQW4gZXJyb3Igb2JqZWN0IHRoYXQgaXMgYmVpbmcgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdFxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBhamF4IH0gZnJvbSAncnhqcy9hamF4JztcbiAqIGltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciwgb2YgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBvYnMkID0gYWpheCgnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS80MDQnKS5waXBlKFxuICogICBtYXAodXNlclJlc3BvbnNlID0+IGNvbnNvbGUubG9nKCd1c2VyczogJywgdXNlclJlc3BvbnNlKSksXG4gKiAgIGNhdGNoRXJyb3IoZXJyb3IgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdlcnJvcjogJywgZXJyb3IpO1xuICogICAgIHJldHVybiBvZihlcnJvcik7XG4gKiAgIH0pXG4gKiApO1xuICpcbiAqIG9icyQuc3Vic2NyaWJlKHtcbiAqICAgbmV4dDogdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogICBlcnJvcjogZXJyID0+IGNvbnNvbGUubG9nKGVycilcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBhamF4OiBBamF4Q3JlYXRpb25NZXRob2QgPSAoKCkgPT4ge1xuICBjb25zdCBjcmVhdGUgPSA8VD4odXJsT3JDb25maWc6IHN0cmluZyB8IEFqYXhDb25maWcpID0+IHtcbiAgICBjb25zdCBjb25maWc6IEFqYXhDb25maWcgPVxuICAgICAgdHlwZW9mIHVybE9yQ29uZmlnID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIHVybDogdXJsT3JDb25maWcsXG4gICAgICAgICAgfVxuICAgICAgICA6IHVybE9yQ29uZmlnO1xuICAgIHJldHVybiBmcm9tQWpheDxUPihjb25maWcpO1xuICB9O1xuXG4gIGNyZWF0ZS5nZXQgPSBhamF4R2V0O1xuICBjcmVhdGUucG9zdCA9IGFqYXhQb3N0O1xuICBjcmVhdGUuZGVsZXRlID0gYWpheERlbGV0ZTtcbiAgY3JlYXRlLnB1dCA9IGFqYXhQdXQ7XG4gIGNyZWF0ZS5wYXRjaCA9IGFqYXhQYXRjaDtcbiAgY3JlYXRlLmdldEpTT04gPSBhamF4R2V0SlNPTjtcblxuICByZXR1cm4gY3JlYXRlO1xufSkoKTtcblxuY29uc3QgVVBMT0FEID0gJ3VwbG9hZCc7XG5jb25zdCBET1dOTE9BRCA9ICdkb3dubG9hZCc7XG5jb25zdCBMT0FEU1RBUlQgPSAnbG9hZHN0YXJ0JztcbmNvbnN0IFBST0dSRVNTID0gJ3Byb2dyZXNzJztcbmNvbnN0IExPQUQgPSAnbG9hZCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWpheDxUPihpbml0OiBBamF4Q29uZmlnKTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U8VD4+IHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChkZXN0aW5hdGlvbikgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIC8vIERlZmF1bHRzXG4gICAgICBhc3luYzogdHJ1ZSxcbiAgICAgIGNyb3NzRG9tYWluOiBmYWxzZSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdGltZW91dDogMCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nIGFzIFhNTEh0dHBSZXF1ZXN0UmVzcG9uc2VUeXBlLFxuXG4gICAgICAuLi5pbml0LFxuICAgIH07XG5cbiAgICBjb25zdCB7IHF1ZXJ5UGFyYW1zLCBib2R5OiBjb25maWd1cmVkQm9keSwgaGVhZGVyczogY29uZmlndXJlZEhlYWRlcnMgfSA9IGNvbmZpZztcblxuICAgIGxldCB1cmwgPSBjb25maWcudXJsO1xuICAgIGlmICghdXJsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1cmwgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnlQYXJhbXMpIHtcbiAgICAgIGxldCBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtcztcbiAgICAgIGlmICh1cmwuaW5jbHVkZXMoJz8nKSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXMgcGFzc2VkIGEgVVJMIHdpdGggYSBxdWVyeXN0cmluZyBhbHJlYWR5IGluIGl0LFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNvbWJpbmUgdGhlbS4gU28gd2UncmUgZ29pbmcgdG8gc3BsaXQgaXQuIFRoZXJlXG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIG9uZSBgP2AgaW4gYSB2YWxpZCBVUkwuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgICAgIGlmICgyIDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCB1cmwnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIHBhc3NlZCBxdWVyeVBhcmFtcyB0byB0aGUgcGFyYW1zIGFscmVhZHkgaW4gdGhlIHVybCBwcm92aWRlZC5cbiAgICAgICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJ0c1sxXSk7XG4gICAgICAgIC8vIHF1ZXJ5UGFyYW1zIGlzIGNvbnZlcnRlZCB0byBhbnkgYmVjYXVzZSB0aGUgcnVudGltZSBpcyAqbXVjaCogbW9yZSBwZXJtaXNzaXZlIHRoYW5cbiAgICAgICAgLy8gdGhlIHR5cGVzIGFyZS5cbiAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeVBhcmFtcyBhcyBhbnkpLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAvLyBXZSBoYXZlIHRvIGRvIHN0cmluZyBjb25jYXRlbmF0aW9uIGhlcmUsIGJlY2F1c2UgYG5ldyBVUkwodXJsKWAgZG9lc1xuICAgICAgICAvLyBub3QgbGlrZSByZWxhdGl2ZSBVUkxzIGxpa2UgYC90aGlzYCB3aXRob3V0IGEgYmFzZSB1cmwsIHdoaWNoIHdlIGNhbid0XG4gICAgICAgIC8vIHNwZWNpZnksIG5vciBjYW4gd2UgYXNzdW1lIGBsb2NhdGlvbmAgd2lsbCBleGlzdCwgYmVjYXVzZSBvZiBub2RlLlxuICAgICAgICB1cmwgPSBwYXJ0c1swXSArICc/JyArIHNlYXJjaFBhcmFtcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHByZWV4aXN0aW5nIHF1ZXJ5c3RyaW5nLCBzbyB3ZSBjYW4ganVzdCB1c2UgVVJMU2VhcmNoUGFyYW1zXG4gICAgICAgIC8vIHRvIGNvbnZlcnQgdGhlIHBhc3NlZCBxdWVyeVBhcmFtcyBpbnRvIHRoZSBwcm9wZXIgZm9ybWF0IGFuZCBlbmNvZGluZ3MuXG4gICAgICAgIC8vIHF1ZXJ5UGFyYW1zIGlzIGNvbnZlcnRlZCB0byBhbnkgYmVjYXVzZSB0aGUgcnVudGltZSBpcyAqbXVjaCogbW9yZSBwZXJtaXNzaXZlIHRoYW5cbiAgICAgICAgLy8gdGhlIHR5cGVzIGFyZS5cbiAgICAgICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeVBhcmFtcyBhcyBhbnkpO1xuICAgICAgICB1cmwgPSB1cmwgKyAnPycgKyBzZWFyY2hQYXJhbXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBoZWFkZXJzLiBXZSdyZSBnb2luZyB0byBtYWtlIHRoZW0gYWxsIGxvd2VyY2FzZSwgc2luY2VcbiAgICAvLyBIZWFkZXJzIGFyZSBjYXNlIGluc2Vuc2l0aXZlIGJ5IGRlc2lnbi4gVGhpcyBtYWtlcyBpdCBlYXNpZXIgdG8gdmVyaWZ5XG4gICAgLy8gdGhhdCB3ZSBhcmVuJ3Qgc2V0dGluZyBvciBzZW5kaW5nIGR1cGxpY2F0ZXMuXG4gICAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICAgIGlmIChjb25maWd1cmVkSGVhZGVycykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29uZmlndXJlZEhlYWRlcnMpIHtcbiAgICAgICAgaWYgKGNvbmZpZ3VyZWRIZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IGNvbmZpZ3VyZWRIZWFkZXJzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjcm9zc0RvbWFpbiA9IGNvbmZpZy5jcm9zc0RvbWFpbjtcblxuICAgIC8vIFNldCB0aGUgeC1yZXF1ZXN0ZWQtd2l0aCBoZWFkZXIuIFRoaXMgaXMgYSBub24tc3RhbmRhcmQgaGVhZGVyIHRoYXQgaGFzXG4gICAgLy8gY29tZSB0byBiZSBhIGRlIGZhY3RvIHN0YW5kYXJkIGZvciBIVFRQIHJlcXVlc3RzIHNlbnQgYnkgbGlicmFyaWVzIGFuZCBmcmFtZXdvcmtzXG4gICAgLy8gdXNpbmcgWEhSLiBIb3dldmVyLCB3ZSBETyBOT1Qgd2FudCB0byBzZXQgdGhpcyBpZiBpdCBpcyBhIENPUlMgcmVxdWVzdC4gVGhpcyBpc1xuICAgIC8vIGJlY2F1c2Ugc29tZXRpbWVzIHRoaXMgaGVhZGVyIGNhbiBjYXVzZSBpc3N1ZXMgd2l0aCBDT1JTLiBUbyBiZSBjbGVhcixcbiAgICAvLyBOb25lIG9mIHRoaXMgaXMgbmVjZXNzYXJ5LCBpdCdzIG9ubHkgYmVpbmcgc2V0IGJlY2F1c2UgaXQncyBcInRoZSB0aGluZyBsaWJyYXJpZXMgZG9cIlxuICAgIC8vIFN0YXJ0aW5nIGJhY2sgYXMgZmFyIGFzIEpRdWVyeSwgYW5kIGNvbnRpbnVpbmcgd2l0aCBvdGhlciBsaWJyYXJpZXMgc3VjaCBhcyBBbmd1bGFyIDEsXG4gICAgLy8gQXhpb3MsIGV0IGFsLlxuICAgIGlmICghY3Jvc3NEb21haW4gJiYgISgneC1yZXF1ZXN0ZWQtd2l0aCcgaW4gaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnNbJ3gtcmVxdWVzdGVkLXdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCc7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgdXNlcnMgdG8gcHJvdmlkZSB0aGVpciBYU1JGIGNvb2tpZSBuYW1lIGFuZCB0aGUgbmFtZSBvZiBhIGN1c3RvbSBoZWFkZXIgdG8gdXNlIHRvXG4gICAgLy8gc2VuZCB0aGUgY29va2llLlxuICAgIGNvbnN0IHsgd2l0aENyZWRlbnRpYWxzLCB4c3JmQ29va2llTmFtZSwgeHNyZkhlYWRlck5hbWUgfSA9IGNvbmZpZztcbiAgICBpZiAoKHdpdGhDcmVkZW50aWFscyB8fCAhY3Jvc3NEb21haW4pICYmIHhzcmZDb29raWVOYW1lICYmIHhzcmZIZWFkZXJOYW1lKSB7XG4gICAgICBjb25zdCB4c3JmQ29va2llID0gZG9jdW1lbnQ/LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKGAoXnw7XFxcXHMqKSgke3hzcmZDb29raWVOYW1lfSk9KFteO10qKWApKT8ucG9wKCkgPz8gJyc7XG4gICAgICBpZiAoeHNyZkNvb2tpZSkge1xuICAgICAgICBoZWFkZXJzW3hzcmZIZWFkZXJOYW1lXSA9IHhzcmZDb29raWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhhbWluZSB0aGUgYm9keSBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIHNlcmlhbGl6ZSBpdFxuICAgIC8vIGFuZCBzZXQgdGhlIGNvbnRlbnQtdHlwZSBpbiBgaGVhZGVyc2AsIGlmIHdlJ3JlIGFibGUuXG4gICAgY29uc3QgYm9keSA9IGV4dHJhY3RDb250ZW50VHlwZUFuZE1heWJlU2VyaWFsaXplQm9keShjb25maWd1cmVkQm9keSwgaGVhZGVycyk7XG5cbiAgICAvLyBUaGUgZmluYWwgcmVxdWVzdCBzZXR0aW5ncy5cbiAgICBjb25zdCBfcmVxdWVzdDogUmVhZG9ubHk8QWpheFJlcXVlc3Q+ID0ge1xuICAgICAgLi4uY29uZmlnLFxuXG4gICAgICAvLyBTZXQgdmFsdWVzIHdlIGVuc3VyZWQgYWJvdmVcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgIH07XG5cbiAgICBsZXQgeGhyOiBYTUxIdHRwUmVxdWVzdDtcblxuICAgIC8vIENyZWF0ZSBvdXIgWEhSIHNvIHdlIGNhbiBnZXQgc3RhcnRlZC5cbiAgICB4aHIgPSBpbml0LmNyZWF0ZVhIUiA/IGluaXQuY3JlYXRlWEhSKCkgOiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHtcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgLy8gc2V0IHVwIHRoZSBldmVudHMgYmVmb3JlIG9wZW4gWEhSXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvVXNpbmdfWE1MSHR0cFJlcXVlc3RcbiAgICAgIC8vIFlvdSBuZWVkIHRvIGFkZCB0aGUgZXZlbnQgbGlzdGVuZXJzIGJlZm9yZSBjYWxsaW5nIG9wZW4oKSBvbiB0aGUgcmVxdWVzdC5cbiAgICAgIC8vIE90aGVyd2lzZSB0aGUgcHJvZ3Jlc3MgZXZlbnRzIHdpbGwgbm90IGZpcmUuXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgY29uc3QgeyBwcm9ncmVzc1N1YnNjcmliZXIsIGluY2x1ZGVEb3dubG9hZFByb2dyZXNzID0gZmFsc2UsIGluY2x1ZGVVcGxvYWRQcm9ncmVzcyA9IGZhbHNlIH0gPSBpbml0O1xuXG4gICAgICAvKipcbiAgICAgICAqIFdpcmVzIHVwIGFuIGV2ZW50IGhhbmRsZXIgdGhhdCB3aWxsIGVtaXQgYW4gZXJyb3Igd2hlbiBmaXJlZC4gVXNlZFxuICAgICAgICogZm9yIHRpbWVvdXQgYW5kIGFib3J0IGV2ZW50cy5cbiAgICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHdlJ3JlIHRyZWF0aW5nIGFzIGFuIGVycm9yXG4gICAgICAgKiBAcGFyYW0gZXJyb3JGYWN0b3J5IEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB0eXBlIG9mIGVycm9yIHRvIGVtaXQuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGFkZEVycm9yRXZlbnQgPSAodHlwZTogc3RyaW5nLCBlcnJvckZhY3Rvcnk6ICgpID0+IGFueSkgPT4ge1xuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckZhY3RvcnkoKTtcbiAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXI/LmVycm9yPy4oZXJyb3IpO1xuICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJZiB0aGUgcmVxdWVzdCB0aW1lcyBvdXQsIGhhbmRsZSBlcnJvcnMgYXBwcm9wcmlhdGVseS5cbiAgICAgIGFkZEVycm9yRXZlbnQoJ3RpbWVvdXQnLCAoKSA9PiBuZXcgQWpheFRpbWVvdXRFcnJvcih4aHIsIF9yZXF1ZXN0KSk7XG5cbiAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGFib3J0cyAoZHVlIHRvIGEgbmV0d29yayBkaXNjb25uZWN0aW9uIG9yIHRoZSBsaWtlKSwgaGFuZGxlXG4gICAgICAvLyBpdCBhcyBhbiBlcnJvci5cbiAgICAgIGFkZEVycm9yRXZlbnQoJ2Fib3J0JywgKCkgPT4gbmV3IEFqYXhFcnJvcignYWJvcnRlZCcsIHhociwgX3JlcXVlc3QpKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgcmVzcG9uc2Ugb2JqZWN0IHRvIGVtaXQgdG8gdGhlIGNvbnN1bWVyLlxuICAgICAgICogQHBhcmFtIGRpcmVjdGlvbiB0aGUgZGlyZWN0aW9uIHJlbGF0ZWQgdG8gdGhlIGV2ZW50LiBQcmVmaXhlcyB0aGUgZXZlbnQgYHR5cGVgIGluIHRoZVxuICAgICAgICogYEFqYXhSZXNwb25zZWAgb2JqZWN0IHdpdGggXCJ1cGxvYWRfXCIgZm9yIGV2ZW50cyByZWxhdGVkIHRvIHVwbG9hZGluZyBhbmQgXCJkb3dubG9hZF9cIlxuICAgICAgICogZm9yIGV2ZW50cyByZWxhdGVkIHRvIGRvd25sb2FkaW5nLlxuICAgICAgICogQHBhcmFtIGV2ZW50IHRoZSBhY3R1YWwgZXZlbnQgb2JqZWN0LlxuICAgICAgICovXG4gICAgICBjb25zdCBjcmVhdGVSZXNwb25zZSA9IChkaXJlY3Rpb246IEFqYXhEaXJlY3Rpb24sIGV2ZW50OiBQcm9ncmVzc0V2ZW50KSA9PlxuICAgICAgICBuZXcgQWpheFJlc3BvbnNlPFQ+KGV2ZW50LCB4aHIsIF9yZXF1ZXN0LCBgJHtkaXJlY3Rpb259XyR7ZXZlbnQudHlwZSBhcyBQcm9ncmVzc0V2ZW50VHlwZX1gIGFzIGNvbnN0KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBXaXJlcyB1cCBhbiBldmVudCBoYW5kbGVyIHRoYXQgZW1pdHMgYSBSZXNwb25zZSBvYmplY3QgdG8gdGhlIGNvbnN1bWVyLCB1c2VkIGZvclxuICAgICAgICogYWxsIGV2ZW50cyB0aGF0IGVtaXQgcmVzcG9uc2VzLCBsb2Fkc3RhcnQsIHByb2dyZXNzLCBhbmQgbG9hZC5cbiAgICAgICAqIE5vdGUgdGhhdCBkb3dubG9hZCBsb2FkIGhhbmRsaW5nIGlzIGEgYml0IGRpZmZlcmVudCBiZWxvdywgYmVjYXVzZSBpdCBoYXNcbiAgICAgICAqIG1vcmUgbG9naWMgaXQgbmVlZHMgdG8gcnVuLlxuICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0LCBlaXRoZXIgdGhlIFhIUiBpdHNlbGYgb3IgdGhlIFVwbG9hZCBvYmplY3QuXG4gICAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byB3aXJlIHVwXG4gICAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIFRoZSBcImRpcmVjdGlvblwiLCB1c2VkIHRvIHByZWZpeCB0aGUgcmVzcG9uc2Ugb2JqZWN0IHRoYXQgaXNcbiAgICAgICAqIGVtaXR0ZWQgdG8gdGhlIGNvbnN1bWVyLiAoZS5nLiBcInVwbG9hZF9cIiBvciBcImRvd25sb2FkX1wiKVxuICAgICAgICovXG4gICAgICBjb25zdCBhZGRQcm9ncmVzc0V2ZW50ID0gKHRhcmdldDogYW55LCB0eXBlOiBzdHJpbmcsIGRpcmVjdGlvbjogQWpheERpcmVjdGlvbikgPT4ge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCAoZXZlbnQ6IFByb2dyZXNzRXZlbnQpID0+IHtcbiAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGNyZWF0ZVJlc3BvbnNlKGRpcmVjdGlvbiwgZXZlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoaW5jbHVkZVVwbG9hZFByb2dyZXNzKSB7XG4gICAgICAgIFtMT0FEU1RBUlQsIFBST0dSRVNTLCBMT0FEXS5mb3JFYWNoKCh0eXBlKSA9PiBhZGRQcm9ncmVzc0V2ZW50KHhoci51cGxvYWQsIHR5cGUsIFVQTE9BRCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgIFtMT0FEU1RBUlQsIFBST0dSRVNTXS5mb3JFYWNoKCh0eXBlKSA9PiB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgKGU6IGFueSkgPT4gcHJvZ3Jlc3NTdWJzY3JpYmVyPy5uZXh0Py4oZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVEb3dubG9hZFByb2dyZXNzKSB7XG4gICAgICAgIFtMT0FEU1RBUlQsIFBST0dSRVNTXS5mb3JFYWNoKCh0eXBlKSA9PiBhZGRQcm9ncmVzc0V2ZW50KHhociwgdHlwZSwgRE9XTkxPQUQpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW1pdEVycm9yID0gKHN0YXR1cz86IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBtc2cgPSAnYWpheCBlcnJvcicgKyAoc3RhdHVzID8gJyAnICsgc3RhdHVzIDogJycpO1xuICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgQWpheEVycm9yKG1zZywgeGhyLCBfcmVxdWVzdCkpO1xuICAgICAgfTtcblxuICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyPy5lcnJvcj8uKGUpO1xuICAgICAgICBlbWl0RXJyb3IoKTtcbiAgICAgIH0pO1xuXG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihMT0FELCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHhocjtcbiAgICAgICAgLy8gNHh4IGFuZCA1eHggc2hvdWxkIGVycm9yIChodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMxMC5odG1sKVxuICAgICAgICBpZiAoc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyPy5jb21wbGV0ZT8uKCk7XG5cbiAgICAgICAgICBsZXQgcmVzcG9uc2U6IEFqYXhSZXNwb25zZTxUPjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gdGhyb3cgaW4gSUUsIGJlY2F1c2Ugd2UgZW5kIHVwIG5lZWRpbmcgdG8gZG8gYSBKU09OLnBhcnNlXG4gICAgICAgICAgICAvLyBvZiB0aGUgcmVzcG9uc2UgaW4gc29tZSBjYXNlcyB0byBwcm9kdWNlIG9iamVjdCB3ZSdkIGV4cGVjdCBmcm9tXG4gICAgICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICAgICAgICByZXNwb25zZSA9IGNyZWF0ZVJlc3BvbnNlKERPV05MT0FELCBldmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzcG9uc2UpO1xuICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyPy5lcnJvcj8uKGV2ZW50KTtcbiAgICAgICAgICBlbWl0RXJyb3Ioc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgeyB1c2VyLCBtZXRob2QsIGFzeW5jIH0gPSBfcmVxdWVzdDtcbiAgICAvLyBvcGVuIFhIUlxuICAgIGlmICh1c2VyKSB7XG4gICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIF9yZXF1ZXN0LnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIGFzeW5jKTtcbiAgICB9XG5cbiAgICAvLyB0aW1lb3V0LCByZXNwb25zZVR5cGUgYW5kIHdpdGhDcmVkZW50aWFscyBjYW4gYmUgc2V0IG9uY2UgdGhlIFhIUiBpcyBvcGVuXG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICB4aHIudGltZW91dCA9IF9yZXF1ZXN0LnRpbWVvdXQ7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gX3JlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBfcmVxdWVzdC53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gc2V0IGhlYWRlcnNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICBpZiAoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5hbGx5IHNlbmQgdGhlIHJlcXVlc3RcbiAgICBpZiAoYm9keSkge1xuICAgICAgeGhyLnNlbmQoYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh4aHIgJiYgeGhyLnJlYWR5U3RhdGUgIT09IDQgLypYSFIgZG9uZSovKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIEV4YW1pbmVzIHRoZSBib2R5IHRvIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIHNlcmlhbGl6ZSBpdCBmb3IgdGhlbSBvciBub3QuXG4gKiBJZiB0aGUgYm9keSBpcyBhIHR5cGUgdGhhdCBYSFIgaGFuZGxlcyBuYXRpdmVseSwgd2UganVzdCBhbGxvdyBpdCB0aHJvdWdoLFxuICogb3RoZXJ3aXNlLCBpZiB0aGUgYm9keSBpcyBzb21ldGhpbmcgdGhhdCAqd2UqIGNhbiBzZXJpYWxpemUgZm9yIHRoZSB1c2VyLFxuICogd2Ugd2lsbCBzZXJpYWxpemUgaXQsIGFuZCBhdHRlbXB0IHRvIHNldCB0aGUgYGNvbnRlbnQtdHlwZWAgaGVhZGVyLCBpZiBpdCdzXG4gKiBub3QgYWxyZWFkeSBzZXQuXG4gKiBAcGFyYW0gYm9keSBUaGUgYm9keSBwYXNzZWQgaW4gYnkgdGhlIHVzZXJcbiAqIEBwYXJhbSBoZWFkZXJzIFRoZSBub3JtYWxpemVkIGhlYWRlcnNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbnRlbnRUeXBlQW5kTWF5YmVTZXJpYWxpemVCb2R5KGJvZHk6IGFueSwgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBpZiAoXG4gICAgIWJvZHkgfHxcbiAgICB0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycgfHxcbiAgICBpc0Zvcm1EYXRhKGJvZHkpIHx8XG4gICAgaXNVUkxTZWFyY2hQYXJhbXMoYm9keSkgfHxcbiAgICBpc0FycmF5QnVmZmVyKGJvZHkpIHx8XG4gICAgaXNGaWxlKGJvZHkpIHx8XG4gICAgaXNCbG9iKGJvZHkpIHx8XG4gICAgaXNSZWFkYWJsZVN0cmVhbShib2R5KVxuICApIHtcbiAgICAvLyBUaGUgWEhSIGluc3RhbmNlIGl0c2VsZiBjYW4gaGFuZGxlIHNlcmlhbGl6aW5nIHRoZXNlLCBhbmQgc2V0IHRoZSBjb250ZW50LXR5cGUgZm9yIHVzXG4gICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBkbyB0aGF0LiBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI3RoZS1zZW5kKCktbWV0aG9kXG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpIHtcbiAgICAvLyBUaGlzIGlzIGEgdHlwZWQgYXJyYXkgKGUuZy4gRmxvYXQzMkFycmF5IG9yIFVpbnQ4QXJyYXkpLCBvciBhIERhdGFWaWV3LlxuICAgIC8vIFhIUiBjYW4gaGFuZGxlIHRoaXMgb25lIHRvbzogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuICAgIHJldHVybiBib2R5LmJ1ZmZlcjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYm9keSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG1hZGUgaXQgaGVyZSwgdGhpcyBpcyBhbiBvYmplY3QsIHByb2JhYmx5IGEgUE9KTywgYW5kIHdlJ2xsIHRyeVxuICAgIC8vIHRvIHNlcmlhbGl6ZSBpdCBmb3IgdGhlbS4gSWYgdGhpcyBkb2Vzbid0IHdvcmssIGl0IHdpbGwgdGhyb3csIG9idmlvdXNseSwgd2hpY2hcbiAgICAvLyBpcyBva2F5LiBUaGUgd29ya2Fyb3VuZCBmb3IgdXNlcnMgd291bGQgYmUgdG8gbWFudWFsbHkgc2V0IHRoZSBib2R5IHRvIHRoZWlyIG93blxuICAgIC8vIHNlcmlhbGl6ZWQgc3RyaW5nIChhY2NvdW50aW5nIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIG9yIHdoYXRldmVyKSwgdGhlbiBzZXRcbiAgICAvLyB0aGUgY29udGVudC10eXBlIG1hbnVhbGx5IGFzIHdlbGwuXG4gICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA/PyAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04JztcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gIH1cblxuICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gcGFzdCBldmVyeXRoaW5nIGFib3ZlLCB0aGlzIGlzIHNvbWV0aGluZyB3ZSBkb24ndCBxdWl0ZSBrbm93IGhvdyB0b1xuICAvLyBoYW5kbGUuIFRocm93IGFuIGVycm9yLiBUaGlzIHdpbGwgYmUgY2F1Z2h0IGFuZCBlbWl0dGVkIGZyb20gdGhlIG9ic2VydmFibGUuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gYm9keSB0eXBlJyk7XG59XG5cbmNvbnN0IF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvU3RyaW5nQ2hlY2sob2JqOiBhbnksIG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gYFtvYmplY3QgJHtuYW1lfV1gO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKGJvZHk6IGFueSk6IGJvZHkgaXMgQXJyYXlCdWZmZXIge1xuICByZXR1cm4gdG9TdHJpbmdDaGVjayhib2R5LCAnQXJyYXlCdWZmZXInKTtcbn1cblxuZnVuY3Rpb24gaXNGaWxlKGJvZHk6IGFueSk6IGJvZHkgaXMgRmlsZSB7XG4gIHJldHVybiB0b1N0cmluZ0NoZWNrKGJvZHksICdGaWxlJyk7XG59XG5cbmZ1bmN0aW9uIGlzQmxvYihib2R5OiBhbnkpOiBib2R5IGlzIEJsb2Ige1xuICByZXR1cm4gdG9TdHJpbmdDaGVjayhib2R5LCAnQmxvYicpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyhib2R5OiBhbnkpOiBib2R5IGlzIEFycmF5QnVmZmVyVmlldyB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldyhib2R5KTtcbn1cblxuZnVuY3Rpb24gaXNGb3JtRGF0YShib2R5OiBhbnkpOiBib2R5IGlzIEZvcm1EYXRhIHtcbiAgcmV0dXJuIHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhO1xufVxuXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyhib2R5OiBhbnkpOiBib2R5IGlzIFVSTFNlYXJjaFBhcmFtcyB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiBib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG5mdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKGJvZHk6IGFueSk6IGJvZHkgaXMgUmVhZGFibGVTdHJlYW0ge1xuICByZXR1cm4gdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJyAmJiBib2R5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG59XG4iXX0=
