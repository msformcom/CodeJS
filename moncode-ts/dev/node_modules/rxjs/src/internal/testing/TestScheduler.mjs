import { Observable } from '../Observable.mjs';
import { ColdObservable } from './ColdObservable.mjs';
import { HotObservable } from './HotObservable.mjs';
import { SubscriptionLog } from './SubscriptionLog.mjs';
import { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler.mjs';
import { COMPLETE_NOTIFICATION, errorNotification, nextNotification } from '../NotificationFactories.mjs';
import { dateTimestampProvider } from '../scheduler/dateTimestampProvider.mjs';
import { performanceTimestampProvider } from '../scheduler/performanceTimestampProvider.mjs';
import { animationFrameProvider } from '../scheduler/animationFrameProvider.mjs';
import { immediateProvider } from '../scheduler/immediateProvider.mjs';
import { intervalProvider } from '../scheduler/intervalProvider.mjs';
import { timeoutProvider } from '../scheduler/timeoutProvider.mjs';
const defaultMaxFrame = 750;
export class TestScheduler extends VirtualTimeScheduler {
    /**
     *
     * @param assertDeepEqual A function to set up your assertion for your test harness
     */
    constructor(assertDeepEqual) {
        super(VirtualAction, defaultMaxFrame);
        this.assertDeepEqual = assertDeepEqual;
        /**
         * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.
         */
        this.hotObservables = [];
        /**
         * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.
         */
        this.coldObservables = [];
        /**
         * Test meta data to be processed during `flush()`
         */
        this.flushTests = [];
        /**
         * Indicates whether the TestScheduler instance is operating in "run mode",
         * meaning it's processing a call to `run()`
         */
        this.runMode = false;
    }
    createTime(marbles) {
        const indexOf = this.runMode ? marbles.trim().indexOf('|') : marbles.indexOf('|');
        if (indexOf === -1) {
            throw new Error('marble diagram for time should have a completion marker "|"');
        }
        return indexOf * TestScheduler.frameTimeFactor;
    }
    /**
     * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.
     * @param values Values to use for the letters in `marbles`. If omitted, the letters themselves are used.
     * @param error The error to use for the `#` marble (if present).
     */
    createColdObservable(marbles, values, error) {
        if (marbles.indexOf('^') !== -1) {
            throw new Error('cold observable cannot have subscription offset "^"');
        }
        if (marbles.indexOf('!') !== -1) {
            throw new Error('cold observable cannot have unsubscription marker "!"');
        }
        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
        const cold = new ColdObservable(messages, this);
        this.coldObservables.push(cold);
        return cold;
    }
    /**
     * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.
     * @param values Values to use for the letters in `marbles`. If omitted, the letters themselves are used.
     * @param error The error to use for the `#` marble (if present).
     */
    createHotObservable(marbles, values, error) {
        if (marbles.indexOf('!') !== -1) {
            throw new Error('hot observable cannot have unsubscription marker "!"');
        }
        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
        const subject = new HotObservable(messages, this);
        this.hotObservables.push(subject);
        return subject;
    }
    materializeInnerObservable(observable, outerFrame) {
        const messages = [];
        observable.subscribe({
            next: (value) => {
                messages.push({ frame: this.frame - outerFrame, notification: nextNotification(value) });
            },
            error: (error) => {
                messages.push({ frame: this.frame - outerFrame, notification: errorNotification(error) });
            },
            complete: () => {
                messages.push({ frame: this.frame - outerFrame, notification: COMPLETE_NOTIFICATION });
            },
        });
        return messages;
    }
    expectObservable(observable, subscriptionMarbles = null) {
        const actual = [];
        const flushTest = { actual, ready: false };
        const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);
        const subscriptionFrame = subscriptionParsed.subscribedFrame === Infinity ? 0 : subscriptionParsed.subscribedFrame;
        const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;
        let subscription;
        this.schedule(() => {
            subscription = observable.subscribe({
                next: (x) => {
                    // Support Observable-of-Observables
                    const value = x instanceof Observable ? this.materializeInnerObservable(x, this.frame) : x;
                    actual.push({ frame: this.frame, notification: nextNotification(value) });
                },
                error: (error) => {
                    actual.push({ frame: this.frame, notification: errorNotification(error) });
                },
                complete: () => {
                    actual.push({ frame: this.frame, notification: COMPLETE_NOTIFICATION });
                },
            });
        }, subscriptionFrame);
        if (unsubscriptionFrame !== Infinity) {
            this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);
        }
        this.flushTests.push(flushTest);
        const { runMode } = this;
        return {
            toBe(marbles, values, errorValue) {
                flushTest.ready = true;
                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);
            },
            toEqual: (other) => {
                flushTest.ready = true;
                flushTest.expected = [];
                this.schedule(() => {
                    subscription = other.subscribe({
                        next: (x) => {
                            // Support Observable-of-Observables
                            const value = x instanceof Observable ? this.materializeInnerObservable(x, this.frame) : x;
                            flushTest.expected.push({ frame: this.frame, notification: nextNotification(value) });
                        },
                        error: (error) => {
                            flushTest.expected.push({ frame: this.frame, notification: errorNotification(error) });
                        },
                        complete: () => {
                            flushTest.expected.push({ frame: this.frame, notification: COMPLETE_NOTIFICATION });
                        },
                    });
                }, subscriptionFrame);
            },
        };
    }
    expectSubscriptions(actualSubscriptionLogs) {
        const flushTest = { actual: actualSubscriptionLogs, ready: false };
        this.flushTests.push(flushTest);
        const { runMode } = this;
        return {
            toBe(marblesOrMarblesArray) {
                const marblesArray = typeof marblesOrMarblesArray === 'string' ? [marblesOrMarblesArray] : marblesOrMarblesArray;
                flushTest.ready = true;
                flushTest.expected = marblesArray
                    .map((marbles) => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode))
                    .filter((marbles) => marbles.subscribedFrame !== Infinity);
            },
        };
    }
    flush() {
        const hotObservables = this.hotObservables;
        while (hotObservables.length > 0) {
            hotObservables.shift().setup();
        }
        super.flush();
        this.flushTests = this.flushTests.filter((test) => {
            if (test.ready) {
                this.assertDeepEqual(test.actual, test.expected);
                return false;
            }
            return true;
        });
    }
    /** @nocollapse */
    static parseMarblesAsSubscriptions(marbles, runMode = false) {
        if (typeof marbles !== 'string') {
            return new SubscriptionLog(Infinity);
        }
        // Spreading the marbles into an array leverages ES2015's support for emoji
        // characters when iterating strings.
        const characters = [...marbles];
        const len = characters.length;
        let groupStart = -1;
        let subscriptionFrame = Infinity;
        let unsubscriptionFrame = Infinity;
        let frame = 0;
        for (let i = 0; i < len; i++) {
            let nextFrame = frame;
            const advanceFrameBy = (count) => {
                nextFrame += count * this.frameTimeFactor;
            };
            const c = characters[i];
            switch (c) {
                case ' ':
                    // Whitespace no longer advances time
                    if (!runMode) {
                        advanceFrameBy(1);
                    }
                    break;
                case '-':
                    advanceFrameBy(1);
                    break;
                case '(':
                    groupStart = frame;
                    advanceFrameBy(1);
                    break;
                case ')':
                    groupStart = -1;
                    advanceFrameBy(1);
                    break;
                case '^':
                    if (subscriptionFrame !== Infinity) {
                        throw new Error("found a second subscription point '^' in a " + 'subscription marble diagram. There can only be one.');
                    }
                    subscriptionFrame = groupStart > -1 ? groupStart : frame;
                    advanceFrameBy(1);
                    break;
                case '!':
                    if (unsubscriptionFrame !== Infinity) {
                        throw new Error("found a second unsubscription point '!' in a " + 'subscription marble diagram. There can only be one.');
                    }
                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                    break;
                default:
                    // time progression syntax
                    if (runMode && c.match(/^[0-9]$/)) {
                        // Time progression must be preceded by at least one space
                        // if it's not at the beginning of the diagram
                        if (i === 0 || characters[i - 1] === ' ') {
                            const buffer = characters.slice(i).join('');
                            const match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                            if (match) {
                                i += match[0].length - 1;
                                const duration = parseFloat(match[1]);
                                const unit = match[2];
                                let durationInMs;
                                switch (unit) {
                                    case 'ms':
                                        durationInMs = duration;
                                        break;
                                    case 's':
                                        durationInMs = duration * 1000;
                                        break;
                                    case 'm':
                                        durationInMs = duration * 1000 * 60;
                                        break;
                                    default:
                                        break;
                                }
                                advanceFrameBy(durationInMs / this.frameTimeFactor);
                                break;
                            }
                        }
                    }
                    throw new Error("there can only be '^' and '!' markers in a " + "subscription marble diagram. Found instead '" + c + "'.");
            }
            frame = nextFrame;
        }
        if (unsubscriptionFrame < 0) {
            return new SubscriptionLog(subscriptionFrame);
        }
        else {
            return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
        }
    }
    /** @nocollapse */
    static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false, runMode = false) {
        if (marbles.indexOf('!') !== -1) {
            throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker "!"');
        }
        // Spreading the marbles into an array leverages ES2015's support for emoji
        // characters when iterating strings.
        const characters = [...marbles];
        const len = characters.length;
        const testMessages = [];
        const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');
        let frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;
        const getValue = typeof values !== 'object'
            ? (x) => x
            : (x) => {
                // Support Observable-of-Observables
                if (materializeInnerObservables && values[x] instanceof ColdObservable) {
                    return values[x].messages;
                }
                return values[x];
            };
        let groupStart = -1;
        for (let i = 0; i < len; i++) {
            let nextFrame = frame;
            const advanceFrameBy = (count) => {
                nextFrame += count * this.frameTimeFactor;
            };
            let notification;
            const c = characters[i];
            switch (c) {
                case ' ':
                    // Whitespace no longer advances time
                    if (!runMode) {
                        advanceFrameBy(1);
                    }
                    break;
                case '-':
                    advanceFrameBy(1);
                    break;
                case '(':
                    groupStart = frame;
                    advanceFrameBy(1);
                    break;
                case ')':
                    groupStart = -1;
                    advanceFrameBy(1);
                    break;
                case '|':
                    notification = COMPLETE_NOTIFICATION;
                    advanceFrameBy(1);
                    break;
                case '^':
                    advanceFrameBy(1);
                    break;
                case '#':
                    notification = errorNotification(errorValue || 'error');
                    advanceFrameBy(1);
                    break;
                default:
                    // Might be time progression syntax, or a value literal
                    if (runMode && c.match(/^[0-9]$/)) {
                        // Time progression must be preceded by at least one space
                        // if it's not at the beginning of the diagram
                        if (i === 0 || characters[i - 1] === ' ') {
                            const buffer = characters.slice(i).join('');
                            const match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                            if (match) {
                                i += match[0].length - 1;
                                const duration = parseFloat(match[1]);
                                const unit = match[2];
                                let durationInMs;
                                switch (unit) {
                                    case 'ms':
                                        durationInMs = duration;
                                        break;
                                    case 's':
                                        durationInMs = duration * 1000;
                                        break;
                                    case 'm':
                                        durationInMs = duration * 1000 * 60;
                                        break;
                                    default:
                                        break;
                                }
                                advanceFrameBy(durationInMs / this.frameTimeFactor);
                                break;
                            }
                        }
                    }
                    notification = nextNotification(getValue(c));
                    advanceFrameBy(1);
                    break;
            }
            if (notification) {
                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification });
            }
            frame = nextFrame;
        }
        return testMessages;
    }
    createAnimator() {
        if (!this.runMode) {
            throw new Error('animate() must only be used in run mode');
        }
        // The TestScheduler assigns a delegate to the provider that's used for
        // requestAnimationFrame (rAF). The delegate works in conjunction with the
        // animate run helper to coordinate the invocation of any rAF callbacks,
        // that are effected within tests, with the animation frames specified by
        // the test's author - in the marbles that are passed to the animate run
        // helper. This allows the test's author to write deterministic tests and
        // gives the author full control over when - or if - animation frames are
        // 'painted'.
        let lastHandle = 0;
        let map;
        const delegate = {
            requestAnimationFrame(callback) {
                if (!map) {
                    throw new Error('animate() was not called within run()');
                }
                const handle = ++lastHandle;
                map.set(handle, callback);
                return handle;
            },
            cancelAnimationFrame(handle) {
                if (!map) {
                    throw new Error('animate() was not called within run()');
                }
                map.delete(handle);
            },
        };
        const animate = (marbles) => {
            if (map) {
                throw new Error('animate() must not be called more than once within run()');
            }
            if (/[|#]/.test(marbles)) {
                throw new Error('animate() must not complete or error');
            }
            map = new Map();
            const messages = TestScheduler.parseMarbles(marbles, undefined, undefined, undefined, true);
            for (const message of messages) {
                this.schedule(() => {
                    const now = this.now();
                    // Capture the callbacks within the queue and clear the queue
                    // before enumerating the callbacks, as callbacks might
                    // reschedule themselves. (And, yeah, we're using a Map to represent
                    // the queue, but the values are guaranteed to be returned in
                    // insertion order, so it's all good. Trust me, I've read the docs.)
                    const callbacks = Array.from(map.values());
                    map.clear();
                    for (const callback of callbacks) {
                        callback(now);
                    }
                }, message.frame);
            }
        };
        return { animate, delegate };
    }
    createDelegates() {
        // When in run mode, the TestScheduler provides alternate implementations
        // of set/clearImmediate and set/clearInterval. These implementations are
        // consumed by the scheduler implementations via the providers. This is
        // done to effect deterministic asap and async scheduler behavior so that
        // all of the schedulers are testable in 'run mode'. Prior to v7,
        // delegation occurred at the scheduler level. That is, the asap and
        // animation frame schedulers were identical in behavior to the async
        // scheduler. Now, when in run mode, asap actions are prioritized over
        // async actions and animation frame actions are coordinated using the
        // animate run helper.
        let lastHandle = 0;
        const scheduleLookup = new Map();
        const run = () => {
            // Whenever a scheduled run is executed, it must run a single immediate
            // or interval action - with immediate actions being prioritized over
            // interval and timeout actions.
            const now = this.now();
            const scheduledRecords = Array.from(scheduleLookup.values());
            const scheduledRecordsDue = scheduledRecords.filter(({ due }) => due <= now);
            const dueImmediates = scheduledRecordsDue.filter(({ type }) => type === 'immediate');
            if (dueImmediates.length > 0) {
                const { handle, handler } = dueImmediates[0];
                scheduleLookup.delete(handle);
                handler();
                return;
            }
            const dueIntervals = scheduledRecordsDue.filter(({ type }) => type === 'interval');
            if (dueIntervals.length > 0) {
                const firstDueInterval = dueIntervals[0];
                const { duration, handler } = firstDueInterval;
                firstDueInterval.due = now + duration;
                // The interval delegate must behave like setInterval, so run needs to
                // be rescheduled. This will continue until the clearInterval delegate
                // unsubscribes and deletes the handle from the map.
                firstDueInterval.subscription = this.schedule(run, duration);
                handler();
                return;
            }
            const dueTimeouts = scheduledRecordsDue.filter(({ type }) => type === 'timeout');
            if (dueTimeouts.length > 0) {
                const { handle, handler } = dueTimeouts[0];
                scheduleLookup.delete(handle);
                handler();
                return;
            }
            throw new Error('Expected a due immediate or interval');
        };
        // The following objects are the delegates that replace conventional
        // runtime implementations with TestScheduler implementations.
        //
        // The immediate delegate is depended upon by the asapScheduler.
        //
        // The interval delegate is depended upon by the asyncScheduler.
        //
        // The timeout delegate is not depended upon by any scheduler, but it's
        // included here because the onUnhandledError and onStoppedNotification
        // configuration points use setTimeout to avoid producer interference. It's
        // inclusion allows for the testing of these configuration points.
        const immediate = {
            setImmediate: (handler) => {
                const handle = ++lastHandle;
                scheduleLookup.set(handle, {
                    due: this.now(),
                    duration: 0,
                    handle,
                    handler,
                    subscription: this.schedule(run, 0),
                    type: 'immediate',
                });
                return handle;
            },
            clearImmediate: (handle) => {
                const value = scheduleLookup.get(handle);
                if (value) {
                    value.subscription.unsubscribe();
                    scheduleLookup.delete(handle);
                }
            },
        };
        const interval = {
            setInterval: (handler, duration = 0) => {
                const handle = ++lastHandle;
                scheduleLookup.set(handle, {
                    due: this.now() + duration,
                    duration,
                    handle,
                    handler,
                    subscription: this.schedule(run, duration),
                    type: 'interval',
                });
                return handle;
            },
            clearInterval: (handle) => {
                const value = scheduleLookup.get(handle);
                if (value) {
                    value.subscription.unsubscribe();
                    scheduleLookup.delete(handle);
                }
            },
        };
        const timeout = {
            setTimeout: (handler, duration = 0) => {
                const handle = ++lastHandle;
                scheduleLookup.set(handle, {
                    due: this.now() + duration,
                    duration,
                    handle,
                    handler,
                    subscription: this.schedule(run, duration),
                    type: 'timeout',
                });
                return handle;
            },
            clearTimeout: (handle) => {
                const value = scheduleLookup.get(handle);
                if (value) {
                    value.subscription.unsubscribe();
                    scheduleLookup.delete(handle);
                }
            },
        };
        return { immediate, interval, timeout };
    }
    /**
     * The `run` method performs the test in 'run mode' - in which schedulers
     * used within the test automatically delegate to the `TestScheduler`. That
     * is, in 'run mode' there is no need to explicitly pass a `TestScheduler`
     * instance to observable creators or operators.
     *
     * @see {@link /guide/testing/marble-testing}
     */
    run(callback) {
        const prevFrameTimeFactor = TestScheduler.frameTimeFactor;
        const prevMaxFrames = this.maxFrames;
        TestScheduler.frameTimeFactor = 1;
        this.maxFrames = Infinity;
        this.runMode = true;
        const animator = this.createAnimator();
        const delegates = this.createDelegates();
        animationFrameProvider.delegate = animator.delegate;
        dateTimestampProvider.delegate = this;
        immediateProvider.delegate = delegates.immediate;
        intervalProvider.delegate = delegates.interval;
        timeoutProvider.delegate = delegates.timeout;
        performanceTimestampProvider.delegate = this;
        const helpers = {
            cold: this.createColdObservable.bind(this),
            hot: this.createHotObservable.bind(this),
            flush: this.flush.bind(this),
            time: this.createTime.bind(this),
            expectObservable: this.expectObservable.bind(this),
            expectSubscriptions: this.expectSubscriptions.bind(this),
            animate: animator.animate,
        };
        try {
            const ret = callback(helpers);
            this.flush();
            return ret;
        }
        finally {
            TestScheduler.frameTimeFactor = prevFrameTimeFactor;
            this.maxFrames = prevMaxFrames;
            this.runMode = false;
            animationFrameProvider.delegate = undefined;
            dateTimestampProvider.delegate = undefined;
            immediateProvider.delegate = undefined;
            intervalProvider.delegate = undefined;
            timeoutProvider.delegate = undefined;
            performanceTimestampProvider.delegate = undefined;
        }
    }
}
/**
 * The number of virtual time units each character in a marble diagram represents. If
 * the test scheduler is being used in "run mode", via the `run` method, this is temporarily
 * set to `1` for the duration of the `run` block, then set back to whatever value it was.
 * @nocollapse
 */
TestScheduler.frameTimeFactor = 10;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC90ZXN0aW5nL1Rlc3RTY2hlZHVsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRWhELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUVwRCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFFeEYsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDdEcsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDM0UsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDekYsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFN0UsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDbkUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDakUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBRS9ELE1BQU0sZUFBZSxHQUFXLEdBQUcsQ0FBQztBQXFCcEMsTUFBTSxPQUFPLGFBQWMsU0FBUSxvQkFBb0I7SUE4QnJEOzs7T0FHRztJQUNILFlBQW1CLGVBQStEO1FBQ2hGLEtBQUssQ0FBQyxhQUFhLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFEckIsb0JBQWUsR0FBZixlQUFlLENBQWdEO1FBekJsRjs7V0FFRztRQUNhLG1CQUFjLEdBQXlCLEVBQUUsQ0FBQztRQUUxRDs7V0FFRztRQUNhLG9CQUFlLEdBQTBC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LENBQUM7WUFDeEMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUM1QixJQUFJLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2hDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2xELG1CQUFtQixFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3hELE9BQU8sRUFBRSxRQUFRLENBQUMsT0FBTztTQUMxQixDQUFDO1FBQ0YsSUFBSSxDQUFDO1lBQ0gsTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNiLE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQztnQkFBUyxDQUFDO1lBQ1QsYUFBYSxDQUFDLGVBQWUsR0FBRyxtQkFBbUIsQ0FBQztZQUNwRCxJQUFJLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQztZQUMvQixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztZQUNyQixzQkFBc0IsQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO1lBQzVDLHFCQUFxQixDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7WUFDM0MsaUJBQWlCLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQztZQUN2QyxnQkFBZ0IsQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO1lBQ3RDLGVBQWUsQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO1lBQ3JDLDRCQUE0QixDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7UUFDcEQsQ0FBQztJQUNILENBQUM7O0FBNW9CRDs7Ozs7R0FLRztBQUNJLDZCQUFlLEdBQUcsRUFBSCxBQUFLLENBQUMiLCJmaWxlIjoibm9kZV9tb2R1bGVzL3J4anMvc3JjL2ludGVybmFsL3Rlc3RpbmcvVGVzdFNjaGVkdWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IENvbGRPYnNlcnZhYmxlIH0gZnJvbSAnLi9Db2xkT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBIb3RPYnNlcnZhYmxlIH0gZnJvbSAnLi9Ib3RPYnNlcnZhYmxlJztcbmltcG9ydCB7IFRlc3RNZXNzYWdlIH0gZnJvbSAnLi9UZXN0TWVzc2FnZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25Mb2cgfSBmcm9tICcuL1N1YnNjcmlwdGlvbkxvZyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgVmlydHVhbFRpbWVTY2hlZHVsZXIsIFZpcnR1YWxBY3Rpb24gfSBmcm9tICcuLi9zY2hlZHVsZXIvVmlydHVhbFRpbWVTY2hlZHVsZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZU5vdGlmaWNhdGlvbiB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IENPTVBMRVRFX05PVElGSUNBVElPTiwgZXJyb3JOb3RpZmljYXRpb24sIG5leHROb3RpZmljYXRpb24gfSBmcm9tICcuLi9Ob3RpZmljYXRpb25GYWN0b3JpZXMnO1xuaW1wb3J0IHsgZGF0ZVRpbWVzdGFtcFByb3ZpZGVyIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2RhdGVUaW1lc3RhbXBQcm92aWRlcic7XG5pbXBvcnQgeyBwZXJmb3JtYW5jZVRpbWVzdGFtcFByb3ZpZGVyIH0gZnJvbSAnLi4vc2NoZWR1bGVyL3BlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXInO1xuaW1wb3J0IHsgYW5pbWF0aW9uRnJhbWVQcm92aWRlciB9IGZyb20gJy4uL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZVByb3ZpZGVyJztcbmltcG9ydCB0eXBlIHsgVGltZXJIYW5kbGUgfSBmcm9tICcuLi9zY2hlZHVsZXIvdGltZXJIYW5kbGUnO1xuaW1wb3J0IHsgaW1tZWRpYXRlUHJvdmlkZXIgfSBmcm9tICcuLi9zY2hlZHVsZXIvaW1tZWRpYXRlUHJvdmlkZXInO1xuaW1wb3J0IHsgaW50ZXJ2YWxQcm92aWRlciB9IGZyb20gJy4uL3NjaGVkdWxlci9pbnRlcnZhbFByb3ZpZGVyJztcbmltcG9ydCB7IHRpbWVvdXRQcm92aWRlciB9IGZyb20gJy4uL3NjaGVkdWxlci90aW1lb3V0UHJvdmlkZXInO1xuXG5jb25zdCBkZWZhdWx0TWF4RnJhbWU6IG51bWJlciA9IDc1MDtcblxuZXhwb3J0IGludGVyZmFjZSBSdW5IZWxwZXJzIHtcbiAgY29sZDogdHlwZW9mIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmNyZWF0ZUNvbGRPYnNlcnZhYmxlO1xuICBob3Q6IHR5cGVvZiBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVIb3RPYnNlcnZhYmxlO1xuICBmbHVzaDogdHlwZW9mIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoO1xuICB0aW1lOiB0eXBlb2YgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuY3JlYXRlVGltZTtcbiAgZXhwZWN0T2JzZXJ2YWJsZTogdHlwZW9mIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmV4cGVjdE9ic2VydmFibGU7XG4gIGV4cGVjdFN1YnNjcmlwdGlvbnM6IHR5cGVvZiBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5leHBlY3RTdWJzY3JpcHRpb25zO1xuICBhbmltYXRlOiAobWFyYmxlczogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgRmx1c2hhYmxlVGVzdCB7XG4gIHJlYWR5OiBib29sZWFuO1xuICBhY3R1YWw/OiBhbnlbXTtcbiAgZXhwZWN0ZWQ/OiBhbnlbXTtcbn1cblxuZXhwb3J0IHR5cGUgb2JzZXJ2YWJsZVRvQmVGbiA9IChtYXJibGVzOiBzdHJpbmcsIHZhbHVlcz86IGFueSwgZXJyb3JWYWx1ZT86IGFueSkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIHN1YnNjcmlwdGlvbkxvZ3NUb0JlRm4gPSAobWFyYmxlczogc3RyaW5nIHwgc3RyaW5nW10pID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBUZXN0U2NoZWR1bGVyIGV4dGVuZHMgVmlydHVhbFRpbWVTY2hlZHVsZXIge1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiB2aXJ0dWFsIHRpbWUgdW5pdHMgZWFjaCBjaGFyYWN0ZXIgaW4gYSBtYXJibGUgZGlhZ3JhbSByZXByZXNlbnRzLiBJZlxuICAgKiB0aGUgdGVzdCBzY2hlZHVsZXIgaXMgYmVpbmcgdXNlZCBpbiBcInJ1biBtb2RlXCIsIHZpYSB0aGUgYHJ1bmAgbWV0aG9kLCB0aGlzIGlzIHRlbXBvcmFyaWx5XG4gICAqIHNldCB0byBgMWAgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYHJ1bmAgYmxvY2ssIHRoZW4gc2V0IGJhY2sgdG8gd2hhdGV2ZXIgdmFsdWUgaXQgd2FzLlxuICAgKiBAbm9jb2xsYXBzZVxuICAgKi9cbiAgc3RhdGljIGZyYW1lVGltZUZhY3RvciA9IDEwO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGRvIG5vdCB1c2UgZGlyZWN0bHkuIFdpbGwgYmUgbWFkZSBpbnRlcm5hbCBpbiB2OC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBob3RPYnNlcnZhYmxlczogSG90T2JzZXJ2YWJsZTxhbnk+W10gPSBbXTtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gZGV0YWlsLCBkbyBub3QgdXNlIGRpcmVjdGx5LiBXaWxsIGJlIG1hZGUgaW50ZXJuYWwgaW4gdjguXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY29sZE9ic2VydmFibGVzOiBDb2xkT2JzZXJ2YWJsZTxhbnk+W10gPSBbXTtcblxuICAvKipcbiAgICogVGVzdCBtZXRhIGRhdGEgdG8gYmUgcHJvY2Vzc2VkIGR1cmluZyBgZmx1c2goKWBcbiAgICovXG4gIHByaXZhdGUgZmx1c2hUZXN0czogRmx1c2hhYmxlVGVzdFtdID0gW107XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBUZXN0U2NoZWR1bGVyIGluc3RhbmNlIGlzIG9wZXJhdGluZyBpbiBcInJ1biBtb2RlXCIsXG4gICAqIG1lYW5pbmcgaXQncyBwcm9jZXNzaW5nIGEgY2FsbCB0byBgcnVuKClgXG4gICAqL1xuICBwcml2YXRlIHJ1bk1vZGUgPSBmYWxzZTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGFzc2VydERlZXBFcXVhbCBBIGZ1bmN0aW9uIHRvIHNldCB1cCB5b3VyIGFzc2VydGlvbiBmb3IgeW91ciB0ZXN0IGhhcm5lc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBhc3NlcnREZWVwRXF1YWw6IChhY3R1YWw6IGFueSwgZXhwZWN0ZWQ6IGFueSkgPT4gYm9vbGVhbiB8IHZvaWQpIHtcbiAgICBzdXBlcihWaXJ0dWFsQWN0aW9uLCBkZWZhdWx0TWF4RnJhbWUpO1xuICB9XG5cbiAgY3JlYXRlVGltZShtYXJibGVzOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGluZGV4T2YgPSB0aGlzLnJ1bk1vZGUgPyBtYXJibGVzLnRyaW0oKS5pbmRleE9mKCd8JykgOiBtYXJibGVzLmluZGV4T2YoJ3wnKTtcbiAgICBpZiAoaW5kZXhPZiA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFyYmxlIGRpYWdyYW0gZm9yIHRpbWUgc2hvdWxkIGhhdmUgYSBjb21wbGV0aW9uIG1hcmtlciBcInxcIicpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXhPZiAqIFRlc3RTY2hlZHVsZXIuZnJhbWVUaW1lRmFjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBtYXJibGVzIEEgZGlhZ3JhbSBpbiB0aGUgbWFyYmxlIERTTC4gTGV0dGVycyBtYXAgdG8ga2V5cyBpbiBgdmFsdWVzYCBpZiBwcm92aWRlZC5cbiAgICogQHBhcmFtIHZhbHVlcyBWYWx1ZXMgdG8gdXNlIGZvciB0aGUgbGV0dGVycyBpbiBgbWFyYmxlc2AuIElmIG9taXR0ZWQsIHRoZSBsZXR0ZXJzIHRoZW1zZWx2ZXMgYXJlIHVzZWQuXG4gICAqIEBwYXJhbSBlcnJvciBUaGUgZXJyb3IgdG8gdXNlIGZvciB0aGUgYCNgIG1hcmJsZSAoaWYgcHJlc2VudCkuXG4gICAqL1xuICBjcmVhdGVDb2xkT2JzZXJ2YWJsZTxUID0gc3RyaW5nPihtYXJibGVzOiBzdHJpbmcsIHZhbHVlcz86IHsgW21hcmJsZTogc3RyaW5nXTogVCB9LCBlcnJvcj86IGFueSk6IENvbGRPYnNlcnZhYmxlPFQ+IHtcbiAgICBpZiAobWFyYmxlcy5pbmRleE9mKCdeJykgIT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbGQgb2JzZXJ2YWJsZSBjYW5ub3QgaGF2ZSBzdWJzY3JpcHRpb24gb2Zmc2V0IFwiXlwiJyk7XG4gICAgfVxuICAgIGlmIChtYXJibGVzLmluZGV4T2YoJyEnKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29sZCBvYnNlcnZhYmxlIGNhbm5vdCBoYXZlIHVuc3Vic2NyaXB0aW9uIG1hcmtlciBcIiFcIicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzKG1hcmJsZXMsIHZhbHVlcywgZXJyb3IsIHVuZGVmaW5lZCwgdGhpcy5ydW5Nb2RlKTtcbiAgICBjb25zdCBjb2xkID0gbmV3IENvbGRPYnNlcnZhYmxlPFQ+KG1lc3NhZ2VzLCB0aGlzKTtcbiAgICB0aGlzLmNvbGRPYnNlcnZhYmxlcy5wdXNoKGNvbGQpO1xuICAgIHJldHVybiBjb2xkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBtYXJibGVzIEEgZGlhZ3JhbSBpbiB0aGUgbWFyYmxlIERTTC4gTGV0dGVycyBtYXAgdG8ga2V5cyBpbiBgdmFsdWVzYCBpZiBwcm92aWRlZC5cbiAgICogQHBhcmFtIHZhbHVlcyBWYWx1ZXMgdG8gdXNlIGZvciB0aGUgbGV0dGVycyBpbiBgbWFyYmxlc2AuIElmIG9taXR0ZWQsIHRoZSBsZXR0ZXJzIHRoZW1zZWx2ZXMgYXJlIHVzZWQuXG4gICAqIEBwYXJhbSBlcnJvciBUaGUgZXJyb3IgdG8gdXNlIGZvciB0aGUgYCNgIG1hcmJsZSAoaWYgcHJlc2VudCkuXG4gICAqL1xuICBjcmVhdGVIb3RPYnNlcnZhYmxlPFQgPSBzdHJpbmc+KG1hcmJsZXM6IHN0cmluZywgdmFsdWVzPzogeyBbbWFyYmxlOiBzdHJpbmddOiBUIH0sIGVycm9yPzogYW55KTogSG90T2JzZXJ2YWJsZTxUPiB7XG4gICAgaWYgKG1hcmJsZXMuaW5kZXhPZignIScpICE9PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdob3Qgb2JzZXJ2YWJsZSBjYW5ub3QgaGF2ZSB1bnN1YnNjcmlwdGlvbiBtYXJrZXIgXCIhXCInKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBUZXN0U2NoZWR1bGVyLnBhcnNlTWFyYmxlcyhtYXJibGVzLCB2YWx1ZXMsIGVycm9yLCB1bmRlZmluZWQsIHRoaXMucnVuTW9kZSk7XG4gICAgY29uc3Qgc3ViamVjdCA9IG5ldyBIb3RPYnNlcnZhYmxlPFQ+KG1lc3NhZ2VzLCB0aGlzKTtcbiAgICB0aGlzLmhvdE9ic2VydmFibGVzLnB1c2goc3ViamVjdCk7XG4gICAgcmV0dXJuIHN1YmplY3Q7XG4gIH1cblxuICBwcml2YXRlIG1hdGVyaWFsaXplSW5uZXJPYnNlcnZhYmxlKG9ic2VydmFibGU6IE9ic2VydmFibGU8YW55Piwgb3V0ZXJGcmFtZTogbnVtYmVyKTogVGVzdE1lc3NhZ2VbXSB7XG4gICAgY29uc3QgbWVzc2FnZXM6IFRlc3RNZXNzYWdlW10gPSBbXTtcbiAgICBvYnNlcnZhYmxlLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAodmFsdWUpID0+IHtcbiAgICAgICAgbWVzc2FnZXMucHVzaCh7IGZyYW1lOiB0aGlzLmZyYW1lIC0gb3V0ZXJGcmFtZSwgbm90aWZpY2F0aW9uOiBuZXh0Tm90aWZpY2F0aW9uKHZhbHVlKSB9KTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goeyBmcmFtZTogdGhpcy5mcmFtZSAtIG91dGVyRnJhbWUsIG5vdGlmaWNhdGlvbjogZXJyb3JOb3RpZmljYXRpb24oZXJyb3IpIH0pO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goeyBmcmFtZTogdGhpcy5mcmFtZSAtIG91dGVyRnJhbWUsIG5vdGlmaWNhdGlvbjogQ09NUExFVEVfTk9USUZJQ0FUSU9OIH0pO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gbWVzc2FnZXM7XG4gIH1cblxuICBleHBlY3RPYnNlcnZhYmxlPFQ+KG9ic2VydmFibGU6IE9ic2VydmFibGU8VD4sIHN1YnNjcmlwdGlvbk1hcmJsZXM6IHN0cmluZyB8IG51bGwgPSBudWxsKSB7XG4gICAgY29uc3QgYWN0dWFsOiBUZXN0TWVzc2FnZVtdID0gW107XG4gICAgY29uc3QgZmx1c2hUZXN0OiBGbHVzaGFibGVUZXN0ID0geyBhY3R1YWwsIHJlYWR5OiBmYWxzZSB9O1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvblBhcnNlZCA9IFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzQXNTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbk1hcmJsZXMsIHRoaXMucnVuTW9kZSk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uRnJhbWUgPSBzdWJzY3JpcHRpb25QYXJzZWQuc3Vic2NyaWJlZEZyYW1lID09PSBJbmZpbml0eSA/IDAgOiBzdWJzY3JpcHRpb25QYXJzZWQuc3Vic2NyaWJlZEZyYW1lO1xuICAgIGNvbnN0IHVuc3Vic2NyaXB0aW9uRnJhbWUgPSBzdWJzY3JpcHRpb25QYXJzZWQudW5zdWJzY3JpYmVkRnJhbWU7XG4gICAgbGV0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgdGhpcy5zY2hlZHVsZSgoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICh4KSA9PiB7XG4gICAgICAgICAgLy8gU3VwcG9ydCBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB4IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSA/IHRoaXMubWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGUoeCwgdGhpcy5mcmFtZSkgOiB4O1xuICAgICAgICAgIGFjdHVhbC5wdXNoKHsgZnJhbWU6IHRoaXMuZnJhbWUsIG5vdGlmaWNhdGlvbjogbmV4dE5vdGlmaWNhdGlvbih2YWx1ZSkgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICBhY3R1YWwucHVzaCh7IGZyYW1lOiB0aGlzLmZyYW1lLCBub3RpZmljYXRpb246IGVycm9yTm90aWZpY2F0aW9uKGVycm9yKSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBhY3R1YWwucHVzaCh7IGZyYW1lOiB0aGlzLmZyYW1lLCBub3RpZmljYXRpb246IENPTVBMRVRFX05PVElGSUNBVElPTiB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0sIHN1YnNjcmlwdGlvbkZyYW1lKTtcblxuICAgIGlmICh1bnN1YnNjcmlwdGlvbkZyYW1lICE9PSBJbmZpbml0eSkge1xuICAgICAgdGhpcy5zY2hlZHVsZSgoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKSwgdW5zdWJzY3JpcHRpb25GcmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaFRlc3RzLnB1c2goZmx1c2hUZXN0KTtcbiAgICBjb25zdCB7IHJ1bk1vZGUgfSA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9CZShtYXJibGVzOiBzdHJpbmcsIHZhbHVlcz86IGFueSwgZXJyb3JWYWx1ZT86IGFueSkge1xuICAgICAgICBmbHVzaFRlc3QucmVhZHkgPSB0cnVlO1xuICAgICAgICBmbHVzaFRlc3QuZXhwZWN0ZWQgPSBUZXN0U2NoZWR1bGVyLnBhcnNlTWFyYmxlcyhtYXJibGVzLCB2YWx1ZXMsIGVycm9yVmFsdWUsIHRydWUsIHJ1bk1vZGUpO1xuICAgICAgfSxcbiAgICAgIHRvRXF1YWw6IChvdGhlcjogT2JzZXJ2YWJsZTxUPikgPT4ge1xuICAgICAgICBmbHVzaFRlc3QucmVhZHkgPSB0cnVlO1xuICAgICAgICBmbHVzaFRlc3QuZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uID0gb3RoZXIuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6ICh4KSA9PiB7XG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHggaW5zdGFuY2VvZiBPYnNlcnZhYmxlID8gdGhpcy5tYXRlcmlhbGl6ZUlubmVyT2JzZXJ2YWJsZSh4LCB0aGlzLmZyYW1lKSA6IHg7XG4gICAgICAgICAgICAgIGZsdXNoVGVzdC5leHBlY3RlZCEucHVzaCh7IGZyYW1lOiB0aGlzLmZyYW1lLCBub3RpZmljYXRpb246IG5leHROb3RpZmljYXRpb24odmFsdWUpIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgZmx1c2hUZXN0LmV4cGVjdGVkIS5wdXNoKHsgZnJhbWU6IHRoaXMuZnJhbWUsIG5vdGlmaWNhdGlvbjogZXJyb3JOb3RpZmljYXRpb24oZXJyb3IpIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGZsdXNoVGVzdC5leHBlY3RlZCEucHVzaCh7IGZyYW1lOiB0aGlzLmZyYW1lLCBub3RpZmljYXRpb246IENPTVBMRVRFX05PVElGSUNBVElPTiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHN1YnNjcmlwdGlvbkZyYW1lKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGV4cGVjdFN1YnNjcmlwdGlvbnMoYWN0dWFsU3Vic2NyaXB0aW9uTG9nczogU3Vic2NyaXB0aW9uTG9nW10pOiB7IHRvQmU6IHN1YnNjcmlwdGlvbkxvZ3NUb0JlRm4gfSB7XG4gICAgY29uc3QgZmx1c2hUZXN0OiBGbHVzaGFibGVUZXN0ID0geyBhY3R1YWw6IGFjdHVhbFN1YnNjcmlwdGlvbkxvZ3MsIHJlYWR5OiBmYWxzZSB9O1xuICAgIHRoaXMuZmx1c2hUZXN0cy5wdXNoKGZsdXNoVGVzdCk7XG4gICAgY29uc3QgeyBydW5Nb2RlIH0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICB0b0JlKG1hcmJsZXNPck1hcmJsZXNBcnJheTogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICAgICAgY29uc3QgbWFyYmxlc0FycmF5OiBzdHJpbmdbXSA9IHR5cGVvZiBtYXJibGVzT3JNYXJibGVzQXJyYXkgPT09ICdzdHJpbmcnID8gW21hcmJsZXNPck1hcmJsZXNBcnJheV0gOiBtYXJibGVzT3JNYXJibGVzQXJyYXk7XG4gICAgICAgIGZsdXNoVGVzdC5yZWFkeSA9IHRydWU7XG4gICAgICAgIGZsdXNoVGVzdC5leHBlY3RlZCA9IG1hcmJsZXNBcnJheVxuICAgICAgICAgIC5tYXAoKG1hcmJsZXMpID0+IFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzQXNTdWJzY3JpcHRpb25zKG1hcmJsZXMsIHJ1bk1vZGUpKVxuICAgICAgICAgIC5maWx0ZXIoKG1hcmJsZXMpID0+IG1hcmJsZXMuc3Vic2NyaWJlZEZyYW1lICE9PSBJbmZpbml0eSk7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBmbHVzaCgpIHtcbiAgICBjb25zdCBob3RPYnNlcnZhYmxlcyA9IHRoaXMuaG90T2JzZXJ2YWJsZXM7XG4gICAgd2hpbGUgKGhvdE9ic2VydmFibGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGhvdE9ic2VydmFibGVzLnNoaWZ0KCkhLnNldHVwKCk7XG4gICAgfVxuXG4gICAgc3VwZXIuZmx1c2goKTtcblxuICAgIHRoaXMuZmx1c2hUZXN0cyA9IHRoaXMuZmx1c2hUZXN0cy5maWx0ZXIoKHRlc3QpID0+IHtcbiAgICAgIGlmICh0ZXN0LnJlYWR5KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0RGVlcEVxdWFsKHRlc3QuYWN0dWFsLCB0ZXN0LmV4cGVjdGVkKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIHBhcnNlTWFyYmxlc0FzU3Vic2NyaXB0aW9ucyhtYXJibGVzOiBzdHJpbmcgfCBudWxsLCBydW5Nb2RlID0gZmFsc2UpOiBTdWJzY3JpcHRpb25Mb2cge1xuICAgIGlmICh0eXBlb2YgbWFyYmxlcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uTG9nKEluZmluaXR5KTtcbiAgICB9XG4gICAgLy8gU3ByZWFkaW5nIHRoZSBtYXJibGVzIGludG8gYW4gYXJyYXkgbGV2ZXJhZ2VzIEVTMjAxNSdzIHN1cHBvcnQgZm9yIGVtb2ppXG4gICAgLy8gY2hhcmFjdGVycyB3aGVuIGl0ZXJhdGluZyBzdHJpbmdzLlxuICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBbLi4ubWFyYmxlc107XG4gICAgY29uc3QgbGVuID0gY2hhcmFjdGVycy5sZW5ndGg7XG4gICAgbGV0IGdyb3VwU3RhcnQgPSAtMTtcbiAgICBsZXQgc3Vic2NyaXB0aW9uRnJhbWUgPSBJbmZpbml0eTtcbiAgICBsZXQgdW5zdWJzY3JpcHRpb25GcmFtZSA9IEluZmluaXR5O1xuICAgIGxldCBmcmFtZSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZXQgbmV4dEZyYW1lID0gZnJhbWU7XG4gICAgICBjb25zdCBhZHZhbmNlRnJhbWVCeSA9IChjb3VudDogbnVtYmVyKSA9PiB7XG4gICAgICAgIG5leHRGcmFtZSArPSBjb3VudCAqIHRoaXMuZnJhbWVUaW1lRmFjdG9yO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGMgPSBjaGFyYWN0ZXJzW2ldO1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgIC8vIFdoaXRlc3BhY2Ugbm8gbG9uZ2VyIGFkdmFuY2VzIHRpbWVcbiAgICAgICAgICBpZiAoIXJ1bk1vZGUpIHtcbiAgICAgICAgICAgIGFkdmFuY2VGcmFtZUJ5KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgYWR2YW5jZUZyYW1lQnkoMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgIGdyb3VwU3RhcnQgPSBmcmFtZTtcbiAgICAgICAgICBhZHZhbmNlRnJhbWVCeSgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgZ3JvdXBTdGFydCA9IC0xO1xuICAgICAgICAgIGFkdmFuY2VGcmFtZUJ5KDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uRnJhbWUgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3VuZCBhIHNlY29uZCBzdWJzY3JpcHRpb24gcG9pbnQgJ14nIGluIGEgXCIgKyAnc3Vic2NyaXB0aW9uIG1hcmJsZSBkaWFncmFtLiBUaGVyZSBjYW4gb25seSBiZSBvbmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YnNjcmlwdGlvbkZyYW1lID0gZ3JvdXBTdGFydCA+IC0xID8gZ3JvdXBTdGFydCA6IGZyYW1lO1xuICAgICAgICAgIGFkdmFuY2VGcmFtZUJ5KDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICBpZiAodW5zdWJzY3JpcHRpb25GcmFtZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvdW5kIGEgc2Vjb25kIHVuc3Vic2NyaXB0aW9uIHBvaW50ICchJyBpbiBhIFwiICsgJ3N1YnNjcmlwdGlvbiBtYXJibGUgZGlhZ3JhbS4gVGhlcmUgY2FuIG9ubHkgYmUgb25lLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bnN1YnNjcmlwdGlvbkZyYW1lID0gZ3JvdXBTdGFydCA+IC0xID8gZ3JvdXBTdGFydCA6IGZyYW1lO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHRpbWUgcHJvZ3Jlc3Npb24gc3ludGF4XG4gICAgICAgICAgaWYgKHJ1bk1vZGUgJiYgYy5tYXRjaCgvXlswLTldJC8pKSB7XG4gICAgICAgICAgICAvLyBUaW1lIHByb2dyZXNzaW9uIG11c3QgYmUgcHJlY2VkZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlXG4gICAgICAgICAgICAvLyBpZiBpdCdzIG5vdCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkaWFncmFtXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBjaGFyYWN0ZXJzW2kgLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGNoYXJhY3RlcnMuc2xpY2UoaSkuam9pbignJyk7XG4gICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYnVmZmVyLm1hdGNoKC9eKFswLTldKyg/OlxcLlswLTldKyk/KShtc3xzfG0pIC8pO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpICs9IG1hdGNoWzBdLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bml0ID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgbGV0IGR1cmF0aW9uSW5NczogbnVtYmVyO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uSW5NcyA9IGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbkluTXMgPSBkdXJhdGlvbiAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uSW5NcyA9IGR1cmF0aW9uICogMTAwMCAqIDYwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFkdmFuY2VGcmFtZUJ5KGR1cmF0aW9uSW5NcyEgLyB0aGlzLmZyYW1lVGltZUZhY3Rvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0aGVyZSBjYW4gb25seSBiZSAnXicgYW5kICchJyBtYXJrZXJzIGluIGEgXCIgKyBcInN1YnNjcmlwdGlvbiBtYXJibGUgZGlhZ3JhbS4gRm91bmQgaW5zdGVhZCAnXCIgKyBjICsgXCInLlwiKTtcbiAgICAgIH1cblxuICAgICAgZnJhbWUgPSBuZXh0RnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKHVuc3Vic2NyaXB0aW9uRnJhbWUgPCAwKSB7XG4gICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbkxvZyhzdWJzY3JpcHRpb25GcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uTG9nKHN1YnNjcmlwdGlvbkZyYW1lLCB1bnN1YnNjcmlwdGlvbkZyYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIHBhcnNlTWFyYmxlcyhcbiAgICBtYXJibGVzOiBzdHJpbmcsXG4gICAgdmFsdWVzPzogYW55LFxuICAgIGVycm9yVmFsdWU/OiBhbnksXG4gICAgbWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGVzOiBib29sZWFuID0gZmFsc2UsXG4gICAgcnVuTW9kZSA9IGZhbHNlXG4gICk6IFRlc3RNZXNzYWdlW10ge1xuICAgIGlmIChtYXJibGVzLmluZGV4T2YoJyEnKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVudGlvbmFsIG1hcmJsZSBkaWFncmFtcyBjYW5ub3QgaGF2ZSB0aGUgJyArICd1bnN1YnNjcmlwdGlvbiBtYXJrZXIgXCIhXCInKTtcbiAgICB9XG4gICAgLy8gU3ByZWFkaW5nIHRoZSBtYXJibGVzIGludG8gYW4gYXJyYXkgbGV2ZXJhZ2VzIEVTMjAxNSdzIHN1cHBvcnQgZm9yIGVtb2ppXG4gICAgLy8gY2hhcmFjdGVycyB3aGVuIGl0ZXJhdGluZyBzdHJpbmdzLlxuICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBbLi4ubWFyYmxlc107XG4gICAgY29uc3QgbGVuID0gY2hhcmFjdGVycy5sZW5ndGg7XG4gICAgY29uc3QgdGVzdE1lc3NhZ2VzOiBUZXN0TWVzc2FnZVtdID0gW107XG4gICAgY29uc3Qgc3ViSW5kZXggPSBydW5Nb2RlID8gbWFyYmxlcy5yZXBsYWNlKC9eWyBdKy8sICcnKS5pbmRleE9mKCdeJykgOiBtYXJibGVzLmluZGV4T2YoJ14nKTtcbiAgICBsZXQgZnJhbWUgPSBzdWJJbmRleCA9PT0gLTEgPyAwIDogc3ViSW5kZXggKiAtdGhpcy5mcmFtZVRpbWVGYWN0b3I7XG4gICAgY29uc3QgZ2V0VmFsdWUgPVxuICAgICAgdHlwZW9mIHZhbHVlcyAhPT0gJ29iamVjdCdcbiAgICAgICAgPyAoeDogYW55KSA9PiB4XG4gICAgICAgIDogKHg6IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gU3VwcG9ydCBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gICAgICAgICAgICBpZiAobWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGVzICYmIHZhbHVlc1t4XSBpbnN0YW5jZW9mIENvbGRPYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbeF0ubWVzc2FnZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW3hdO1xuICAgICAgICAgIH07XG4gICAgbGV0IGdyb3VwU3RhcnQgPSAtMTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBuZXh0RnJhbWUgPSBmcmFtZTtcbiAgICAgIGNvbnN0IGFkdmFuY2VGcmFtZUJ5ID0gKGNvdW50OiBudW1iZXIpID0+IHtcbiAgICAgICAgbmV4dEZyYW1lICs9IGNvdW50ICogdGhpcy5mcmFtZVRpbWVGYWN0b3I7XG4gICAgICB9O1xuXG4gICAgICBsZXQgbm90aWZpY2F0aW9uOiBPYnNlcnZhYmxlTm90aWZpY2F0aW9uPGFueT4gfCB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBjID0gY2hhcmFjdGVyc1tpXTtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAvLyBXaGl0ZXNwYWNlIG5vIGxvbmdlciBhZHZhbmNlcyB0aW1lXG4gICAgICAgICAgaWYgKCFydW5Nb2RlKSB7XG4gICAgICAgICAgICBhZHZhbmNlRnJhbWVCeSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIGFkdmFuY2VGcmFtZUJ5KDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICBncm91cFN0YXJ0ID0gZnJhbWU7XG4gICAgICAgICAgYWR2YW5jZUZyYW1lQnkoMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgIGdyb3VwU3RhcnQgPSAtMTtcbiAgICAgICAgICBhZHZhbmNlRnJhbWVCeSgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgbm90aWZpY2F0aW9uID0gQ09NUExFVEVfTk9USUZJQ0FUSU9OO1xuICAgICAgICAgIGFkdmFuY2VGcmFtZUJ5KDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICBhZHZhbmNlRnJhbWVCeSgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgbm90aWZpY2F0aW9uID0gZXJyb3JOb3RpZmljYXRpb24oZXJyb3JWYWx1ZSB8fCAnZXJyb3InKTtcbiAgICAgICAgICBhZHZhbmNlRnJhbWVCeSgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBNaWdodCBiZSB0aW1lIHByb2dyZXNzaW9uIHN5bnRheCwgb3IgYSB2YWx1ZSBsaXRlcmFsXG4gICAgICAgICAgaWYgKHJ1bk1vZGUgJiYgYy5tYXRjaCgvXlswLTldJC8pKSB7XG4gICAgICAgICAgICAvLyBUaW1lIHByb2dyZXNzaW9uIG11c3QgYmUgcHJlY2VkZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlXG4gICAgICAgICAgICAvLyBpZiBpdCdzIG5vdCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkaWFncmFtXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBjaGFyYWN0ZXJzW2kgLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGNoYXJhY3RlcnMuc2xpY2UoaSkuam9pbignJyk7XG4gICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYnVmZmVyLm1hdGNoKC9eKFswLTldKyg/OlxcLlswLTldKyk/KShtc3xzfG0pIC8pO1xuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpICs9IG1hdGNoWzBdLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bml0ID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgbGV0IGR1cmF0aW9uSW5NczogbnVtYmVyO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uSW5NcyA9IGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbkluTXMgPSBkdXJhdGlvbiAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uSW5NcyA9IGR1cmF0aW9uICogMTAwMCAqIDYwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFkdmFuY2VGcmFtZUJ5KGR1cmF0aW9uSW5NcyEgLyB0aGlzLmZyYW1lVGltZUZhY3Rvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub3RpZmljYXRpb24gPSBuZXh0Tm90aWZpY2F0aW9uKGdldFZhbHVlKGMpKTtcbiAgICAgICAgICBhZHZhbmNlRnJhbWVCeSgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdGlmaWNhdGlvbikge1xuICAgICAgICB0ZXN0TWVzc2FnZXMucHVzaCh7IGZyYW1lOiBncm91cFN0YXJ0ID4gLTEgPyBncm91cFN0YXJ0IDogZnJhbWUsIG5vdGlmaWNhdGlvbiB9KTtcbiAgICAgIH1cblxuICAgICAgZnJhbWUgPSBuZXh0RnJhbWU7XG4gICAgfVxuICAgIHJldHVybiB0ZXN0TWVzc2FnZXM7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUFuaW1hdG9yKCkge1xuICAgIGlmICghdGhpcy5ydW5Nb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FuaW1hdGUoKSBtdXN0IG9ubHkgYmUgdXNlZCBpbiBydW4gbW9kZScpO1xuICAgIH1cblxuICAgIC8vIFRoZSBUZXN0U2NoZWR1bGVyIGFzc2lnbnMgYSBkZWxlZ2F0ZSB0byB0aGUgcHJvdmlkZXIgdGhhdCdzIHVzZWQgZm9yXG4gICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpLiBUaGUgZGVsZWdhdGUgd29ya3MgaW4gY29uanVuY3Rpb24gd2l0aCB0aGVcbiAgICAvLyBhbmltYXRlIHJ1biBoZWxwZXIgdG8gY29vcmRpbmF0ZSB0aGUgaW52b2NhdGlvbiBvZiBhbnkgckFGIGNhbGxiYWNrcyxcbiAgICAvLyB0aGF0IGFyZSBlZmZlY3RlZCB3aXRoaW4gdGVzdHMsIHdpdGggdGhlIGFuaW1hdGlvbiBmcmFtZXMgc3BlY2lmaWVkIGJ5XG4gICAgLy8gdGhlIHRlc3QncyBhdXRob3IgLSBpbiB0aGUgbWFyYmxlcyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlIGFuaW1hdGUgcnVuXG4gICAgLy8gaGVscGVyLiBUaGlzIGFsbG93cyB0aGUgdGVzdCdzIGF1dGhvciB0byB3cml0ZSBkZXRlcm1pbmlzdGljIHRlc3RzIGFuZFxuICAgIC8vIGdpdmVzIHRoZSBhdXRob3IgZnVsbCBjb250cm9sIG92ZXIgd2hlbiAtIG9yIGlmIC0gYW5pbWF0aW9uIGZyYW1lcyBhcmVcbiAgICAvLyAncGFpbnRlZCcuXG5cbiAgICBsZXQgbGFzdEhhbmRsZSA9IDA7XG4gICAgbGV0IG1hcDogTWFwPG51bWJlciwgRnJhbWVSZXF1ZXN0Q2FsbGJhY2s+IHwgdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgZGVsZWdhdGUgPSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2s6IEZyYW1lUmVxdWVzdENhbGxiYWNrKSB7XG4gICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbmltYXRlKCkgd2FzIG5vdCBjYWxsZWQgd2l0aGluIHJ1bigpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlID0gKytsYXN0SGFuZGxlO1xuICAgICAgICBtYXAuc2V0KGhhbmRsZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZTogbnVtYmVyKSB7XG4gICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbmltYXRlKCkgd2FzIG5vdCBjYWxsZWQgd2l0aGluIHJ1bigpJyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFwLmRlbGV0ZShoYW5kbGUpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgYW5pbWF0ZSA9IChtYXJibGVzOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChtYXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbmltYXRlKCkgbXVzdCBub3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGhpbiBydW4oKScpO1xuICAgICAgfVxuICAgICAgaWYgKC9bfCNdLy50ZXN0KG1hcmJsZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYW5pbWF0ZSgpIG11c3Qgbm90IGNvbXBsZXRlIG9yIGVycm9yJyk7XG4gICAgICB9XG4gICAgICBtYXAgPSBuZXcgTWFwPG51bWJlciwgRnJhbWVSZXF1ZXN0Q2FsbGJhY2s+KCk7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzKG1hcmJsZXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vdyA9IHRoaXMubm93KCk7XG4gICAgICAgICAgLy8gQ2FwdHVyZSB0aGUgY2FsbGJhY2tzIHdpdGhpbiB0aGUgcXVldWUgYW5kIGNsZWFyIHRoZSBxdWV1ZVxuICAgICAgICAgIC8vIGJlZm9yZSBlbnVtZXJhdGluZyB0aGUgY2FsbGJhY2tzLCBhcyBjYWxsYmFja3MgbWlnaHRcbiAgICAgICAgICAvLyByZXNjaGVkdWxlIHRoZW1zZWx2ZXMuIChBbmQsIHllYWgsIHdlJ3JlIHVzaW5nIGEgTWFwIHRvIHJlcHJlc2VudFxuICAgICAgICAgIC8vIHRoZSBxdWV1ZSwgYnV0IHRoZSB2YWx1ZXMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgcmV0dXJuZWQgaW5cbiAgICAgICAgICAvLyBpbnNlcnRpb24gb3JkZXIsIHNvIGl0J3MgYWxsIGdvb2QuIFRydXN0IG1lLCBJJ3ZlIHJlYWQgdGhlIGRvY3MuKVxuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IEFycmF5LmZyb20obWFwIS52YWx1ZXMoKSk7XG4gICAgICAgICAgbWFwIS5jbGVhcigpO1xuICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhub3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbWVzc2FnZS5mcmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB7IGFuaW1hdGUsIGRlbGVnYXRlIH07XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURlbGVnYXRlcygpIHtcbiAgICAvLyBXaGVuIGluIHJ1biBtb2RlLCB0aGUgVGVzdFNjaGVkdWxlciBwcm92aWRlcyBhbHRlcm5hdGUgaW1wbGVtZW50YXRpb25zXG4gICAgLy8gb2Ygc2V0L2NsZWFySW1tZWRpYXRlIGFuZCBzZXQvY2xlYXJJbnRlcnZhbC4gVGhlc2UgaW1wbGVtZW50YXRpb25zIGFyZVxuICAgIC8vIGNvbnN1bWVkIGJ5IHRoZSBzY2hlZHVsZXIgaW1wbGVtZW50YXRpb25zIHZpYSB0aGUgcHJvdmlkZXJzLiBUaGlzIGlzXG4gICAgLy8gZG9uZSB0byBlZmZlY3QgZGV0ZXJtaW5pc3RpYyBhc2FwIGFuZCBhc3luYyBzY2hlZHVsZXIgYmVoYXZpb3Igc28gdGhhdFxuICAgIC8vIGFsbCBvZiB0aGUgc2NoZWR1bGVycyBhcmUgdGVzdGFibGUgaW4gJ3J1biBtb2RlJy4gUHJpb3IgdG8gdjcsXG4gICAgLy8gZGVsZWdhdGlvbiBvY2N1cnJlZCBhdCB0aGUgc2NoZWR1bGVyIGxldmVsLiBUaGF0IGlzLCB0aGUgYXNhcCBhbmRcbiAgICAvLyBhbmltYXRpb24gZnJhbWUgc2NoZWR1bGVycyB3ZXJlIGlkZW50aWNhbCBpbiBiZWhhdmlvciB0byB0aGUgYXN5bmNcbiAgICAvLyBzY2hlZHVsZXIuIE5vdywgd2hlbiBpbiBydW4gbW9kZSwgYXNhcCBhY3Rpb25zIGFyZSBwcmlvcml0aXplZCBvdmVyXG4gICAgLy8gYXN5bmMgYWN0aW9ucyBhbmQgYW5pbWF0aW9uIGZyYW1lIGFjdGlvbnMgYXJlIGNvb3JkaW5hdGVkIHVzaW5nIHRoZVxuICAgIC8vIGFuaW1hdGUgcnVuIGhlbHBlci5cblxuICAgIGxldCBsYXN0SGFuZGxlID0gMDtcbiAgICBjb25zdCBzY2hlZHVsZUxvb2t1cCA9IG5ldyBNYXA8XG4gICAgICBUaW1lckhhbmRsZSxcbiAgICAgIHtcbiAgICAgICAgZHVlOiBudW1iZXI7XG4gICAgICAgIGR1cmF0aW9uOiBudW1iZXI7XG4gICAgICAgIGhhbmRsZTogVGltZXJIYW5kbGU7XG4gICAgICAgIGhhbmRsZXI6ICgpID0+IHZvaWQ7XG4gICAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgICAgICB0eXBlOiAnaW1tZWRpYXRlJyB8ICdpbnRlcnZhbCcgfCAndGltZW91dCc7XG4gICAgICB9XG4gICAgPigpO1xuXG4gICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgLy8gV2hlbmV2ZXIgYSBzY2hlZHVsZWQgcnVuIGlzIGV4ZWN1dGVkLCBpdCBtdXN0IHJ1biBhIHNpbmdsZSBpbW1lZGlhdGVcbiAgICAgIC8vIG9yIGludGVydmFsIGFjdGlvbiAtIHdpdGggaW1tZWRpYXRlIGFjdGlvbnMgYmVpbmcgcHJpb3JpdGl6ZWQgb3ZlclxuICAgICAgLy8gaW50ZXJ2YWwgYW5kIHRpbWVvdXQgYWN0aW9ucy5cbiAgICAgIGNvbnN0IG5vdyA9IHRoaXMubm93KCk7XG4gICAgICBjb25zdCBzY2hlZHVsZWRSZWNvcmRzID0gQXJyYXkuZnJvbShzY2hlZHVsZUxvb2t1cC52YWx1ZXMoKSk7XG4gICAgICBjb25zdCBzY2hlZHVsZWRSZWNvcmRzRHVlID0gc2NoZWR1bGVkUmVjb3Jkcy5maWx0ZXIoKHsgZHVlIH0pID0+IGR1ZSA8PSBub3cpO1xuICAgICAgY29uc3QgZHVlSW1tZWRpYXRlcyA9IHNjaGVkdWxlZFJlY29yZHNEdWUuZmlsdGVyKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gJ2ltbWVkaWF0ZScpO1xuICAgICAgaWYgKGR1ZUltbWVkaWF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB7IGhhbmRsZSwgaGFuZGxlciB9ID0gZHVlSW1tZWRpYXRlc1swXTtcbiAgICAgICAgc2NoZWR1bGVMb29rdXAuZGVsZXRlKGhhbmRsZSk7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHVlSW50ZXJ2YWxzID0gc2NoZWR1bGVkUmVjb3Jkc0R1ZS5maWx0ZXIoKHsgdHlwZSB9KSA9PiB0eXBlID09PSAnaW50ZXJ2YWwnKTtcbiAgICAgIGlmIChkdWVJbnRlcnZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmaXJzdER1ZUludGVydmFsID0gZHVlSW50ZXJ2YWxzWzBdO1xuICAgICAgICBjb25zdCB7IGR1cmF0aW9uLCBoYW5kbGVyIH0gPSBmaXJzdER1ZUludGVydmFsO1xuICAgICAgICBmaXJzdER1ZUludGVydmFsLmR1ZSA9IG5vdyArIGR1cmF0aW9uO1xuICAgICAgICAvLyBUaGUgaW50ZXJ2YWwgZGVsZWdhdGUgbXVzdCBiZWhhdmUgbGlrZSBzZXRJbnRlcnZhbCwgc28gcnVuIG5lZWRzIHRvXG4gICAgICAgIC8vIGJlIHJlc2NoZWR1bGVkLiBUaGlzIHdpbGwgY29udGludWUgdW50aWwgdGhlIGNsZWFySW50ZXJ2YWwgZGVsZWdhdGVcbiAgICAgICAgLy8gdW5zdWJzY3JpYmVzIGFuZCBkZWxldGVzIHRoZSBoYW5kbGUgZnJvbSB0aGUgbWFwLlxuICAgICAgICBmaXJzdER1ZUludGVydmFsLnN1YnNjcmlwdGlvbiA9IHRoaXMuc2NoZWR1bGUocnVuLCBkdXJhdGlvbik7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHVlVGltZW91dHMgPSBzY2hlZHVsZWRSZWNvcmRzRHVlLmZpbHRlcigoeyB0eXBlIH0pID0+IHR5cGUgPT09ICd0aW1lb3V0Jyk7XG4gICAgICBpZiAoZHVlVGltZW91dHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB7IGhhbmRsZSwgaGFuZGxlciB9ID0gZHVlVGltZW91dHNbMF07XG4gICAgICAgIHNjaGVkdWxlTG9va3VwLmRlbGV0ZShoYW5kbGUpO1xuICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBkdWUgaW1tZWRpYXRlIG9yIGludGVydmFsJyk7XG4gICAgfTtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgb2JqZWN0cyBhcmUgdGhlIGRlbGVnYXRlcyB0aGF0IHJlcGxhY2UgY29udmVudGlvbmFsXG4gICAgLy8gcnVudGltZSBpbXBsZW1lbnRhdGlvbnMgd2l0aCBUZXN0U2NoZWR1bGVyIGltcGxlbWVudGF0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZSBpbW1lZGlhdGUgZGVsZWdhdGUgaXMgZGVwZW5kZWQgdXBvbiBieSB0aGUgYXNhcFNjaGVkdWxlci5cbiAgICAvL1xuICAgIC8vIFRoZSBpbnRlcnZhbCBkZWxlZ2F0ZSBpcyBkZXBlbmRlZCB1cG9uIGJ5IHRoZSBhc3luY1NjaGVkdWxlci5cbiAgICAvL1xuICAgIC8vIFRoZSB0aW1lb3V0IGRlbGVnYXRlIGlzIG5vdCBkZXBlbmRlZCB1cG9uIGJ5IGFueSBzY2hlZHVsZXIsIGJ1dCBpdCdzXG4gICAgLy8gaW5jbHVkZWQgaGVyZSBiZWNhdXNlIHRoZSBvblVuaGFuZGxlZEVycm9yIGFuZCBvblN0b3BwZWROb3RpZmljYXRpb25cbiAgICAvLyBjb25maWd1cmF0aW9uIHBvaW50cyB1c2Ugc2V0VGltZW91dCB0byBhdm9pZCBwcm9kdWNlciBpbnRlcmZlcmVuY2UuIEl0J3NcbiAgICAvLyBpbmNsdXNpb24gYWxsb3dzIGZvciB0aGUgdGVzdGluZyBvZiB0aGVzZSBjb25maWd1cmF0aW9uIHBvaW50cy5cblxuICAgIGNvbnN0IGltbWVkaWF0ZSA9IHtcbiAgICAgIHNldEltbWVkaWF0ZTogKGhhbmRsZXI6ICgpID0+IHZvaWQpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gKytsYXN0SGFuZGxlO1xuICAgICAgICBzY2hlZHVsZUxvb2t1cC5zZXQoaGFuZGxlLCB7XG4gICAgICAgICAgZHVlOiB0aGlzLm5vdygpLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgIGhhbmRsZSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHN1YnNjcmlwdGlvbjogdGhpcy5zY2hlZHVsZShydW4sIDApLFxuICAgICAgICAgIHR5cGU6ICdpbW1lZGlhdGUnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgIH0sXG4gICAgICBjbGVhckltbWVkaWF0ZTogKGhhbmRsZTogVGltZXJIYW5kbGUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzY2hlZHVsZUxvb2t1cC5nZXQoaGFuZGxlKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgc2NoZWR1bGVMb29rdXAuZGVsZXRlKGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGludGVydmFsID0ge1xuICAgICAgc2V0SW50ZXJ2YWw6IChoYW5kbGVyOiAoKSA9PiB2b2lkLCBkdXJhdGlvbiA9IDApID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gKytsYXN0SGFuZGxlO1xuICAgICAgICBzY2hlZHVsZUxvb2t1cC5zZXQoaGFuZGxlLCB7XG4gICAgICAgICAgZHVlOiB0aGlzLm5vdygpICsgZHVyYXRpb24sXG4gICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLnNjaGVkdWxlKHJ1biwgZHVyYXRpb24pLFxuICAgICAgICAgIHR5cGU6ICdpbnRlcnZhbCcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgfSxcbiAgICAgIGNsZWFySW50ZXJ2YWw6IChoYW5kbGU6IFRpbWVySGFuZGxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2NoZWR1bGVMb29rdXAuZ2V0KGhhbmRsZSk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhbHVlLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHNjaGVkdWxlTG9va3VwLmRlbGV0ZShoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBjb25zdCB0aW1lb3V0ID0ge1xuICAgICAgc2V0VGltZW91dDogKGhhbmRsZXI6ICgpID0+IHZvaWQsIGR1cmF0aW9uID0gMCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGUgPSArK2xhc3RIYW5kbGU7XG4gICAgICAgIHNjaGVkdWxlTG9va3VwLnNldChoYW5kbGUsIHtcbiAgICAgICAgICBkdWU6IHRoaXMubm93KCkgKyBkdXJhdGlvbixcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICBoYW5kbGUsXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICBzdWJzY3JpcHRpb246IHRoaXMuc2NoZWR1bGUocnVuLCBkdXJhdGlvbiksXG4gICAgICAgICAgdHlwZTogJ3RpbWVvdXQnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgIH0sXG4gICAgICBjbGVhclRpbWVvdXQ6IChoYW5kbGU6IFRpbWVySGFuZGxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2NoZWR1bGVMb29rdXAuZ2V0KGhhbmRsZSk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhbHVlLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHNjaGVkdWxlTG9va3VwLmRlbGV0ZShoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4geyBpbW1lZGlhdGUsIGludGVydmFsLCB0aW1lb3V0IH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGBydW5gIG1ldGhvZCBwZXJmb3JtcyB0aGUgdGVzdCBpbiAncnVuIG1vZGUnIC0gaW4gd2hpY2ggc2NoZWR1bGVyc1xuICAgKiB1c2VkIHdpdGhpbiB0aGUgdGVzdCBhdXRvbWF0aWNhbGx5IGRlbGVnYXRlIHRvIHRoZSBgVGVzdFNjaGVkdWxlcmAuIFRoYXRcbiAgICogaXMsIGluICdydW4gbW9kZScgdGhlcmUgaXMgbm8gbmVlZCB0byBleHBsaWNpdGx5IHBhc3MgYSBgVGVzdFNjaGVkdWxlcmBcbiAgICogaW5zdGFuY2UgdG8gb2JzZXJ2YWJsZSBjcmVhdG9ycyBvciBvcGVyYXRvcnMuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIC9ndWlkZS90ZXN0aW5nL21hcmJsZS10ZXN0aW5nfVxuICAgKi9cbiAgcnVuPFQ+KGNhbGxiYWNrOiAoaGVscGVyczogUnVuSGVscGVycykgPT4gVCk6IFQge1xuICAgIGNvbnN0IHByZXZGcmFtZVRpbWVGYWN0b3IgPSBUZXN0U2NoZWR1bGVyLmZyYW1lVGltZUZhY3RvcjtcbiAgICBjb25zdCBwcmV2TWF4RnJhbWVzID0gdGhpcy5tYXhGcmFtZXM7XG5cbiAgICBUZXN0U2NoZWR1bGVyLmZyYW1lVGltZUZhY3RvciA9IDE7XG4gICAgdGhpcy5tYXhGcmFtZXMgPSBJbmZpbml0eTtcbiAgICB0aGlzLnJ1bk1vZGUgPSB0cnVlO1xuXG4gICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLmNyZWF0ZUFuaW1hdG9yKCk7XG4gICAgY29uc3QgZGVsZWdhdGVzID0gdGhpcy5jcmVhdGVEZWxlZ2F0ZXMoKTtcblxuICAgIGFuaW1hdGlvbkZyYW1lUHJvdmlkZXIuZGVsZWdhdGUgPSBhbmltYXRvci5kZWxlZ2F0ZTtcbiAgICBkYXRlVGltZXN0YW1wUHJvdmlkZXIuZGVsZWdhdGUgPSB0aGlzO1xuICAgIGltbWVkaWF0ZVByb3ZpZGVyLmRlbGVnYXRlID0gZGVsZWdhdGVzLmltbWVkaWF0ZTtcbiAgICBpbnRlcnZhbFByb3ZpZGVyLmRlbGVnYXRlID0gZGVsZWdhdGVzLmludGVydmFsO1xuICAgIHRpbWVvdXRQcm92aWRlci5kZWxlZ2F0ZSA9IGRlbGVnYXRlcy50aW1lb3V0O1xuICAgIHBlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXIuZGVsZWdhdGUgPSB0aGlzO1xuXG4gICAgY29uc3QgaGVscGVyczogUnVuSGVscGVycyA9IHtcbiAgICAgIGNvbGQ6IHRoaXMuY3JlYXRlQ29sZE9ic2VydmFibGUuYmluZCh0aGlzKSxcbiAgICAgIGhvdDogdGhpcy5jcmVhdGVIb3RPYnNlcnZhYmxlLmJpbmQodGhpcyksXG4gICAgICBmbHVzaDogdGhpcy5mbHVzaC5iaW5kKHRoaXMpLFxuICAgICAgdGltZTogdGhpcy5jcmVhdGVUaW1lLmJpbmQodGhpcyksXG4gICAgICBleHBlY3RPYnNlcnZhYmxlOiB0aGlzLmV4cGVjdE9ic2VydmFibGUuYmluZCh0aGlzKSxcbiAgICAgIGV4cGVjdFN1YnNjcmlwdGlvbnM6IHRoaXMuZXhwZWN0U3Vic2NyaXB0aW9ucy5iaW5kKHRoaXMpLFxuICAgICAgYW5pbWF0ZTogYW5pbWF0b3IuYW5pbWF0ZSxcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXQgPSBjYWxsYmFjayhoZWxwZXJzKTtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRlc3RTY2hlZHVsZXIuZnJhbWVUaW1lRmFjdG9yID0gcHJldkZyYW1lVGltZUZhY3RvcjtcbiAgICAgIHRoaXMubWF4RnJhbWVzID0gcHJldk1heEZyYW1lcztcbiAgICAgIHRoaXMucnVuTW9kZSA9IGZhbHNlO1xuICAgICAgYW5pbWF0aW9uRnJhbWVQcm92aWRlci5kZWxlZ2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIGRhdGVUaW1lc3RhbXBQcm92aWRlci5kZWxlZ2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIGltbWVkaWF0ZVByb3ZpZGVyLmRlbGVnYXRlID0gdW5kZWZpbmVkO1xuICAgICAgaW50ZXJ2YWxQcm92aWRlci5kZWxlZ2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRpbWVvdXRQcm92aWRlci5kZWxlZ2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHBlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXIuZGVsZWdhdGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG4iXX0=
