import { EmptyError } from './util/EmptyError.mjs';
import { SafeSubscriber } from './Subscriber.mjs';
/**
 * Converts an observable to a promise by subscribing to the observable,
 * and returning a promise that will resolve as soon as the first value
 * arrives from the observable. The subscription will then be closed.
 *
 * If the observable stream completes before any values were emitted, the
 * returned promise will reject with {@link EmptyError} or will resolve
 * with the default value if a default was specified.
 *
 * If the observable stream emits an error, the returned promise will reject
 * with that error.
 *
 * **WARNING**: Only use this with observables you *know* will emit at least one value,
 * *OR* complete. If the source observable does not emit one value or complete, you will
 * end up with a promise that is hung up, and potentially all of the state of an
 * async function hanging out in memory. To avoid this situation, look into adding
 * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}
 * amongst others.
 *
 * ## Example
 *
 * Wait for the first value from a stream and emit it from a promise in
 * an async function
 *
 * ```ts
 * import { interval, firstValueFrom } from 'rxjs';
 *
 * async function execute() {
 *   const source$ = interval(2000);
 *   const firstNumber = await firstValueFrom(source$);
 *   console.log(`The first number is ${ firstNumber }`);
 * }
 *
 * execute();
 *
 * // Expected output:
 * // 'The first number is 0'
 * ```
 *
 * @see {@link lastValueFrom}
 *
 * @param source the observable to convert to a promise
 * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value
 */
export function firstValueFrom(source, config) {
    const hasConfig = typeof config === 'object';
    return new Promise((resolve, reject) => {
        const subscriber = new SafeSubscriber({
            next: (value) => {
                resolve(value);
                subscriber.unsubscribe();
            },
            error: reject,
            complete: () => {
                if (hasConfig) {
                    resolve(config.defaultValue);
                }
                else {
                    reject(new EmptyError());
                }
            },
        });
        source.subscribe(subscriber);
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9maXJzdFZhbHVlRnJvbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDL0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQVM5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJDRztBQUNILE1BQU0sVUFBVSxjQUFjLENBQU8sTUFBcUIsRUFBRSxNQUFnQztJQUMxRixNQUFNLFNBQVMsR0FBRyxPQUFPLE1BQU0sS0FBSyxRQUFRLENBQUM7SUFDN0MsT0FBTyxJQUFJLE9BQU8sQ0FBUSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUM1QyxNQUFNLFVBQVUsR0FBRyxJQUFJLGNBQWMsQ0FBSTtZQUN2QyxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDZCxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ2YsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQzNCLENBQUM7WUFDRCxLQUFLLEVBQUUsTUFBTTtZQUNiLFFBQVEsRUFBRSxHQUFHLEVBQUU7Z0JBQ2IsSUFBSSxTQUFTLEVBQUUsQ0FBQztvQkFDZCxPQUFPLENBQUMsTUFBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUNoQyxDQUFDO3FCQUFNLENBQUM7b0JBQ04sTUFBTSxDQUFDLElBQUksVUFBVSxFQUFFLENBQUMsQ0FBQztnQkFDM0IsQ0FBQztZQUNILENBQUM7U0FDRixDQUFDLENBQUM7UUFDSCxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQy9CLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsImZpbGUiOiJub2RlX21vZHVsZXMvcnhqcy9zcmMvaW50ZXJuYWwvZmlyc3RWYWx1ZUZyb20uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IEVtcHR5RXJyb3IgfSBmcm9tICcuL3V0aWwvRW1wdHlFcnJvcic7XG5pbXBvcnQgeyBTYWZlU3Vic2NyaWJlciB9IGZyb20gJy4vU3Vic2NyaWJlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlyc3RWYWx1ZUZyb21Db25maWc8VD4ge1xuICBkZWZhdWx0VmFsdWU6IFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdFZhbHVlRnJvbTxULCBEPihzb3VyY2U6IE9ic2VydmFibGU8VD4sIGNvbmZpZzogRmlyc3RWYWx1ZUZyb21Db25maWc8RD4pOiBQcm9taXNlPFQgfCBEPjtcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdFZhbHVlRnJvbTxUPihzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBQcm9taXNlPFQ+O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9ic2VydmFibGUgdG8gYSBwcm9taXNlIGJ5IHN1YnNjcmliaW5nIHRvIHRoZSBvYnNlcnZhYmxlLFxuICogYW5kIHJldHVybmluZyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgYXMgc29vbiBhcyB0aGUgZmlyc3QgdmFsdWVcbiAqIGFycml2ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS4gVGhlIHN1YnNjcmlwdGlvbiB3aWxsIHRoZW4gYmUgY2xvc2VkLlxuICpcbiAqIElmIHRoZSBvYnNlcnZhYmxlIHN0cmVhbSBjb21wbGV0ZXMgYmVmb3JlIGFueSB2YWx1ZXMgd2VyZSBlbWl0dGVkLCB0aGVcbiAqIHJldHVybmVkIHByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCB7QGxpbmsgRW1wdHlFcnJvcn0gb3Igd2lsbCByZXNvbHZlXG4gKiB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlIGlmIGEgZGVmYXVsdCB3YXMgc3BlY2lmaWVkLlxuICpcbiAqIElmIHRoZSBvYnNlcnZhYmxlIHN0cmVhbSBlbWl0cyBhbiBlcnJvciwgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCByZWplY3RcbiAqIHdpdGggdGhhdCBlcnJvci5cbiAqXG4gKiAqKldBUk5JTkcqKjogT25seSB1c2UgdGhpcyB3aXRoIG9ic2VydmFibGVzIHlvdSAqa25vdyogd2lsbCBlbWl0IGF0IGxlYXN0IG9uZSB2YWx1ZSxcbiAqICpPUiogY29tcGxldGUuIElmIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBkb2VzIG5vdCBlbWl0IG9uZSB2YWx1ZSBvciBjb21wbGV0ZSwgeW91IHdpbGxcbiAqIGVuZCB1cCB3aXRoIGEgcHJvbWlzZSB0aGF0IGlzIGh1bmcgdXAsIGFuZCBwb3RlbnRpYWxseSBhbGwgb2YgdGhlIHN0YXRlIG9mIGFuXG4gKiBhc3luYyBmdW5jdGlvbiBoYW5naW5nIG91dCBpbiBtZW1vcnkuIFRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLCBsb29rIGludG8gYWRkaW5nXG4gKiBzb21ldGhpbmcgbGlrZSB7QGxpbmsgdGltZW91dH0sIHtAbGluayB0YWtlfSwge0BsaW5rIHRha2VXaGlsZX0sIG9yIHtAbGluayB0YWtlVW50aWx9XG4gKiBhbW9uZ3N0IG90aGVycy5cbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICogV2FpdCBmb3IgdGhlIGZpcnN0IHZhbHVlIGZyb20gYSBzdHJlYW0gYW5kIGVtaXQgaXQgZnJvbSBhIHByb21pc2UgaW5cbiAqIGFuIGFzeW5jIGZ1bmN0aW9uXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGludGVydmFsLCBmaXJzdFZhbHVlRnJvbSB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gKiAgIGNvbnN0IHNvdXJjZSQgPSBpbnRlcnZhbCgyMDAwKTtcbiAqICAgY29uc3QgZmlyc3ROdW1iZXIgPSBhd2FpdCBmaXJzdFZhbHVlRnJvbShzb3VyY2UkKTtcbiAqICAgY29uc29sZS5sb2coYFRoZSBmaXJzdCBudW1iZXIgaXMgJHsgZmlyc3ROdW1iZXIgfWApO1xuICogfVxuICpcbiAqIGV4ZWN1dGUoKTtcbiAqXG4gKiAvLyBFeHBlY3RlZCBvdXRwdXQ6XG4gKiAvLyAnVGhlIGZpcnN0IG51bWJlciBpcyAwJ1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgbGFzdFZhbHVlRnJvbX1cbiAqXG4gKiBAcGFyYW0gc291cmNlIHRoZSBvYnNlcnZhYmxlIHRvIGNvbnZlcnQgdG8gYSBwcm9taXNlXG4gKiBAcGFyYW0gY29uZmlnIGEgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gZGVmaW5lIHRoZSBgZGVmYXVsdFZhbHVlYCB0byB1c2UgaWYgdGhlIHNvdXJjZSBjb21wbGV0ZXMgd2l0aG91dCBlbWl0dGluZyBhIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdFZhbHVlRnJvbTxULCBEPihzb3VyY2U6IE9ic2VydmFibGU8VD4sIGNvbmZpZz86IEZpcnN0VmFsdWVGcm9tQ29uZmlnPEQ+KTogUHJvbWlzZTxUIHwgRD4ge1xuICBjb25zdCBoYXNDb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JztcbiAgcmV0dXJuIG5ldyBQcm9taXNlPFQgfCBEPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaWJlciA9IG5ldyBTYWZlU3Vic2NyaWJlcjxUPih7XG4gICAgICBuZXh0OiAodmFsdWUpID0+IHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIHN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgaWYgKGhhc0NvbmZpZykge1xuICAgICAgICAgIHJlc29sdmUoY29uZmlnIS5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRW1wdHlFcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgICBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICB9KTtcbn1cbiJdfQ==
