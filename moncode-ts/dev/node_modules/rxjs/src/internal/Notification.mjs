import { EMPTY } from './observable/empty.mjs';
import { of } from './observable/of.mjs';
import { throwError } from './observable/throwError.mjs';
import { isFunction } from './util/isFunction.mjs';
// TODO: When this enum is removed, replace it with a type alias. See #4556.
/**
 * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.
 * It will not be replaced with a const enum as those are not compatible with isolated modules.
 */
export var NotificationKind;
(function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 * @deprecated It is NOT recommended to create instances of `Notification` directly.
 * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.
 * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.
 * Will be removed in v8.
 */
export class Notification {
    constructor(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Executes the appropriate handler on a passed `observer` given the `kind` of notification.
     * If the handler is missing it will do nothing. Even if the notification is an error, if
     * there is no error handler on the observer, an error will not be thrown, it will noop.
     * @param observer The observer to notify.
     */
    observe(observer) {
        return observeNotification(this, observer);
    }
    do(nextHandler, errorHandler, completeHandler) {
        const { kind, value, error } = this;
        return kind === 'N' ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === 'E' ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
    }
    accept(nextOrObserver, error, complete) {
        return isFunction(nextOrObserver === null || nextOrObserver === void 0 ? void 0 : nextOrObserver.next)
            ? this.observe(nextOrObserver)
            : this.do(nextOrObserver, error, complete);
    }
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     *
     * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},
     * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.
     */
    toObservable() {
        const { kind, value, error } = this;
        // Select the observable to return by `kind`
        const result = kind === 'N'
            ? // Next kind. Return an observable of that value.
                of(value)
            : //
                kind === 'E'
                    ? // Error kind. Return an observable that emits the error.
                        throwError(() => error)
                    : //
                        kind === 'C'
                            ? // Completion kind. Kind is "C", return an observable that just completes.
                                EMPTY
                            : // Unknown kind, return falsy, so we error below.
                                0;
        if (!result) {
            // TODO: consider removing this check. The only way to cause this would be to
            // use the Notification constructor directly in a way that is not type-safe.
            // and direct use of the Notification constructor is deprecated.
            throw new TypeError(`Unexpected notification kind ${kind}`);
        }
        return result;
    }
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     * @nocollapse
     * @deprecated It is NOT recommended to create instances of `Notification` directly.
     * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.
     * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.
     * Will be removed in v8.
     */
    static createNext(value) {
        return new Notification('N', value);
    }
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     * @nocollapse
     * @deprecated It is NOT recommended to create instances of `Notification` directly.
     * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.
     * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.
     * Will be removed in v8.
     */
    static createError(err) {
        return new Notification('E', undefined, err);
    }
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     * @nocollapse
     * @deprecated It is NOT recommended to create instances of `Notification` directly.
     * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.
     * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.
     * Will be removed in v8.
     */
    static createComplete() {
        return Notification.completeNotification;
    }
}
Notification.completeNotification = new Notification('C');
/**
 * Executes the appropriate handler on a passed `observer` given the `kind` of notification.
 * If the handler is missing it will do nothing. Even if the notification is an error, if
 * there is no error handler on the observer, an error will not be thrown, it will noop.
 * @param notification The notification object to observe.
 * @param observer The observer to notify.
 */
export function observeNotification(notification, observer) {
    var _a, _b, _c;
    const { kind, value, error } = notification;
    if (typeof kind !== 'string') {
        throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === 'N' ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === 'E' ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9yeGpzL3NyYy9pbnRlcm5hbC9Ob3RpZmljYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNyQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDckQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRS9DLDRFQUE0RTtBQUM1RTs7O0dBR0c7QUFDSCxNQUFNLENBQU4sSUFBWSxnQkFJWDtBQUpELFdBQVksZ0JBQWdCO0lBQzFCLDhCQUFVLENBQUE7SUFDViwrQkFBVyxDQUFBO0lBQ1gsa0NBQWMsQ0FBQTtBQUNoQixDQUFDLEVBSlcsZ0JBQWdCLEtBQWhCLGdCQUFnQixRQUkzQjtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBNkJ2QixZQUE0QixJQUFxQixFQUFrQixLQUFTLEVBQWtCLEtBQVc7UUFBN0UsU0FBSSxHQUFKLElBQUksQ0FBaUI7UUFBa0IsVUFBSyxHQUFMLEtBQUssQ0FBSTtRQUFrQixVQUFLLEdBQUwsS0FBSyxDQUFNO1FBQ3ZHLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxLQUFLLEdBQUcsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxPQUFPLENBQUMsUUFBNEI7UUFDbEMsT0FBTyxtQkFBbUIsQ0FBQyxJQUFpQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUE0QkQsRUFBRSxDQUFDLFdBQStCLEVBQUUsWUFBaUMsRUFBRSxlQUE0QjtRQUNqRyxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDcEMsT0FBTyxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxXQUFXLGFBQVgs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bGVzL3J4anMvc3JjL2ludGVybmFsL05vdGlmaWNhdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcnRpYWxPYnNlcnZlciwgT2JzZXJ2YWJsZU5vdGlmaWNhdGlvbiwgQ29tcGxldGVOb3RpZmljYXRpb24sIE5leHROb3RpZmljYXRpb24sIEVycm9yTm90aWZpY2F0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IEVNUFRZIH0gZnJvbSAnLi9vYnNlcnZhYmxlL2VtcHR5JztcbmltcG9ydCB7IG9mIH0gZnJvbSAnLi9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IHRocm93RXJyb3IgfSBmcm9tICcuL29ic2VydmFibGUvdGhyb3dFcnJvcic7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi91dGlsL2lzRnVuY3Rpb24nO1xuXG4vLyBUT0RPOiBXaGVuIHRoaXMgZW51bSBpcyByZW1vdmVkLCByZXBsYWNlIGl0IHdpdGggYSB0eXBlIGFsaWFzLiBTZWUgIzQ1NTYuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBhIHN0cmluZyBsaXRlcmFsIGluc3RlYWQuIGBOb3RpZmljYXRpb25LaW5kYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYSB0eXBlIGFsaWFzIGluIHY4LlxuICogSXQgd2lsbCBub3QgYmUgcmVwbGFjZWQgd2l0aCBhIGNvbnN0IGVudW0gYXMgdGhvc2UgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggaXNvbGF0ZWQgbW9kdWxlcy5cbiAqL1xuZXhwb3J0IGVudW0gTm90aWZpY2F0aW9uS2luZCB7XG4gIE5FWFQgPSAnTicsXG4gIEVSUk9SID0gJ0UnLFxuICBDT01QTEVURSA9ICdDJyxcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcHVzaC1iYXNlZCBldmVudCBvciB2YWx1ZSB0aGF0IGFuIHtAbGluayBPYnNlcnZhYmxlfSBjYW4gZW1pdC5cbiAqIFRoaXMgY2xhc3MgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igb3BlcmF0b3JzIHRoYXQgbWFuYWdlIG5vdGlmaWNhdGlvbnMsXG4gKiBsaWtlIHtAbGluayBtYXRlcmlhbGl6ZX0sIHtAbGluayBkZW1hdGVyaWFsaXplfSwge0BsaW5rIG9ic2VydmVPbn0sIGFuZFxuICogb3RoZXJzLiBCZXNpZGVzIHdyYXBwaW5nIHRoZSBhY3R1YWwgZGVsaXZlcmVkIHZhbHVlLCBpdCBhbHNvIGFubm90YXRlcyBpdFxuICogd2l0aCBtZXRhZGF0YSBvZiwgZm9yIGluc3RhbmNlLCB3aGF0IHR5cGUgb2YgcHVzaCBtZXNzYWdlIGl0IGlzIChgbmV4dGAsXG4gKiBgZXJyb3JgLCBvciBgY29tcGxldGVgKS5cbiAqXG4gKiBAc2VlIHtAbGluayBtYXRlcmlhbGl6ZX1cbiAqIEBzZWUge0BsaW5rIGRlbWF0ZXJpYWxpemV9XG4gKiBAc2VlIHtAbGluayBvYnNlcnZlT259XG4gKiBAZGVwcmVjYXRlZCBJdCBpcyBOT1QgcmVjb21tZW5kZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBgTm90aWZpY2F0aW9uYCBkaXJlY3RseS5cbiAqIFJhdGhlciwgdHJ5IHRvIGNyZWF0ZSBQT0pPcyBtYXRjaGluZyB0aGUgc2lnbmF0dXJlIG91dGxpbmVkIGluIHtAbGluayBPYnNlcnZhYmxlTm90aWZpY2F0aW9ufS5cbiAqIEZvciBleGFtcGxlOiBgeyBraW5kOiAnTicsIHZhbHVlOiAxIH1gLCBgeyBraW5kOiAnRScsIGVycm9yOiBuZXcgRXJyb3IoJ2JhZCcpIH1gLCBvciBgeyBraW5kOiAnQycgfWAuXG4gKiBXaWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb248VD4ge1xuICAvKipcbiAgICogQSB2YWx1ZSBzaWduaWZ5aW5nIHRoYXQgdGhlIG5vdGlmaWNhdGlvbiB3aWxsIFwibmV4dFwiIGlmIG9ic2VydmVkLiBJbiB0cnV0aCxcbiAgICogVGhpcyBpcyByZWFsbHkgc3lub255bW91cyB3aXRoIGp1c3QgY2hlY2tpbmcgYGtpbmQgPT09IFwiTlwiYC5cbiAgICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY4LiBJbnN0ZWFkLCBqdXN0IGNoZWNrIHRvIHNlZSBpZiB0aGUgdmFsdWUgb2YgYGtpbmRgIGlzIGBcIk5cImAuXG4gICAqL1xuICByZWFkb25seSBoYXNWYWx1ZTogYm9vbGVhbjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFwiTmV4dFwiIG5vdGlmaWNhdGlvbiBvYmplY3QuXG4gICAqIEBwYXJhbSBraW5kIEFsd2F5cyBgJ04nYFxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIG5vdGlmeSB3aXRoIGlmIG9ic2VydmVkLlxuICAgKiBAZGVwcmVjYXRlZCBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuIFVzZSB7QGxpbmsgTm90aWZpY2F0aW9uI2NyZWF0ZU5leHQgY3JlYXRlTmV4dH0gaW5zdGVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGtpbmQ6ICdOJywgdmFsdWU/OiBUKTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gXCJFcnJvclwiIG5vdGlmaWNhdGlvbiBvYmplY3QuXG4gICAqIEBwYXJhbSBraW5kIEFsd2F5cyBgJ0UnYFxuICAgKiBAcGFyYW0gdmFsdWUgQWx3YXlzIGB1bmRlZmluZWRgXG4gICAqIEBwYXJhbSBlcnJvciBUaGUgZXJyb3IgdG8gbm90aWZ5IHdpdGggaWYgb2JzZXJ2ZWQuXG4gICAqIEBkZXByZWNhdGVkIEludGVybmFsIGltcGxlbWVudGF0aW9uIGRldGFpbC4gVXNlIHtAbGluayBOb3RpZmljYXRpb24jY3JlYXRlRXJyb3IgY3JlYXRlRXJyb3J9IGluc3RlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihraW5kOiAnRScsIHZhbHVlOiB1bmRlZmluZWQsIGVycm9yOiBhbnkpO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFwiY29tcGxldGlvblwiIG5vdGlmaWNhdGlvbiBvYmplY3QuXG4gICAqIEBwYXJhbSBraW5kIEFsd2F5cyBgJ0MnYFxuICAgKiBAZGVwcmVjYXRlZCBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuIFVzZSB7QGxpbmsgTm90aWZpY2F0aW9uI2NyZWF0ZUNvbXBsZXRlIGNyZWF0ZUNvbXBsZXRlfSBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2luZDogJ0MnKTtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGtpbmQ6ICdOJyB8ICdFJyB8ICdDJywgcHVibGljIHJlYWRvbmx5IHZhbHVlPzogVCwgcHVibGljIHJlYWRvbmx5IGVycm9yPzogYW55KSB7XG4gICAgdGhpcy5oYXNWYWx1ZSA9IGtpbmQgPT09ICdOJztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlciBvbiBhIHBhc3NlZCBgb2JzZXJ2ZXJgIGdpdmVuIHRoZSBga2luZGAgb2Ygbm90aWZpY2F0aW9uLlxuICAgKiBJZiB0aGUgaGFuZGxlciBpcyBtaXNzaW5nIGl0IHdpbGwgZG8gbm90aGluZy4gRXZlbiBpZiB0aGUgbm90aWZpY2F0aW9uIGlzIGFuIGVycm9yLCBpZlxuICAgKiB0aGVyZSBpcyBubyBlcnJvciBoYW5kbGVyIG9uIHRoZSBvYnNlcnZlciwgYW4gZXJyb3Igd2lsbCBub3QgYmUgdGhyb3duLCBpdCB3aWxsIG5vb3AuXG4gICAqIEBwYXJhbSBvYnNlcnZlciBUaGUgb2JzZXJ2ZXIgdG8gbm90aWZ5LlxuICAgKi9cbiAgb2JzZXJ2ZShvYnNlcnZlcjogUGFydGlhbE9ic2VydmVyPFQ+KTogdm9pZCB7XG4gICAgcmV0dXJuIG9ic2VydmVOb3RpZmljYXRpb24odGhpcyBhcyBPYnNlcnZhYmxlTm90aWZpY2F0aW9uPFQ+LCBvYnNlcnZlcik7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBub3RpZmljYXRpb24gb24gdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIgZnJvbSBhIGxpc3QgcHJvdmlkZWQuXG4gICAqIElmIGEgaGFuZGxlciBpcyBtaXNzaW5nIGZvciB0aGUga2luZCBvZiBub3RpZmljYXRpb24sIG5vdGhpbmcgaXMgY2FsbGVkXG4gICAqIGFuZCBubyBlcnJvciBpcyB0aHJvd24sIGl0IHdpbGwgYmUgYSBub29wLlxuICAgKiBAcGFyYW0gbmV4dCBBIG5leHQgaGFuZGxlclxuICAgKiBAcGFyYW0gZXJyb3IgQW4gZXJyb3IgaGFuZGxlclxuICAgKiBAcGFyYW0gY29tcGxldGUgQSBjb21wbGV0ZSBoYW5kbGVyXG4gICAqIEBkZXByZWNhdGVkIFJlcGxhY2VkIHdpdGgge0BsaW5rIE5vdGlmaWNhdGlvbiNvYnNlcnZlIG9ic2VydmV9LiBXaWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gICAqL1xuICBkbyhuZXh0OiAodmFsdWU6IFQpID0+IHZvaWQsIGVycm9yOiAoZXJyOiBhbnkpID0+IHZvaWQsIGNvbXBsZXRlOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgbm90aWZpY2F0aW9uIG9uIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVyIGZyb20gYSBsaXN0IHByb3ZpZGVkLlxuICAgKiBJZiBhIGhhbmRsZXIgaXMgbWlzc2luZyBmb3IgdGhlIGtpbmQgb2Ygbm90aWZpY2F0aW9uLCBub3RoaW5nIGlzIGNhbGxlZFxuICAgKiBhbmQgbm8gZXJyb3IgaXMgdGhyb3duLCBpdCB3aWxsIGJlIGEgbm9vcC5cbiAgICogQHBhcmFtIG5leHQgQSBuZXh0IGhhbmRsZXJcbiAgICogQHBhcmFtIGVycm9yIEFuIGVycm9yIGhhbmRsZXJcbiAgICogQGRlcHJlY2F0ZWQgUmVwbGFjZWQgd2l0aCB7QGxpbmsgTm90aWZpY2F0aW9uI29ic2VydmUgb2JzZXJ2ZX0uIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OC5cbiAgICovXG4gIGRvKG5leHQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgZXJyb3I6IChlcnI6IGFueSkgPT4gdm9pZCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgbmV4dCBoYW5kbGVyIGlmIHRoZSBOb3RpZmljYXRpb24gaXMgb2YgYGtpbmRgIGBcIk5cImAuIE90aGVyd2lzZVxuICAgKiB0aGlzIHdpbGwgbm90IGVycm9yLCBhbmQgaXQgd2lsbCBiZSBhIG5vb3AuXG4gICAqIEBwYXJhbSBuZXh0IFRoZSBuZXh0IGhhbmRsZXJcbiAgICogQGRlcHJlY2F0ZWQgUmVwbGFjZWQgd2l0aCB7QGxpbmsgTm90aWZpY2F0aW9uI29ic2VydmUgb2JzZXJ2ZX0uIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OC5cbiAgICovXG4gIGRvKG5leHQ6ICh2YWx1ZTogVCkgPT4gdm9pZCk6IHZvaWQ7XG4gIGRvKG5leHRIYW5kbGVyOiAodmFsdWU6IFQpID0+IHZvaWQsIGVycm9ySGFuZGxlcj86IChlcnI6IGFueSkgPT4gdm9pZCwgY29tcGxldGVIYW5kbGVyPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNvbnN0IHsga2luZCwgdmFsdWUsIGVycm9yIH0gPSB0aGlzO1xuICAgIHJldHVybiBraW5kID09PSAnTicgPyBuZXh0SGFuZGxlcj8uKHZhbHVlISkgOiBraW5kID09PSAnRScgPyBlcnJvckhhbmRsZXI/LihlcnJvcikgOiBjb21wbGV0ZUhhbmRsZXI/LigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgbm90aWZpY2F0aW9uIG9uIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVyIGZyb20gYSBsaXN0IHByb3ZpZGVkLlxuICAgKiBJZiBhIGhhbmRsZXIgaXMgbWlzc2luZyBmb3IgdGhlIGtpbmQgb2Ygbm90aWZpY2F0aW9uLCBub3RoaW5nIGlzIGNhbGxlZFxuICAgKiBhbmQgbm8gZXJyb3IgaXMgdGhyb3duLCBpdCB3aWxsIGJlIGEgbm9vcC5cbiAgICogQHBhcmFtIG5leHQgQSBuZXh0IGhhbmRsZXJcbiAgICogQHBhcmFtIGVycm9yIEFuIGVycm9yIGhhbmRsZXJcbiAgICogQHBhcmFtIGNvbXBsZXRlIEEgY29tcGxldGUgaGFuZGxlclxuICAgKiBAZGVwcmVjYXRlZCBSZXBsYWNlZCB3aXRoIHtAbGluayBOb3RpZmljYXRpb24jb2JzZXJ2ZSBvYnNlcnZlfS4gV2lsbCBiZSByZW1vdmVkIGluIHY4LlxuICAgKi9cbiAgYWNjZXB0KG5leHQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgZXJyb3I6IChlcnI6IGFueSkgPT4gdm9pZCwgY29tcGxldGU6ICgpID0+IHZvaWQpOiB2b2lkO1xuICAvKipcbiAgICogRXhlY3V0ZXMgYSBub3RpZmljYXRpb24gb24gdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIgZnJvbSBhIGxpc3QgcHJvdmlkZWQuXG4gICAqIElmIGEgaGFuZGxlciBpcyBtaXNzaW5nIGZvciB0aGUga2luZCBvZiBub3RpZmljYXRpb24sIG5vdGhpbmcgaXMgY2FsbGVkXG4gICAqIGFuZCBubyBlcnJvciBpcyB0aHJvd24sIGl0IHdpbGwgYmUgYSBub29wLlxuICAgKiBAcGFyYW0gbmV4dCBBIG5leHQgaGFuZGxlclxuICAgKiBAcGFyYW0gZXJyb3IgQW4gZXJyb3IgaGFuZGxlclxuICAgKiBAZGVwcmVjYXRlZCBSZXBsYWNlZCB3aXRoIHtAbGluayBOb3RpZmljYXRpb24jb2JzZXJ2ZSBvYnNlcnZlfS4gV2lsbCBiZSByZW1vdmVkIGluIHY4LlxuICAgKi9cbiAgYWNjZXB0KG5leHQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgZXJyb3I6IChlcnI6IGFueSkgPT4gdm9pZCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgbmV4dCBoYW5kbGVyIGlmIHRoZSBOb3RpZmljYXRpb24gaXMgb2YgYGtpbmRgIGBcIk5cImAuIE90aGVyd2lzZVxuICAgKiB0aGlzIHdpbGwgbm90IGVycm9yLCBhbmQgaXQgd2lsbCBiZSBhIG5vb3AuXG4gICAqIEBwYXJhbSBuZXh0IFRoZSBuZXh0IGhhbmRsZXJcbiAgICogQGRlcHJlY2F0ZWQgUmVwbGFjZWQgd2l0aCB7QGxpbmsgTm90aWZpY2F0aW9uI29ic2VydmUgb2JzZXJ2ZX0uIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OC5cbiAgICovXG4gIGFjY2VwdChuZXh0OiAodmFsdWU6IFQpID0+IHZvaWQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlciBvbiBhIHBhc3NlZCBgb2JzZXJ2ZXJgIGdpdmVuIHRoZSBga2luZGAgb2Ygbm90aWZpY2F0aW9uLlxuICAgKiBJZiB0aGUgaGFuZGxlciBpcyBtaXNzaW5nIGl0IHdpbGwgZG8gbm90aGluZy4gRXZlbiBpZiB0aGUgbm90aWZpY2F0aW9uIGlzIGFuIGVycm9yLCBpZlxuICAgKiB0aGVyZSBpcyBubyBlcnJvciBoYW5kbGVyIG9uIHRoZSBvYnNlcnZlciwgYW4gZXJyb3Igd2lsbCBub3QgYmUgdGhyb3duLCBpdCB3aWxsIG5vb3AuXG4gICAqIEBwYXJhbSBvYnNlcnZlciBUaGUgb2JzZXJ2ZXIgdG8gbm90aWZ5LlxuICAgKiBAZGVwcmVjYXRlZCBSZXBsYWNlZCB3aXRoIHtAbGluayBOb3RpZmljYXRpb24jb2JzZXJ2ZSBvYnNlcnZlfS4gV2lsbCBiZSByZW1vdmVkIGluIHY4LlxuICAgKi9cbiAgYWNjZXB0KG9ic2VydmVyOiBQYXJ0aWFsT2JzZXJ2ZXI8VD4pOiB2b2lkO1xuICBhY2NlcHQobmV4dE9yT2JzZXJ2ZXI6IFBhcnRpYWxPYnNlcnZlcjxUPiB8ICgodmFsdWU6IFQpID0+IHZvaWQpLCBlcnJvcj86IChlcnI6IGFueSkgPT4gdm9pZCwgY29tcGxldGU/OiAoKSA9PiB2b2lkKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oKG5leHRPck9ic2VydmVyIGFzIGFueSk/Lm5leHQpXG4gICAgICA/IHRoaXMub2JzZXJ2ZShuZXh0T3JPYnNlcnZlciBhcyBQYXJ0aWFsT2JzZXJ2ZXI8VD4pXG4gICAgICA6IHRoaXMuZG8obmV4dE9yT2JzZXJ2ZXIgYXMgKHZhbHVlOiBUKSA9PiB2b2lkLCBlcnJvciBhcyBhbnksIGNvbXBsZXRlIGFzIGFueSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQganVzdCBkZWxpdmVycyB0aGUgbm90aWZpY2F0aW9uIHJlcHJlc2VudGVkXG4gICAqIGJ5IHRoaXMgTm90aWZpY2F0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjguIFRvIGNvbnZlcnQgYSBgTm90aWZpY2F0aW9uYCB0byBhbiB7QGxpbmsgT2JzZXJ2YWJsZX0sXG4gICAqIHVzZSB7QGxpbmsgb2Z9IGFuZCB7QGxpbmsgZGVtYXRlcmlhbGl6ZX06IGBvZihub3RpZmljYXRpb24pLnBpcGUoZGVtYXRlcmlhbGl6ZSgpKWAuXG4gICAqL1xuICB0b09ic2VydmFibGUoKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgY29uc3QgeyBraW5kLCB2YWx1ZSwgZXJyb3IgfSA9IHRoaXM7XG4gICAgLy8gU2VsZWN0IHRoZSBvYnNlcnZhYmxlIHRvIHJldHVybiBieSBga2luZGBcbiAgICBjb25zdCByZXN1bHQgPVxuICAgICAga2luZCA9PT0gJ04nXG4gICAgICAgID8gLy8gTmV4dCBraW5kLiBSZXR1cm4gYW4gb2JzZXJ2YWJsZSBvZiB0aGF0IHZhbHVlLlxuICAgICAgICAgIG9mKHZhbHVlISlcbiAgICAgICAgOiAvL1xuICAgICAgICBraW5kID09PSAnRSdcbiAgICAgICAgPyAvLyBFcnJvciBraW5kLiBSZXR1cm4gYW4gb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBlcnJvci5cbiAgICAgICAgICB0aHJvd0Vycm9yKCgpID0+IGVycm9yKVxuICAgICAgICA6IC8vXG4gICAgICAgIGtpbmQgPT09ICdDJ1xuICAgICAgICA/IC8vIENvbXBsZXRpb24ga2luZC4gS2luZCBpcyBcIkNcIiwgcmV0dXJuIGFuIG9ic2VydmFibGUgdGhhdCBqdXN0IGNvbXBsZXRlcy5cbiAgICAgICAgICBFTVBUWVxuICAgICAgICA6IC8vIFVua25vd24ga2luZCwgcmV0dXJuIGZhbHN5LCBzbyB3ZSBlcnJvciBiZWxvdy5cbiAgICAgICAgICAwO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciByZW1vdmluZyB0aGlzIGNoZWNrLiBUaGUgb25seSB3YXkgdG8gY2F1c2UgdGhpcyB3b3VsZCBiZSB0b1xuICAgICAgLy8gdXNlIHRoZSBOb3RpZmljYXRpb24gY29uc3RydWN0b3IgZGlyZWN0bHkgaW4gYSB3YXkgdGhhdCBpcyBub3QgdHlwZS1zYWZlLlxuICAgICAgLy8gYW5kIGRpcmVjdCB1c2Ugb2YgdGhlIE5vdGlmaWNhdGlvbiBjb25zdHJ1Y3RvciBpcyBkZXByZWNhdGVkLlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5leHBlY3RlZCBub3RpZmljYXRpb24ga2luZCAke2tpbmR9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjb21wbGV0ZU5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24oJ0MnKSBhcyBOb3RpZmljYXRpb248bmV2ZXI+ICYgQ29tcGxldGVOb3RpZmljYXRpb247XG4gIC8qKlxuICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgbmV4dGAgZnJvbSBhXG4gICAqIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAqIEByZXR1cm4ge05vdGlmaWNhdGlvbjxUPn0gVGhlIFwibmV4dFwiIE5vdGlmaWNhdGlvbiByZXByZXNlbnRpbmcgdGhlXG4gICAqIGFyZ3VtZW50LlxuICAgKiBAbm9jb2xsYXBzZVxuICAgKiBAZGVwcmVjYXRlZCBJdCBpcyBOT1QgcmVjb21tZW5kZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBgTm90aWZpY2F0aW9uYCBkaXJlY3RseS5cbiAgICogUmF0aGVyLCB0cnkgdG8gY3JlYXRlIFBPSk9zIG1hdGNoaW5nIHRoZSBzaWduYXR1cmUgb3V0bGluZWQgaW4ge0BsaW5rIE9ic2VydmFibGVOb3RpZmljYXRpb259LlxuICAgKiBGb3IgZXhhbXBsZTogYHsga2luZDogJ04nLCB2YWx1ZTogMSB9YCwgYHsga2luZDogJ0UnLCBlcnJvcjogbmV3IEVycm9yKCdiYWQnKSB9YCwgb3IgYHsga2luZDogJ0MnIH1gLlxuICAgKiBXaWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlTmV4dDxUPih2YWx1ZTogVCkge1xuICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKCdOJywgdmFsdWUpIGFzIE5vdGlmaWNhdGlvbjxUPiAmIE5leHROb3RpZmljYXRpb248VD47XG4gIH1cblxuICAvKipcbiAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYGVycm9yYCBmcm9tIGFcbiAgICogZ2l2ZW4gZXJyb3IuXG4gICAqIEBwYXJhbSB7YW55fSBbZXJyXSBUaGUgYGVycm9yYCBlcnJvci5cbiAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPFQ+fSBUaGUgXCJlcnJvclwiIE5vdGlmaWNhdGlvbiByZXByZXNlbnRpbmcgdGhlXG4gICAqIGFyZ3VtZW50LlxuICAgKiBAbm9jb2xsYXBzZVxuICAgKiBAZGVwcmVjYXRlZCBJdCBpcyBOT1QgcmVjb21tZW5kZWQgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBgTm90aWZpY2F0aW9uYCBkaXJlY3RseS5cbiAgICogUmF0aGVyLCB0cnkgdG8gY3JlYXRlIFBPSk9zIG1hdGNoaW5nIHRoZSBzaWduYXR1cmUgb3V0bGluZWQgaW4ge0BsaW5rIE9ic2VydmFibGVOb3RpZmljYXRpb259LlxuICAgKiBGb3IgZXhhbXBsZTogYHsga2luZDogJ04nLCB2YWx1ZTogMSB9YCwgYHsga2luZDogJ0UnLCBlcnJvcjogbmV3IEVycm9yKCdiYWQnKSB9YCwgb3IgYHsga2luZDogJ0MnIH1gLlxuICAgKiBXaWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRXJyb3IoZXJyPzogYW55KSB7XG4gICAgcmV0dXJuIG5ldyBOb3RpZmljYXRpb24oJ0UnLCB1bmRlZmluZWQsIGVycikgYXMgTm90aWZpY2F0aW9uPG5ldmVyPiAmIEVycm9yTm90aWZpY2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2hvcnRjdXQgdG8gY3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlIG9mIHRoZSB0eXBlIGBjb21wbGV0ZWAuXG4gICAqIEByZXR1cm4ge05vdGlmaWNhdGlvbjxhbnk+fSBUaGUgdmFsdWVsZXNzIFwiY29tcGxldGVcIiBOb3RpZmljYXRpb24uXG4gICAqIEBub2NvbGxhcHNlXG4gICAqIEBkZXByZWNhdGVkIEl0IGlzIE5PVCByZWNvbW1lbmRlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGBOb3RpZmljYXRpb25gIGRpcmVjdGx5LlxuICAgKiBSYXRoZXIsIHRyeSB0byBjcmVhdGUgUE9KT3MgbWF0Y2hpbmcgdGhlIHNpZ25hdHVyZSBvdXRsaW5lZCBpbiB7QGxpbmsgT2JzZXJ2YWJsZU5vdGlmaWNhdGlvbn0uXG4gICAqIEZvciBleGFtcGxlOiBgeyBraW5kOiAnTicsIHZhbHVlOiAxIH1gLCBgeyBraW5kOiAnRScsIGVycm9yOiBuZXcgRXJyb3IoJ2JhZCcpIH1gLCBvciBgeyBraW5kOiAnQycgfWAuXG4gICAqIFdpbGwgYmUgcmVtb3ZlZCBpbiB2OC5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVDb21wbGV0ZSgpOiBOb3RpZmljYXRpb248bmV2ZXI+ICYgQ29tcGxldGVOb3RpZmljYXRpb24ge1xuICAgIHJldHVybiBOb3RpZmljYXRpb24uY29tcGxldGVOb3RpZmljYXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlciBvbiBhIHBhc3NlZCBgb2JzZXJ2ZXJgIGdpdmVuIHRoZSBga2luZGAgb2Ygbm90aWZpY2F0aW9uLlxuICogSWYgdGhlIGhhbmRsZXIgaXMgbWlzc2luZyBpdCB3aWxsIGRvIG5vdGhpbmcuIEV2ZW4gaWYgdGhlIG5vdGlmaWNhdGlvbiBpcyBhbiBlcnJvciwgaWZcbiAqIHRoZXJlIGlzIG5vIGVycm9yIGhhbmRsZXIgb24gdGhlIG9ic2VydmVyLCBhbiBlcnJvciB3aWxsIG5vdCBiZSB0aHJvd24sIGl0IHdpbGwgbm9vcC5cbiAqIEBwYXJhbSBub3RpZmljYXRpb24gVGhlIG5vdGlmaWNhdGlvbiBvYmplY3QgdG8gb2JzZXJ2ZS5cbiAqIEBwYXJhbSBvYnNlcnZlciBUaGUgb2JzZXJ2ZXIgdG8gbm90aWZ5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZU5vdGlmaWNhdGlvbjxUPihub3RpZmljYXRpb246IE9ic2VydmFibGVOb3RpZmljYXRpb248VD4sIG9ic2VydmVyOiBQYXJ0aWFsT2JzZXJ2ZXI8VD4pIHtcbiAgY29uc3QgeyBraW5kLCB2YWx1ZSwgZXJyb3IgfSA9IG5vdGlmaWNhdGlvbiBhcyBhbnk7XG4gIGlmICh0eXBlb2Yga2luZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vdGlmaWNhdGlvbiwgbWlzc2luZyBcImtpbmRcIicpO1xuICB9XG4gIGtpbmQgPT09ICdOJyA/IG9ic2VydmVyLm5leHQ/Lih2YWx1ZSEpIDoga2luZCA9PT0gJ0UnID8gb2JzZXJ2ZXIuZXJyb3I/LihlcnJvcikgOiBvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG59XG4iXX0=
